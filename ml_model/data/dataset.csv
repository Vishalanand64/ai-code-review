Code Snippet,Syntax Error,Optimization Suggestion,Time Complexity,Cyclomatic Complexity
"const isValid = (s) => { const stack = []; const map = { '(': ')', '{': '}', '[': ']' }; for (let char of s) { if (map[char]) stack.push(map[char]); else if (stack.pop() !== char) return false; } return stack.length === 0; }",No,No,O(n),3
"const climbStairs = (n) => { const dp = Array(n + 1).fill(0); dp[0] = 1; dp[1] = 1; for (let i = 2; i <= n; i++) dp[i] = dp[i - 1] + dp[i - 2]; return dp[n]; }",No,No,O(n),3
"const uniquePaths = (m, n) => { const dp = Array(m).fill().map(() => Array(n).fill(1)); for (let i = 1; i < m; i++) { for (let j = 1; j < n; j++) { dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } return dp[m - 1][n - 1]; }",No,No,O(m*n),3
"const reverseString = (s) => { let left = 0, right = s.length - 1; while (left < right) { [s[left], s[right]] = [s[right], s[left]]; left++; right--; } return s; }",No,No,O(n),3
"const findMedianSortedArrays = (nums1, nums2) => { const merged = [...nums1, ...nums2].sort((a, b) => a - b); const mid = Math.floor(merged.length / 2); return merged.length % 2 === 0 ? (merged[mid - 1] + merged[mid]) / 2 : merged[mid]; }",No,No,O((m+n) log(m+n)),3
"const maxArea = (height) => { let left = 0, right = height.length - 1, maxArea = 0; while (left < right) { const area = Math.min(height[left], height[right]) * (right - left); maxArea = Math.max(maxArea, area); height[left] < height[right] ? left++ : right--; } return maxArea; }",No,No,O(n),3
"const longestCommonPrefix = (strs) => { if (!strs.length) return ''; let prefix = strs[0]; for (let i = 1; i < strs.length; i++) { while (strs[i].indexOf(prefix) !== 0) prefix = prefix.slice(0, -1); } return prefix; }",No,No,O(n*m),3
"const threeSum = (nums) => { const result = []; nums.sort((a, b) => a - b); for (let i = 0; i < nums.length - 2; i++) { if (i > 0 && nums[i] === nums[i - 1]) continue; let left = i + 1, right = nums.length - 1; while (left < right) { const sum = nums[i] + nums[left] + nums[right]; if (sum === 0) { result.push([nums[i], nums[left], nums[right]]); while (nums[left] === nums[left + 1]) left++; while (nums[right] === nums[right - 1]) right--; left++; right--; } else if (sum < 0) left++; else right--; } } return result; }",No,No,O(n^2),3
"const groupAnagrams = (strs) => { const map = {}; for (let str of strs) { const sortedStr = str.split('').sort().join(''); map[sortedStr] ? map[sortedStr].push(str) : map[sortedStr] = [str]; } return Object.values(map); }",No,No,O(n*m log m),3
"const rotate = (nums, k) => { k %= nums.length; nums.reverse(); nums.reverse(0, k); nums.reverse(k); }",No,No,O(n),3
"const searchInsert = (nums, target) => { let left = 0, right = nums.length - 1; while (left <= right) { const mid = Math.floor((left + right) / 2); if (nums[mid] === target) return mid; else if (nums[mid] < target) left = mid + 1; else right = mid - 1; } return left; }",No,No,O(log n),3
"const removeDuplicates = (nums) => { if (!nums.length) return 0; let uniqueIndex = 0; for (let i = 1; i < nums.length; i++) { if (nums[i] !== nums[uniqueIndex]) { uniqueIndex++; nums[uniqueIndex] = nums[i]; } } return uniqueIndex + 1; }",No,No,O(n),3
"const isPalindrome = (s) => { const filtered = s.replace(/[^a-zA-Z0-9]/g, '').toLowerCase(); return filtered === filtered.split('').reverse().join(''); }",No,No,O(n),3
"const longestSubstrWithoutRepeating = (s) => { const set = new Set(); let left = 0, maxLength = 0; for (let right = 0; right < s.length; right++) { while (set.has(s[right])) { set.delete(s[left++]); } set.add(s[right]); maxLength = Math.max(maxLength, right - left + 1); } return maxLength; }",No,No,O(n),3
"const mergeIntervals = (intervals) => { if (!intervals.length) return []; intervals.sort((a, b) => a[0] - b[0]); const merged = [intervals[0]]; for (let i = 1; i < intervals.length; i++) { const current = intervals[i], lastMerged = merged[merged.length - 1]; if (current[0] <= lastMerged[1]) lastMerged[1] = Math.max(lastMerged[1], current[1]); else merged.push(current); } return merged; }",No,No,O(n log n),3
"const findPeakElement = (nums) => { let left = 0, right = nums.length - 1; while (left < right) { const mid = Math.floor((left + right) / 2); if (nums[mid] < nums[mid + 1]) left = mid + 1; else right = mid; } return left; }",No,No,O(log n),3
"const canJump = (nums) => { let maxReach = 0; for (let i = 0; i < nums.length; i++) { if (i > maxReach) return false; maxReach = Math.max(maxReach, i + nums[i]); } return true; }",No,No,O(n),3
"const trap = (height) => { let left = 0, right = height.length - 1, leftMax = 0, rightMax = 0, waterTrapped = 0; while (left < right) { if (height[left] < height[right]) { leftMax = Math.max(leftMax, height[left]); waterTrapped += leftMax - height[left++]; } else { rightMax = Math.max(rightMax, height[right]); waterTrapped += rightMax - height[right--]; } } return waterTrapped; }",No,No,O(n),3
"const maxSubArray = (nums) => { let maxSoFar = nums[0], maxEndingHere = nums[0]; for (let i = 1; i < nums.length; i++) { maxEndingHere = Math.max(nums[i], maxEndingHere + nums[i]); maxSoFar = Math.max(maxSoFar, maxEndingHere); } return maxSoFar; }",No,No,O(n),3
"const kClosest = (points, k) => { return points.sort((a, b) => (a[0] ** 2 + a[1] ** 2) - (b[0] ** 2 + b[1] ** 2)).slice(0, k); }",No,No,O(n log n),3
"const twoSum = (nums, target) => { const map = new Map(); for (let i = 0; i < nums.length; i++) { const complement = target - nums[i]; if (map.has(complement)) return [map.get(complement), i]; map.set(nums[i], i); } }",No,No,O(n),3
"const numberOfIslands = (grid) => { if (!grid.length) return 0; let count = 0; const dfs = (i, j) => { if (i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || grid[i][j] === '0') return; grid[i][j] = '0'; dfs(i - 1, j); dfs(i + 1, j); dfs(i, j - 1); dfs(i, j + 1); }; for (let i = 0; i < grid.length; i++) { for (let j = 0; j < grid[0].length; j++) { if (grid[i][j] === '1') { count++; dfs(i, j); } } } return count; }",No,No,O(m*n),3
"const longestPalindrome = (s) => { if (s.length < 1) return ''; let start = 0, end = 0; for (let i = 0; i < s.length; i++) { const len1 = expandAroundCenter(s, i, i); const len2 = expandAroundCenter(s, i, i + 1); const len = Math.max(len1, len2); if (len > end - start) { start = i - Math.floor((len - 1) / 2); end = i + Math.floor(len / 2); } } return s.slice(start, end + 1); }; const expandAroundCenter = (s, left, right) => { while (left >= 0 && right < s.length && s[left] === s[right]) { left--; right++; } return right - left - 1; };",No,No,O(n^2),3
"const permute = (nums) => { const result = []; const backtrack = (path, remaining) => { if (!remaining.length) result.push(path); for (let i = 0; i < remaining.length; i++) { backtrack([...path, remaining[i]], remaining.slice(0, i).concat(remaining.slice(i + 1))); } }; backtrack([], nums); return result; }",No,No,O(n!),3
"const combinationSum = (candidates, target) => { const result = []; const backtrack = (start, path, remain) => { if (remain === 0) result.push(path); else if (remain < 0) return; for (let i = start; i < candidates.length; i++) { backtrack(i, [...path, candidates[i]], remain - candidates[i]); } }; backtrack(0, [], target); return result; }",No,No,O(2^n),3
"const coinChange = (coins, amount) => { const dp = Array(amount + 1).fill(Infinity); dp[0] = 0; for (let coin of coins) { for (let i = coin; i <= amount; i++) { dp[i] = Math.min(dp[i], dp[i - coin] + 1); } } return dp[amount] === Infinity ? -1 : dp[amount]; }",No,No,O(n*amount),3
"const dailyTemperatures = (T) => { const result = Array(T.length).fill(0); const stack = []; for (let i = 0; i < T.length; i++) { while (stack.length && T[i] > T[stack[stack.length - 1]]) { const j = stack.pop(); result[j] = i - j; } stack.push(i); } return result; }",No,No,O(n),3
"const productExceptSelf = (nums) => { const result = Array(nums.length).fill(1); let left = 1, right = 1; for (let i = 0; i < nums.length; i++) { result[i] *= left; left *= nums[i]; result[nums.length - 1 - i] *= right; right *= nums[nums.length - 1 - i]; } return result; }",No,No,O(n),3
"const findKthLargest = (nums, k) => { return nums.sort((a, b) => b - a)[k - 1]; }",No,No,O(n log n),3
"const binaryTreePaths = (root) => { const result = []; const constructPaths = (node, path) => { if (!node) return; path += node.val + '->'; if (!node.left && !node.right) result.push(path.slice(0, -2)); constructPaths(node.left, path); constructPaths(node.right, path); }; constructPaths(root, ''); return result; }",No,No,O(n),3
"const invertTree = (root) => { if (!root) return null; [root.left, root.right] = [invertTree(root.right), invertTree(root.left)]; return root; }",No,No,O(n),3
"const isSymmetric = (root) => { const isMirror = (t1, t2) => { if (!t1 && !t2) return true; if (!t1 || !t2) return false; return (t1.val === t2.val) && isMirror(t1.left, t2.right) && isMirror(t1.right, t2.left); }; return isMirror(root, root); }",No,No,O(n),3
"const levelOrder = (root) => { if (!root) return []; const result = []; const queue = [root]; while (queue.length) { const level = []; const size = queue.length; for (let i = 0; i < size; i++) { const node = queue.shift(); level.push(node.val); if (node.left) queue.push(node.left); if (node.right) queue.push(node.right); } result.push(level); } return result; }",No,No,O(n),3
"const mergeTwoLists = (l1, l2) => { const dummy = new ListNode(0); let tail = dummy; while (l1 && l2) { if (l1.val < l2.val) { tail.next = l1; l1 = l1.next; } else { tail.next = l2; l2 = l2.next; } tail = tail.next; } tail.next = l1 || l2; return dummy.next; }",No,No,O(n),3
"const deleteNode = (node) => { node.val = node.next.val; node.next = node.next.next; }",No,No,O(1),3
"const reverseList = (head) => { let prev = null; while (head) { const nextTemp = head.next; head.next = prev; prev = head; head = nextTemp; } return prev; }",No,No,O(n),3
"const hasCycle = (head) => { let slow = head, fast = head; while (fast && fast.next) { slow = slow.next; fast = fast.next.next; if (slow === fast) return true; } return false; }",No,No,O(n),3
"const getIntersectionNode = (headA, headB) => { let a = headA, b = headB; while (a !== b) { a = a ? a.next : headB; b = b ? b.next : headA; } return a; }",No,No,O(n),3
"const reorderList = (head) => { if (!head || !head.next) return; let slow = head, fast = head; while (fast && fast.next) { slow = slow.next; fast = fast.next.next; } let prev = null, curr = slow; while (curr) { const next = curr.next; curr.next = prev; prev = curr; curr = next; } let first = head, second = prev; while (second) { const temp1 = first.next; const temp2 = second.next; first.next = second; second.next = temp1; first = temp1; second = temp2; } }",No,No,O(n),3
"const findDuplicate = (nums) => { let slow = nums[0], fast = nums[0]; while (true) { slow = nums[slow]; fast = nums[nums[fast]]; if (slow === fast) break; } let ptr1 = nums[0], ptr2 = slow; while (ptr1 !== ptr2) { ptr1 = nums[ptr1]; ptr2 = nums[ptr2]; } return ptr1; }",No,No,O(n),3
"const lengthOfLongestSubstring = (s) => { const map = {}; let left = 0, maxLength = 0; for (let right = 0; right < s.length; right++) { if (map[s[right]] !== undefined) left = Math.max(left, map[s[right]] + 1); map[s[right]] = right; maxLength = Math.max(maxLength, right - left + 1); } return maxLength; }",No,No,O(n),3
"const summaryRanges = (nums) => { const ranges = []; for (let i = 0; i < nums.length; i++) { const start = nums[i]; while (i + 1 < nums.length && nums[i + 1] === nums[i] + 1) i++; const end = nums[i]; ranges.push(start === end ? `${start}` : `${start}->${end}`); } return ranges; }",No,No,O(n),3
"const twoSumLessThanK = (A, K) => { let maxSum = -1; for (let i = 0; i < A.length; i++) { for (let j = i + 1; j < A.length; j++) { const sum = A[i] + A[j]; if (sum < K) maxSum = Math.max(maxSum, sum); } } return maxSum; }",No,No,O(n^2),3
"const longestMountain = (A) => { let maxLen = 0; for (let i = 1; i < A.length - 1; i++) { if (A[i] > A[i - 1] && A[i] > A[i + 1]) { let left = i, right = i; while (left > 0 && A[left - 1] < A[left]) left--; while (right < A.length - 1 && A[right + 1] < A[right]) right++; maxLen = Math.max(maxLen, right - left + 1); } } return maxLen; }",No,No,O(n),3
"const mostFrequent = (nums, key) => { const count = {}; for (let i = 0; i < nums.length - 1; i++) { if (nums[i] === key) { const nextNum = nums[i + 1]; count[nextNum] = (count[nextNum] || 0) + 1; } } return Object.keys(count).reduce((a, b) => (count[a] > count[b] ? a : b)); }",No,No,O(n),3
"const threeSum = (nums) => { const result = []; nums.sort((a, b) => a - b); for (let i = 0; i < nums.length; i++) { if (i > 0 && nums[i] === nums[i - 1]) continue; let left = i + 1, right = nums.length - 1; while (left < right) { const sum = nums[i] + nums[left] + nums[right]; if (sum < 0) left++; else if (sum > 0) right--; else { result.push([nums[i], nums[left], nums[right]]); while (left < right && nums[left] === nums[left + 1]) left++; while (left < right && nums[right] === nums[right - 1]) right--; left++; right--; } } } return result; }",No,No,O(n^2),3
"const containsNearbyAlmostDuplicate = (nums, k, t) => { const map = new Map(); for (let i = 0; i < nums.length; i++) { if (i > k) map.delete(nums[i - k - 1]); const left = Math.max(nums[i] - t, -2147483648); const right = Math.min(nums[i] + t, 2147483647); for (let j = left; j <= right; j++) { if (map.has(j) && Math.abs(map.get(j) - nums[i]) <= t) return true; } map.set(nums[i], i); } return false; }",No,No,O(n),3
"const minWindow = (s, t) => { const mapT = {}; const mapS = {}; for (const char of t) { mapT[char] = (mapT[char] || 0) + 1; } let required = Object.keys(mapT).length; let l = 0, r = 0; let formed = 0; let minLen = Infinity; let minL = 0; while (r < s.length) { const char = s[r]; mapS[char] = (mapS[char] || 0) + 1; if (mapS[char] === mapT[char]) formed++; while (l <= r && formed === required) { const charL = s[l]; if (r - l + 1 < minLen) { minLen = r - l + 1; minL = l; } mapS[charL]--; if (mapS[charL] < mapT[charL]) formed--; l++; } r++; } return minLen === Infinity ? "" : s.slice(minL, minL + minLen); }",No,No,O(n),3
"const findLongestChain = (pairs) => { pairs.sort((a, b) => a[1] - b[1]); let currentEnd = -Infinity, count = 0; for (const [start, end] of pairs) { if (start > currentEnd) { currentEnd = end; count++; } } return count; }",No,No,O(n log n),3
"const validPalindrome = (s) => { const isPalindrome = (s) => s === s.split('').reverse().join(''); for (let i = 0; i < s.length; i++) { const newStr = s.slice(0, i) + s.slice(i + 1); if (isPalindrome(newStr)) return true; } return false; }",No,No,O(n^2),3
"const numIslands2 = (m, n, positions) => { const grid = Array.from({ length: m }, () => Array(n).fill(0)); const parents = []; const find = (x) => { if (parents[x] !== x) parents[x] = find(parents[x]); return parents[x]; }; const union = (x, y) => { const rootX = find(x); const rootY = find(y); if (rootX !== rootY) parents[rootY] = rootX; }; const countIslands = () => { const islands = new Set(); for (let i = 0; i < m; i++) { for (let j = 0; j < n; j++) { if (grid[i][j] === 1) islands.add(find(i * n + j)); } } return islands.size; }; const result = []; for (const [x, y] of positions) { grid[x][y] = 1; parents[x * n + y] = x * n + y; for (const [dx, dy] of [[0, 1], [1, 0], [0, -1], [-1, 0]]) { const nx = x + dx, ny = y + dy; if (nx >= 0 && nx < m && ny >= 0 && ny < n && grid[nx][ny] === 1) union(x * n + y, nx * n + ny); } result.push(countIslands()); } return result; }",No,No,O(positions.length * (m + n)),3
"const maxProfit = (prices) => { let maxProfit = 0; let minPrice = Infinity; for (let price of prices) { minPrice = Math.min(minPrice, price); maxProfit = Math.max(maxProfit, price - minPrice); } return maxProfit; }",No,No,O(n),3
"const findKthSmallest = (matrix, k) => { const flat = [].concat(...matrix); flat.sort((a, b) => a - b); return flat[k - 1]; }",No,No,O(n log n),3
"const lastStoneWeight = (stones) => { const heap = new MaxPriorityQueue(); for (const stone of stones) { heap.enqueue(stone); } while (heap.size() > 1) { const stone1 = heap.dequeue().element; const stone2 = heap.dequeue().element; if (stone1 !== stone2) heap.enqueue(stone1 - stone2); } return heap.size() === 0 ? 0 : heap.dequeue().element; }",No,No,O(n log n),3
"const nthUglyNumber = (n) => { const dp = [1]; let i2 = 0, i3 = 0, i5 = 0; while (dp.length < n) { const nextUgly = Math.min(dp[i2] * 2, dp[i3] * 3, dp[i5] * 5); dp.push(nextUgly); if (nextUgly === dp[i2] * 2) i2++; if (nextUgly === dp[i3] * 3) i3++; if (nextUgly === dp[i5] * 5) i5++; } return dp[n - 1]; }",No,No,O(n),3
"const longestValidParentheses = (s) => { const stack = [-1]; let maxLength = 0; for (let i = 0; i < s.length; i++) { if (s[i] === '(') stack.push(i); else { stack.pop(); if (stack.length === 0) stack.push(i); else maxLength = Math.max(maxLength, i - stack[stack.length - 1]); } } return maxLength; }",No,No,O(n),3
"const maxArea = (height) => { let maxArea = 0, left = 0, right = height.length - 1; while (left < right) { const area = Math.min(height[left], height[right]) * (right - left); maxArea = Math.max(maxArea, area); if (height[left] < height[right]) left++; else right--; } return maxArea; }",No,No,O(n),3
"const climbStairs = (n) => { if (n <= 2) return n; let first = 1, second = 2; for (let i = 3; i <= n; i++) { const next = first + second; first = second; second = next; } return second; }",No,No,O(n),3
"const myAtoi = (s) => { s = s.trim(); let i = 0, sign = 1, total = 0; if (s[i] === '-' || s[i] === '+') { sign = s[i++] === '-' ? -1 : 1; } while (i < s.length && s[i] >= '0' && s[i] <= '9') { total = total * 10 + (s[i++] - '0'); } total *= sign; return Math.max(Math.min(total, 2 ** 31 - 1), -(2 ** 31)); }",No,No,O(n),3
"const generateParenthesis = (n) => { const res = []; const backtrack = (current, open, close) => { if (current.length === 2 * n) { res.push(current); return; } if (open < n) backtrack(current + '(', open + 1, close); if (close < open) backtrack(current + ')', open, close + 1); }; backtrack('', 0, 0); return res; }",No,No,O(2^n),3
"const permuteUnique = (nums) => { const res = []; nums.sort((a, b) => a - b); const backtrack = (start) => { if (start === nums.length) { res.push([...nums]); return; } for (let i = start; i < nums.length; i++) { if (i > start && nums[i] === nums[i - 1]) continue; [nums[start], nums[i]] = [nums[i], nums[start]]; backtrack(start + 1); [nums[start], nums[i]] = [nums[i], nums[start]]; } }; backtrack(0); return res; }",No,No,O(n!),3
"const partitionLabels = (s) => { const last = {}; for (let i = 0; i < s.length; i++) last[s[i]] = i; let partitions = [], j = 0, anchor = 0; for (let i = 0; i < s.length; i++) { j = Math.max(j, last[s[i]]); if (i === j) { partitions.push(i - anchor + 1); anchor = i + 1; } } return partitions; }",No,No,O(n),3
"const kClosest = (points, k) => { points.sort((a, b) => a[0] ** 2 + a[1] ** 2 - (b[0] ** 2 + b[1] ** 2)); return points.slice(0, k); }",No,No,O(n log n),3
"const search = (nums, target) => { let left = 0, right = nums.length - 1; while (left <= right) { const mid = Math.floor((left + right) / 2); if (nums[mid] === target) return mid; if (nums[left] <= nums[mid]) { if (nums[left] <= target && target < nums[mid]) right = mid - 1; else left = mid + 1; } else { if (nums[mid] < target && target <= nums[right]) left = mid + 1; else right = mid - 1; } } return -1; }",No,No,O(log n),3
"const maxCoins = (nums) => { const n = nums.length; const dp = Array(n + 2).fill(0); nums = [1, ...nums, 1]; for (let i = n; i >= 1; i--) { for (let j = i; j <= n; j++) { dp[j] = Math.max(dp[j], dp[j - 1] + nums[i] * nums[j] * nums[j + 1]); } } return dp[n]; }",No,No,O(n^3),3
"const canConstruct = (ransomNote, magazine) => { const count = {}; for (const char of magazine) { count[char] = (count[char] || 0) + 1; } for (const char of ransomNote) { if (!count[char]) return false; count[char]--; } return true; }",No,No,O(m + n),3
"const countSubstrings = (s) => { let count = 0; const dp = Array.from({ length: s.length }, () => Array(s.length).fill(false)); for (let end = 0; end < s.length; end++) { for (let start = end; start >= 0; start--) { if (s[start] === s[end] && (end - start < 2 || dp[start + 1][end - 1])) { dp[start][end] = true; count++; } } } return count; }",No,No,O(n^2),3
"const shortestPalindrome = (s) => { const revS = s.split('').reverse().join(''); const l = s + '#' + revS; const n = l.length; const lps = Array(n).fill(0); for (let i = 1; i < n; i++) { let j = lps[i - 1]; while (j > 0 && l[i] !== l[j]) j = lps[j - 1]; if (l[i] === l[j]) j++; lps[i] = j; } return revS.slice(0, s.length - lps[n - 1]) + s; }",No,No,O(n),3
"const groupAnagrams = (strs) => { const map = {}; for (const str of strs) { const key = str.split('').sort().join(''); if (!map[key]) map[key] = []; map[key].push(str); } return Object.values(map); }",No,No,O(n * k log k),3
"const trap = (height) => { if (height.length === 0) return 0; let left = 0, right = height.length - 1, leftMax = height[left], rightMax = height[right], water = 0; while (left < right) { if (leftMax < rightMax) { left++; leftMax = Math.max(leftMax, height[left]); water += leftMax - height[left]; } else { right--; rightMax = Math.max(rightMax, height[right]); water += rightMax - height[right]; } } return water; }",No,No,O(n),3
"const longestCommonPrefix = (strs) => { if (!strs.length) return ''; let prefix = strs[0]; for (let i = 1; i < strs.length; i++) { while (strs[i].indexOf(prefix) !== 0) { prefix = prefix.slice(0, -1); if (!prefix) return ''; } } return prefix; }",No,No,O(n * m),3
"const searchRange = (nums, target) => { const findLeft = (nums, target) => { let left = 0, right = nums.length - 1; while (left <= right) { const mid = Math.floor((left + right) / 2); if (nums[mid] < target) left = mid + 1; else right = mid - 1; } return left; }; const findRight = (nums, target) => { let left = 0, right = nums.length - 1; while (left <= right) { const mid = Math.floor((left + right) / 2); if (nums[mid] <= target) left = mid + 1; else right = mid - 1; } return right; }; const leftIndex = findLeft(nums, target); const rightIndex = findRight(nums, target); return leftIndex <= rightIndex ? [leftIndex, rightIndex] : [-1, -1]; }",No,No,O(log n),3
"const minCostToMoveChips = (position) => { let odd = 0, even = 0; for (const p of position) { if (p % 2 === 0) even++; else odd++; } return Math.min(odd, even); }",No,No,O(n),3
"const longestSubstring = (s, k) => { const map = {}; for (const char of s) { map[char] = (map[char] || 0) + 1; } let maxLen = 0; for (const [char, count] of Object.entries(map)) { if (count < k) { const filtered = s.split(char).join(''); maxLen = Math.max(maxLen, longestSubstring(filtered, k)); } } return Math.max(maxLen, s.length); }",No,No,O(n^2),3
"const combinationSum = (candidates, target) => { const res = []; const backtrack = (start, target, path) => { if (target === 0) { res.push(path); return; } if (target < 0) return; for (let i = start; i < candidates.length; i++) { backtrack(i, target - candidates[i], [...path, candidates[i]]); } }; backtrack(0, target, []); return res; }",No,No,O(2^n),3
"const longestSubstringWithoutRepeating = (s) => { const chars = new Set(); let left = 0, maxLen = 0; for (let right = 0; right < s.length; right++) { while (chars.has(s[right])) { chars.delete(s[left]); left++; } chars.add(s[right]); maxLen = Math.max(maxLen, right - left + 1); } return maxLen; }",No,No,O(n),3
"const isPalindrome = (s) => { const cleanStr = s.replace(/[^a-zA-Z0-9]/g, '').toLowerCase(); return cleanStr === cleanStr.split('').reverse().join(''); }",No,No,O(n),3
"const dailyTemperatures = (T) => { const stack = []; const res = Array(T.length).fill(0); for (let i = 0; i < T.length; i++) { while (stack.length && T[i] > T[stack[stack.length - 1]]) { const j = stack.pop(); res[j] = i - j; } stack.push(i); } return res; }",No,No,O(n),3
"const maxProfit = (prices) => { let maxProfit = 0; let minPrice = Infinity; for (const price of prices) { if (price < minPrice) minPrice = price; else maxProfit = Math.max(maxProfit, price - minPrice); } return maxProfit; }",No,No,O(n),3
"const restoreString = (s, indices) => { const res = Array(s.length); for (let i = 0; i < s.length; i++) { res[indices[i]] = s[i]; } return res.join(''); }",No,No,O(n),3
"const rotate = (nums, k) => { k %= nums.length; const reverse = (arr, start, end) => { while (start < end) { [arr[start], arr[end]] = [arr[end], arr[start]]; start++; end--; } }; reverse(nums, 0, nums.length - 1); reverse(nums, 0, k - 1); reverse(nums, k, nums.length - 1); }",No,No,O(n),3
"const removeDuplicates = (nums) => { let i = 0; for (let j = 1; j < nums.length; j++) { if (nums[i] !== nums[j]) { i++; nums[i] = nums[j]; } } return i + 1; }",No,No,O(n),3
"const numDecodings = (s) => { if (s[0] === '0') return 0; const dp = Array(s.length + 1).fill(0); dp[0] = 1; dp[1] = 1; for (let i = 2; i <= s.length; i++) { if (s[i - 1] !== '0') dp[i] += dp[i - 1]; if (s[i - 2] === '1' || (s[i - 2] === '2' && s[i - 1] <= '6')) dp[i] += dp[i - 2]; } return dp[s.length]; }",No,No,O(n),3
"const climbStairs = (n) => { if (n <= 2) return n; let first = 1, second = 2; for (let i = 3; i <= n; i++) { [first, second] = [second, first + second]; } return second; }",No,No,O(n),3
"const findMedianSortedArrays = (nums1, nums2) => { const merge = (arr1, arr2) => { const merged = []; let i = 0, j = 0; while (i < arr1.length || j < arr2.length) { if (i < arr1.length && (j >= arr2.length || arr1[i] < arr2[j])) merged.push(arr1[i++]); else merged.push(arr2[j++]); } return merged; }; const merged = merge(nums1, nums2); const mid = merged.length / 2; return mid % 1 === 0 ? (merged[mid - 1] + merged[mid]) / 2 : merged[Math.floor(mid)]; }",No,No,O(n),3
"const letterCombinations = (digits) => { if (!digits) return []; const mapping = { 2: 'abc', 3: 'def', 4: 'ghi', 5: 'jkl', 6: 'mno', 7: 'pqrs', 8: 'tuv', 9: 'wxyz' }; const res = []; const backtrack = (index, path) => { if (index === digits.length) { res.push(path); return; } for (const char of mapping[digits[index]]) backtrack(index + 1, path + char); }; backtrack(0, ''); return res; }",No,No,O(3^n),3
"const validParentheses = (s) => { const stack = []; for (const char of s) { if (char === '(') stack.push(')'); else if (char === '{') stack.push('}'); else if (char === '[') stack.push(']'); else if (stack.pop() !== char) return false; } return stack.length === 0; }",No,No,O(n),3
"const minDistance = (word1, word2) => { const dp = Array.from({ length: word1.length + 1 }, () => Array(word2.length + 1).fill(0)); for (let i = 0; i <= word1.length; i++) dp[i][0] = i; for (let j = 0; j <= word2.length; j++) dp[0][j] = j; for (let i = 1; i <= word1.length; i++) { for (let j = 1; j <= word2.length; j++) { if (word1[i - 1] === word2[j - 1]) dp[i][j] = dp[i - 1][j - 1]; else dp[i][j] = 1 + Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]); } } return dp[word1.length][word2.length]; }",No,No,O(m*n),3
"const isValidSudoku = (board) => { const rows = Array(9).fill(null).map(() => new Set()); const cols = Array(9).fill(null).map(() => new Set()); const boxes = Array(9).fill(null).map(() => new Set()); for (let r = 0; r < 9; r++) { for (let c = 0; c < 9; c++) { if (board[r][c] !== '.') { if (rows[r].has(board[r][c])) return false; rows[r].add(board[r][c]); if (cols[c].has(board[r][c])) return false; cols[c].add(board[r][c]); const boxIdx = Math.floor(r / 3) * 3 + Math.floor(c / 3); if (boxes[boxIdx].has(board[r][c])) return false; boxes[boxIdx].add(board[r][c]); } } } return true; }",No,No,O(n^2),3
"const maxArea = (height) => { let left = 0, right = height.length - 1; let maxArea = 0; while (left < right) { maxArea = Math.max(maxArea, Math.min(height[left], height[right]) * (right - left)); if (height[left] < height[right]) left++; else right--; } return maxArea; }",No,No,O(n),3
"const subsets = (nums) => { const res = []; const backtrack = (start, path) => { res.push(path); for (let i = start; i < nums.length; i++) { backtrack(i + 1, [...path, nums[i]]); } }; backtrack(0, []); return res; }",No,No,O(2^n),3
"const findDuplicate = (nums) => { let slow = nums[0], fast = nums[0]; do { slow = nums[slow]; fast = nums[nums[fast]]; } while (slow !== fast); let entry = nums[0]; while (entry !== slow) { entry = nums[entry]; slow = nums[slow]; } return entry; }",No,No,O(n),3
"const lengthOfLIS = (nums) => { const dp = Array(nums.length).fill(1); for (let i = 1; i < nums.length; i++) { for (let j = 0; j < i; j++) { if (nums[i] > nums[j]) dp[i] = Math.max(dp[i], dp[j] + 1); } } return Math.max(...dp); }",No,No,O(n^2),3
"const validAnagram = (s, t) => { if (s.length !== t.length) return false; const count = {}; for (const char of s) { count[char] = (count[char] || 0) + 1; } for (const char of t) { if (!count[char]) return false; count[char]--; } return true; }",No,No,O(n),3
"const minPathSum = (grid) => { const m = grid.length, n = grid[0].length; const dp = Array.from({ length: m }, () => Array(n).fill(0)); dp[0][0] = grid[0][0]; for (let i = 1; i < m; i++) dp[i][0] = dp[i - 1][0] + grid[i][0]; for (let j = 1; j < n; j++) dp[0][j] = dp[0][j - 1] + grid[0][j]; for (let i = 1; i < m; i++) { for (let j = 1; j < n; j++) dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]; } return dp[m - 1][n - 1]; }",No,No,O(m*n),3
"const findFirstAndLastPosition = (nums, target) => { const binarySearch = (left) => { let low = 0, high = nums.length - 1; while (low <= high) { const mid = Math.floor((low + high) / 2); if (nums[mid] > target || (left && nums[mid] === target)) high = mid - 1; else low = mid + 1; } return low; }; const start = binarySearch(true); const end = binarySearch(false) - 1; return (start <= end) ? [start, end] : [-1, -1]; };",No,No,O(log n),3
"const productExceptSelf = (nums) => { const output = Array(nums.length).fill(1); let prefix = 1; for (let i = 0; i < nums.length; i++) { output[i] *= prefix; prefix *= nums[i]; } let postfix = 1; for (let i = nums.length - 1; i >= 0; i--) { output[i] *= postfix; postfix *= nums[i]; } return output; }",No,No,O(n),3
"const largestRectangleArea = (heights) => { const stack = []; let maxArea = 0; for (let i = 0; i <= heights.length; i++) { while (stack.length && (i === heights.length || heights[stack[stack.length - 1]] > heights[i])) { const h = heights[stack.pop()]; const w = stack.length ? i - stack[stack.length - 1] - 1 : i; maxArea = Math.max(maxArea, h * w); } stack.push(i); } return maxArea; }",No,No,O(n),3
"const combinationSum = (candidates, target) => { const res = []; const backtrack = (start, target, path) => { if (target === 0) { res.push(path); return; } for (let i = start; i < candidates.length; i++) { if (candidates[i] > target) continue; backtrack(i, target - candidates[i], [...path, candidates[i]]); } }; backtrack(0, target, []); return res; }",No,No,O(2^n),3
"const uniquePaths = (m, n) => { const dp = Array.from({ length: m }, () => Array(n).fill(1)); for (let i = 1; i < m; i++) { for (let j = 1; j < n; j++) { dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } return dp[m - 1][n - 1]; }",No,No,O(m*n),3
"const spiralOrder = (matrix) => { const result = []; if (!matrix.length) return result; let left = 0, right = matrix[0].length - 1, top = 0, bottom = matrix.length - 1; while (left <= right && top <= bottom) { for (let i = left; i <= right; i++) result.push(matrix[top][i]); top++; for (let i = top; i <= bottom; i++) result.push(matrix[i][right]); right--; if (top <= bottom) { for (let i = right; i >= left; i--) result.push(matrix[bottom][i]); bottom--; } if (left <= right) { for (let i = bottom; i >= top; i--) result.push(matrix[i][left]); left++; } } return result; }",No,No,O(m*n),3
"const reverseString = (s) => { return s.split('').reverse().join(''); }",No,No,O(n),3
"const groupAnagrams = (strs) => { const map = new Map(); for (const str of strs) { const key = str.split('').sort().join(''); if (!map.has(key)) map.set(key, []); map.get(key).push(str); } return Array.from(map.values()); }",No,No,O(n*k*log k),3
"const isHappy = (n) => { const seen = new Set(); while (n !== 1 && !seen.has(n)) { seen.add(n); n = n.toString().split('').reduce((sum, digit) => sum + Math.pow(digit, 2), 0); } return n === 1; }",No,No,O(log n),3
"const longestCommonPrefix = (strs) => { if (!strs.length) return ''; let prefix = strs[0]; for (let i = 1; i < strs.length; i++) { while (strs[i].indexOf(prefix) !== 0) prefix = prefix.substring(0, prefix.length - 1); } return prefix; }",No,No,O(n*m),3
"const findKthLargest = (nums, k) => { const quickSelect = (left, right, kSmallest) => { if (left === right) return nums[left]; const pivotIndex = Math.floor((right + left) / 2); const pivot = nums[pivotIndex]; const partition = (left, right) => { let leftPointer = left, rightPointer = right; while (leftPointer <= rightPointer) { while (nums[leftPointer] < pivot) leftPointer++; while (nums[rightPointer] > pivot) rightPointer--; if (leftPointer <= rightPointer) { [nums[leftPointer], nums[rightPointer]] = [nums[rightPointer], nums[leftPointer]]; leftPointer++; rightPointer--; } } return leftPointer; }; const newPivotIndex = partition(left, right); if (kSmallest < newPivotIndex) return quickSelect(left, newPivotIndex - 1, kSmallest); else return quickSelect(newPivotIndex, right, kSmallest); }; return quickSelect(0, nums.length - 1, nums.length - k); }",No,No,O(n),3
"const canJump = (nums) => { let reachable = 0; for (let i = 0; i < nums.length; i++) { if (i > reachable) return false; reachable = Math.max(reachable, i + nums[i]); } return true; }",No,No,O(n),3
"const increasingTriplet = (nums) => { let first = Infinity, second = Infinity; for (const num of nums) { if (num <= first) first = num; else if (num <= second) second = num; else return true; } return false; }",No,No,O(n),3
"const majorityElement = (nums) => { const count = {}; for (const num of nums) { count[num] = (count[num] || 0) + 1; if (count[num] > nums.length / 2) return num; } }",No,No,O(n),3
"const lengthOfLastWord = (s) => { let length = 0; for (let i = s.length - 1; i >= 0; i--) { if (s[i] === ' ' && length > 0) break; if (s[i] !== ' ') length++; } return length; }",No,No,O(n),3
"const searchInsert = (nums, target) => { let left = 0, right = nums.length; while (left < right) { const mid = Math.floor((left + right) / 2); if (nums[mid] < target) left = mid + 1; else right = mid; } return left; }",No,No,O(log n),3
"const reverseWords = (s) => { return s.trim().split(/\s+/).reverse().join(' '); }",No,No,O(n),3
"const singleNumber = (nums) => { return nums.reduce((acc, num) => acc ^ num, 0); }",No,No,O(n),3
"const isSubsequence = (s, t) => { let sIndex = 0, tIndex = 0; while (sIndex < s.length && tIndex < t.length) { if (s[sIndex] === t[tIndex]) sIndex++; tIndex++; } return sIndex === s.length; }",No,No,O(n),3
"const numIslands = (grid) => { const visited = new Set(); let islands = 0; for (let i = 0; i < grid.length; i++) { for (let j = 0; j < grid[0].length; j++) { if (grid[i][j] === '1' && !visited.has(`${i},${j}`)) { islands++; const dfs = (r, c) => { if (r < 0 || r >= grid.length || c < 0 || c >= grid[0].length || grid[r][c] === '0' || visited.has(`${r},${c}`)) return; visited.add(`${r},${c}`); dfs(r + 1, c); dfs(r - 1, c); dfs(r, c + 1); dfs(r, c - 1); }; dfs(i, j); } } } return islands; }",No,No,O(m*n),3
"const merge = (intervals) => { if (intervals.length === 0) return []; intervals.sort((a, b) => a[0] - b[0]); const merged = [intervals[0]]; for (let i = 1; i < intervals.length; i++) { const [start, end] = intervals[i]; const [lastStart, lastEnd] = merged[merged.length - 1]; if (start <= lastEnd) { merged[merged.length - 1][1] = Math.max(lastEnd, end); } else { merged.push(intervals[i]); } } return merged; }",No,No,O(n*log n),3
"const rotate = (nums, k) => { k %= nums.length; const reverse = (arr, start, end) => { while (start < end) { [arr[start], arr[end]] = [arr[end], arr[start]]; start++; end--; } }; reverse(nums, 0, nums.length - 1); reverse(nums, 0, k - 1); reverse(nums, k, nums.length - 1); }",No,No,O(n),3
"const generateParenthesis = (n) => { const res = []; const backtrack = (left, right, path) => { if (left === 0 && right === 0) { res.push(path); return; } if (left > 0) backtrack(left - 1, right, path + '('); if (right > left) backtrack(left, right - 1, path + ')'); }; backtrack(n, n, ''); return res; }",No,No,O(2^n),3
"const subsets = (nums) => { const res = []; const backtrack = (start, path) => { res.push(path); for (let i = start; i < nums.length; i++) { backtrack(i + 1, [...path, nums[i]]); } }; backtrack(0, []); return res; }",No,No,O(2^n),3
"const validParentheses = (s) => { const stack = []; for (let char of s) { if (char === '(') stack.push(char); else if (char === ')') { if (!stack.length) return false; stack.pop(); } } return stack.length === 0; }",No,No,O(n),3
"const minPathSum = (grid) => { const m = grid.length, n = grid[0].length; for (let i = 0; i < m; i++) { for (let j = 0; j < n; j++) { if (i === 0 && j === 0) continue; grid[i][j] += Math.min(i > 0 ? grid[i - 1][j] : Infinity, j > 0 ? grid[i][j - 1] : Infinity); } } return grid[m - 1][n - 1]; }",No,No,O(m*n),3
"const removeDuplicates = (nums) => { if (nums.length === 0) return 0; let j = 0; for (let i = 1; i < nums.length; i++) { if (nums[i] !== nums[j]) { j++; nums[j] = nums[i]; } } return j + 1; }",No,No,O(n),3
"const climbStairs = (n) => { const dp = Array(n + 1).fill(0); dp[0] = 1; dp[1] = 1; for (let i = 2; i <= n; i++) { dp[i] = dp[i - 1] + dp[i - 2]; } return dp[n]; }",No,No,O(n),3
"const longestSubstring = (s, k) => { const count = {}; for (let char of s) count[char] = (count[char] || 0) + 1; let maxLength = 0; for (let i = 1; i <= 26; i++) { let start = 0, end = 0, uniqueCount = 0; while (end < s.length) { if (uniqueCount <= i) { if (uniqueCount === i) maxLength = Math.max(maxLength, end - start); if (uniqueCount < i) { if (count[s[end]] === 0) uniqueCount++; count[s[end]]++; } end++; } else { if (count[s[start]] === 1) uniqueCount--; count[s[start]]--; start++; } } } } return maxLength; }",No,No,O(n^2),3
"const searchRange = (nums, target) => { const binarySearch = (left) => { let low = 0, high = nums.length - 1; while (low <= high) { const mid = Math.floor((low + high) / 2); if (nums[mid] > target || (left && nums[mid] === target)) high = mid - 1; else low = mid + 1; } return low; }; const start = binarySearch(true); const end = binarySearch(false) - 1; return (start <= end) ? [start, end] : [-1, -1]; };",No,No,O(log n),3
"const longestPalindrome = (s) => { if (s.length < 1) return ''; let start = 0, end = 0; const expandFromCenter = (left, right) => { while (left >= 0 && right < s.length && s[left] === s[right]) { left--; right++; } return right - left - 1; }; for (let i = 0; i < s.length; i++) { const len1 = expandFromCenter(i, i); const len2 = expandFromCenter(i, i + 1); const len = Math.max(len1, len2); if (len > end - start) { start = i - Math.floor((len - 1) / 2); end = i + Math.floor(len / 2); } } return s.substring(start, end + 1); }",No,No,O(n^2),3
"const twoSum = (nums, target) => { const map = new Map(); for (let i = 0; i < nums.length; i++) { const complement = target - nums[i]; if (map.has(complement)) return [map.get(complement), i]; map.set(nums[i], i); } return []; }",No,No,O(n),3
"const rotateArray = (arr, d) => { const n = arr.length; const gcd = (a, b) => { return b ? gcd(b, a % b) : a; }; const swap = (start, end) => { while (start < end) { [arr[start], arr[end]] = [arr[end], arr[start]]; start++; end--; } }; const rotateGroup = (start, count) => { const temp = arr.slice(start, start + count); for (let i = 0; i < count; i++) { arr[start + i] = arr[(start + i + d) % n]; } for (let i = 0; i < count; i++) { arr[(start + i + d) % n] = temp[i]; } }; const numGcd = gcd(n, d); for (let i = 0; i < numGcd; i++) { rotateGroup(i, Math.floor(n / numGcd)); } return arr; }",No,No,O(n),3
"const kthLargestElement = (arr, k) => { const sorted = arr.slice().sort((a, b) => b - a); return sorted[k - 1]; }",No,No,O(n*log n),3
"const longestIncreasingSubsequence = (nums) => { const dp = Array(nums.length).fill(1); for (let i = 1; i < nums.length; i++) { for (let j = 0; j < i; j++) { if (nums[i] > nums[j]) dp[i] = Math.max(dp[i], dp[j] + 1); } } return Math.max(...dp); }",No,No,O(n^2),3
"const binaryTreePaths = (root) => { const res = []; const dfs = (node, path) => { if (!node) return; path += node.val + '->'; if (!node.left && !node.right) res.push(path.slice(0, -2)); dfs(node.left, path); dfs(node.right, path); }; dfs(root, ''); return res; }",No,No,O(n),3
"const removeElement = (nums, val) => { let count = 0; for (let i = 0; i < nums.length; i++) { if (nums[i] !== val) nums[count++] = nums[i]; } return count; }",No,No,O(n),3
"const maximumSubarray = (nums) => { let max = nums[0], currentSum = 0; for (const num of nums) { currentSum = Math.max(num, currentSum + num); max = Math.max(max, currentSum); } return max; }",No,No,O(n),3
"const isAnagram = (s, t) => { if (s.length !== t.length) return false; const count = {}; for (const char of s) count[char] = (count[char] || 0) + 1; for (const char of t) { if (!count[char]) return false; count[char]--; } return true; }",No,No,O(n),3
"const countPrimes = (n) => { const isPrime = Array(n).fill(true); isPrime[0] = isPrime[1] = false; for (let i = 2; i * i < n; i++) { if (isPrime[i]) { for (let j = i * i; j < n; j += i) isPrime[j] = false; } } return isPrime.reduce((count, prime) => count + (prime ? 1 : 0), 0); }",No,No,O(n*log(log(n))),3
"const countVowelSubstrings = (s) => { const vowels = 'aeiou'; const map = {}; let start = 0, count = 0; for (let end = 0; end < s.length; end++) { if (!vowels.includes(s[end])) { start = end + 1; continue; } map[s[end]] = (map[s[end]] || 0) + 1; while (Object.keys(map).length === 5) { count += end - start + 1; map[s[start]]--; if (map[s[start]] === 0) delete map[s[start]]; start++; } } } return count; }",No,No,O(n),3
"const permute = (nums) => { const result = []; const backtrack = (temp) => { if (temp.length === nums.length) { result.push([...temp]); return; } for (let i = 0; i < nums.length; i++) { if (temp.includes(nums[i])) continue; temp.push(nums[i]); backtrack(temp); temp.pop(); } }; backtrack([]); return result; }",No,No,O(n!),3
"const minWindow = (s, t) => { const map = {}; for (const char of t) map[char] = (map[char] || 0) + 1; let start = 0, end = 0, minLen = Infinity, minStart = 0, counter = t.length; while (end < s.length) { if (map[s[end]] > 0) counter--; map[s[end]]--; end++; while (counter === 0) { if (end - start < minLen) { minLen = end - start; minStart = start; } map[s[start]]++; if (map[s[start]] > 0) counter++; start++; } } return minLen === Infinity ? '' : s.slice(minStart, minStart + minLen); }",No,No,O(n),3
"const groupAnagrams = (strs) => { const map = {}; for (const str of strs) { const key = str.split('').sort().join(''); if (!map[key]) map[key] = []; map[key].push(str); } return Object.values(map); }",No,No,O(n*k*log k),3
"const findMedianSortedArrays = (nums1, nums2) => { const merged = [...nums1, ...nums2].sort((a, b) => a - b); const mid = merged.length / 2; return merged.length % 2 !== 0 ? merged[Math.floor(mid)] : (merged[mid - 1] + merged[mid]) / 2; }",No,No,O((m+n) * log(m+n)),3
"const threeSum = (nums) => { const res = []; nums.sort((a, b) => a - b); for (let i = 0; i < nums.length; i++) { if (i > 0 && nums[i] === nums[i - 1]) continue; let left = i + 1, right = nums.length - 1; while (left < right) { const sum = nums[i] + nums[left] + nums[right]; if (sum === 0) { res.push([nums[i], nums[left], nums[right]]); while (nums[left] === nums[left + 1]) left++; while (nums[right] === nums[right - 1]) right--; left++; right--; } else if (sum < 0) left++; else right--; } } return res; }",No,No,O(n^2),3
"const searchInsert = (nums, target) => { let left = 0, right = nums.length - 1; while (left <= right) { const mid = Math.floor((left + right) / 2); if (nums[mid] === target) return mid; else if (nums[mid] < target) left = mid + 1; else right = mid - 1; } return left; }",No,No,O(log n),3
"const validSudoku = (board) => { const rows = Array(9).fill(0).map(() => new Set()); const cols = Array(9).fill(0).map(() => new Set()); const boxes = Array(9).fill(0).map(() => new Set()); for (let i = 0; i < 9; i++) { for (let j = 0; j < 9; j++) { const num = board[i][j]; if (num !== '.') { const boxIndex = Math.floor(i / 3) * 3 + Math.floor(j / 3); if (rows[i].has(num) || cols[j].has(num) || boxes[boxIndex].has(num)) return false; rows[i].add(num); cols[j].add(num); boxes[boxIndex].add(num); } } } return true; }",No,No,O(n^2),3
"const flatten = (nestedArray) => { const result = []; const flattenHelper = (array) => { for (let item of array) { if (Array.isArray(item)) { flattenHelper(item); } else { result.push(item); } } }; flattenHelper(nestedArray); return result; }",No,No,O(n),3
"const maxProfit = (prices) => { let minPrice = Infinity; let maxProfit = 0; for (const price of prices) { minPrice = Math.min(minPrice, price); maxProfit = Math.max(maxProfit, price - minPrice); } return maxProfit; }",No,No,O(n),3
"const coinChange = (coins, amount) => { const dp = Array(amount + 1).fill(Infinity); dp[0] = 0; for (const coin of coins) { for (let i = coin; i <= amount; i++) { dp[i] = Math.min(dp[i], dp[i - coin] + 1); } } return dp[amount] === Infinity ? -1 : dp[amount]; }",No,No,O(n*amount),3
"const longestCommonPrefix = (strs) => { if (!strs.length) return ''; let prefix = strs[0]; for (let i = 1; i < strs.length; i++) { while (strs[i].indexOf(prefix) !== 0) { prefix = prefix.slice(0, -1); } } return prefix; }",No,No,O(n*m),3
"const isPalindrome = (s) => { s = s.replace(/[^a-zA-Z0-9]/g, '').toLowerCase(); let left = 0, right = s.length - 1; while (left < right) { if (s[left] !== s[right]) return false; left++; right--; } return true; }",No,No,O(n),3
"const bitCount = (n) => { let count = 0; while (n) { count += n & 1; n >>= 1; } return count; }",No,No,O(log n),3
"const longestValidParentheses = (s) => { const stack = [-1]; let maxLen = 0; for (let i = 0; i < s.length; i++) { if (s[i] === '(') stack.push(i); else { stack.pop(); if (stack.length === 0) { stack.push(i); } else { maxLen = Math.max(maxLen, i - stack[stack.length - 1]); } } } return maxLen; }",No,No,O(n),3
"const trap = (height) => { const n = height.length; if (n === 0) return 0; let leftMax = Array(n).fill(0); let rightMax = Array(n).fill(0); leftMax[0] = height[0]; rightMax[n - 1] = height[n - 1]; for (let i = 1; i < n; i++) { leftMax[i] = Math.max(leftMax[i - 1], height[i]); } for (let i = n - 2; i >= 0; i--) { rightMax[i] = Math.max(rightMax[i + 1], height[i]); } let waterTrapped = 0; for (let i = 0; i < n; i++) { waterTrapped += Math.min(leftMax[i], rightMax[i]) - height[i]; } return waterTrapped; }",No,No,O(n),3
"const findDuplicates = (nums) => { const duplicates = []; const seen = new Set(); for (const num of nums) { if (seen.has(num)) duplicates.push(num); else seen.add(num); } return duplicates; }",No,No,O(n),3
"const simplifyPath = (path) => { const stack = []; const parts = path.split('/'); for (const part of parts) { if (part === '' || part === '.') continue; if (part === '..') { if (stack.length) stack.pop(); } else stack.push(part); } return '/' + stack.join('/'); }",No,No,O(n),3
"const uniquePaths = (m, n) => { const dp = Array(m).fill(0).map(() => Array(n).fill(0)); for (let i = 0; i < m; i++) dp[i][0] = 1; for (let j = 0; j < n; j++) dp[0][j] = 1; for (let i = 1; i < m; i++) { for (let j = 1; j < n; j++) { dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } return dp[m - 1][n - 1]; }",No,No,O(m*n),3
"const longestSubstrWithoutRepeating = (s) => { const charIndexMap = {}; let maxLength = 0, start = 0; for (let end = 0; end < s.length; end++) { if (charIndexMap[s[end]] !== undefined) start = Math.max(start, charIndexMap[s[end]] + 1); charIndexMap[s[end]] = end; maxLength = Math.max(maxLength, end - start + 1); } return maxLength; }",No,No,O(n),3
"const validAnagram = (s, t) => { const count = {}; for (const char of s) count[char] = (count[char] || 0) + 1; for (const char of t) { if (!count[char]) return false; count[char]--; } return true; }",No,No,O(n),3
"const countPrimes = (n) => { const isPrime = Array(n).fill(true); isPrime[0] = isPrime[1] = false; for (let i = 2; i * i < n; i++) { if (isPrime[i]) { for (let j = i * i; j < n; j += i) isPrime[j] = false; } } return isPrime.reduce((count, prime) => count + (prime ? 1 : 0), 0); }",No,No,O(n*log(log(n))),3
"const countVowelSubstrings = (s) => { const vowels = 'aeiou'; const map = {}; let start = 0, count = 0; for (let end = 0; end < s.length; end++) { if (!vowels.includes(s[end])) { start = end + 1; continue; } map[s[end]] = (map[s[end]] || 0) + 1; while (Object.keys(map).length === 5) { count += end - start + 1; map[s[start]]--; if (map[s[start]] === 0) delete map[s[start]]; start++; } } } return count; }",No,No,O(n),3
"const permute = (nums) => { const result = []; const backtrack = (temp) => { if (temp.length === nums.length) { result.push([...temp]); return; } for (let i = 0; i < nums.length; i++) { if (temp.includes(nums[i])) continue; temp.push(nums[i]); backtrack(temp); temp.pop(); } }; backtrack([]); return result; }",No,No,O(n!),3
"const minWindow = (s, t) => { const map = {}; for (const char of t) map[char] = (map[char] || 0) + 1; let start = 0, end = 0, minLen = Infinity, minStart = 0, counter = t.length; while (end < s.length) { if (map[s[end]] > 0) counter--; map[s[end]]--; end++; while (counter === 0) { if (end - start < minLen) { minLen = end - start; minStart = start; } map[s[start]]++; if (map[s[start]] > 0) counter++; start++; } } return minLen === Infinity ? '' : s.slice(minStart, minStart + minLen); }",No,No,O(n),3
"const groupAnagrams = (strs) => { const map = {}; for (const str of strs) { const key = str.split('').sort().join(''); if (!map[key]) map[key] = []; map[key].push(str); } return Object.values(map); }",No,No,O(n*k*log k),3
"const findMedianSortedArrays = (nums1, nums2) => { const merged = [...nums1, ...nums2].sort((a, b) => a - b); const mid = merged.length / 2; return merged.length % 2 !== 0 ? merged[Math.floor(mid)] : (merged[mid - 1] + merged[mid]) / 2; }",No,No,O((m+n) * log(m+n)),3
"const threeSum = (nums) => { const res = []; nums.sort((a, b) => a - b); for (let i = 0; i < nums.length; i++) { if (i > 0 && nums[i] === nums[i - 1]) continue; let left = i + 1, right = nums.length - 1; while (left < right) { const sum = nums[i] + nums[left] + nums[right]; if (sum === 0) { res.push([nums[i], nums[left], nums[right]]); while (nums[left] === nums[left + 1]) left++; while (nums[right] === nums[right - 1]) right--; left++; right--; } else if (sum < 0) left++; else right--; } } return res; }",No,No,O(n^2),3
"const searchInsert = (nums, target) => { let left = 0, right = nums.length - 1; while (left <= right) { const mid = Math.floor((left + right) / 2); if (nums[mid] === target) return mid; else if (nums[mid] < target) left = mid + 1; else right = mid - 1; } return left; }",No,No,O(log n),3
"const validSudoku = (board) => { const rows = Array(9).fill(0).map(() => new Set()); const cols = Array(9).fill(0).map(() => new Set()); const boxes = Array(9).fill(0).map(() => new Set()); for (let i = 0; i < 9; i++) { for (let j = 0; j < 9; j++) { const num = board[i][j]; if (num !== '.') { const boxIndex = Math.floor(i / 3) * 3 + Math.floor(j / 3); if (rows[i].has(num) || cols[j].has(num) || boxes[boxIndex].has(num)) return false; rows[i].add(num); cols[j].add(num); boxes[boxIndex].add(num); } } } return true; }",No,No,O(n^2),3
"const flatten = (nestedArray) => { const result = []; const flattenHelper = (array) => { for (let item of array) { if (Array.isArray(item)) { flattenHelper(item); } else { result.push(item); } } }; flattenHelper(nestedArray); return result; }",No,No,O(n),3
"const maxProfit = (prices) => { let minPrice = Infinity; let maxProfit = 0; for (const price of prices) { minPrice = Math.min(minPrice, price); maxProfit = Math.max(maxProfit, price - minPrice); } return maxProfit; }",No,No,O(n),3
"const coinChange = (coins, amount) => { const dp = Array(amount + 1).fill(Infinity); dp[0] = 0; for (const coin of coins) { for (let i = coin; i <= amount; i++) { dp[i] = Math.min(dp[i], dp[i - coin] + 1); } } return dp[amount] === Infinity ? -1 : dp[amount]; }",No,No,O(n*amount),3
"const longestCommonPrefix = (strs) => { if (!strs.length) return ''; let prefix = strs[0]; for (let i = 1; i < strs.length; i++) { while (strs[i].indexOf(prefix) !== 0) { prefix = prefix.slice(0, -1); } } return prefix; }",No,No,O(n*m),3
"const isPalindrome = (s) => { s = s.replace(/[^a-zA-Z0-9]/g, '').toLowerCase(); let left = 0, right = s.length - 1; while (left < right) { if (s[left] !== s[right]) return false; left++; right--; } return true; }",No,No,O(n),3
"const bitCount = (n) => { let count = 0; while (n) { count += n & 1; n >>= 1; } return count; }",No,No,O(log n),3
"const combinationSum = (candidates, target) => { const result = []; const backtrack = (temp, sum, start) => { if (sum === target) { result.push([...temp]); return; } if (sum > target) return; for (let i = start; i < candidates.length; i++) { temp.push(candidates[i]); backtrack(temp, sum + candidates[i], i); temp.pop(); } }; backtrack([], 0, 0); return result; }",No,No,O(2^n),3
"const maxSubArray = (nums) => { let maxSum = nums[0], currentSum = 0; for (const num of nums) { currentSum = Math.max(num, currentSum + num); maxSum = Math.max(maxSum, currentSum); } return maxSum; }",No,No,O(n),3
"const nthFibonacci = (n) => { if (n <= 1) return n; return nthFibonacci(n - 1) + nthFibonacci(n - 2); }",No,No,O(2^n),3
"const jump = (nums) => { let jumps = 0, currentEnd = 0, farthest = 0; for (let i = 0; i < nums.length - 1; i++) { farthest = Math.max(farthest, i + nums[i]); if (i === currentEnd) { jumps++; currentEnd = farthest; } } return jumps; }",No,No,O(n),3
"const findLongestSubstring = (s) => { const charIndexMap = {}; let longest = 0, start = 0; for (let end = 0; end < s.length; end++) { if (charIndexMap[s[end]] !== undefined) start = Math.max(start, charIndexMap[s[end]] + 1); charIndexMap[s[end]] = end; longest = Math.max(longest, end - start + 1); } return longest; }",No,No,O(n),3
"const subsets = (nums) => { const result = []; const backtrack = (temp, start) => { result.push([...temp]); for (let i = start; i < nums.length; i++) { temp.push(nums[i]); backtrack(temp, i + 1); temp.pop(); } }; backtrack([], 0); return result; }",No,No,O(2^n),3
"const rotate = (nums, k) => { k %= nums.length; reverse(nums, 0, nums.length - 1); reverse(nums, 0, k - 1); reverse(nums, k, nums.length - 1); }; const reverse = (arr, start, end) => { while (start < end) { [arr[start], arr[end]] = [arr[end], arr[start]]; start++; end--; } }",No,No,O(n),3
"const findDuplicate = (nums) => { const seen = new Set(); for (const num of nums) { if (seen.has(num)) return num; seen.add(num); } return -1; }",No,No,O(n),3
"const reverseString = (s) => { let reversed = ''; for (let i = s.length - 1; i >= 0; i--) { reversed += s[i]; } return reversed; }",No,No,O(n),3
"const sumZero = (nums) => { const res = []; const seen = new Set(); for (let num of nums) { if (seen.has(-num)) res.push([-num, num]); seen.add(num); } return res; }",No,No,O(n),3
"const climbStairs = (n) => { const dp = Array(n + 1).fill(0); dp[0] = 1; dp[1] = 1; for (let i = 2; i <= n; i++) { dp[i] = dp[i - 1] + dp[i - 2]; } return dp[n]; }",No,No,O(n),3
"const checkPalindrome = (s) => { const normalized = s.toLowerCase().replace(/[^a-z0-9]/g, ''); return normalized === normalized.split('').reverse().join(''); }",No,No,O(n),3
"const minAddToMakeValid = (s) => { let balance = 0, count = 0; for (const char of s) { if (char === '(') balance++; else if (char === ')') { if (balance === 0) count++; else balance--; } } return count + balance; }",No,No,O(n),3
"const longestPalindrome = (s) => { const expandAroundCenter = (left, right) => { while (left >= 0 && right < s.length && s[left] === s[right]) { left--; right++; } return right - left - 1; }; let maxLen = 0; for (let i = 0; i < s.length; i++) { maxLen = Math.max(maxLen, expandAroundCenter(i, i), expandAroundCenter(i, i + 1)); } return maxLen; }",No,No,O(n^2),3
"const isValidBST = (root) => { const validate = (node, lower, upper) => { if (!node) return true; if (node.val <= lower || node.val >= upper) return false; return validate(node.left, lower, node.val) && validate(node.right, node.val, upper); }; return validate(root, -Infinity, Infinity); }",No,No,O(n),3
"const maxDepth = (root) => { if (!root) return 0; return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1; }",No,No,O(n),3
"const levelOrder = (root) => { if (!root) return []; const result = []; const queue = [root]; while (queue.length) { const level = []; const size = queue.length; for (let i = 0; i < size; i++) { const node = queue.shift(); level.push(node.val); if (node.left) queue.push(node.left); if (node.right) queue.push(node.right); } result.push(level); } return result; }",No,No,O(n),3
"const invertTree = (root) => { if (!root) return null; const left = invertTree(root.left); const right = invertTree(root.right); root.left = right; root.right = left; return root; }",No,No,O(n),3
"const kthLargest = (root, k) => { const inorder = (node) => { if (!node) return []; return [...inorder(node.left), node.val, ...inorder(node.right)]; }; const sorted = inorder(root); return sorted[sorted.length - k]; }",No,No,O(n),3
"const isSymmetric = (root) => { const isMirror = (left, right) => { if (!left && !right) return true; if (!left || !right) return false; return left.val === right.val && isMirror(left.left, right.right) && isMirror(left.right, right.left); }; return isMirror(root, root); }",No,No,O(n),3
"const searchBST = (root, val) => { if (!root || root.val === val) return root; return val < root.val ? searchBST(root.left, val) : searchBST(root.right, val); }",No,No,O(n),3
"const sortedArrayToBST = (nums) => { if (!nums.length) return null; const mid = Math.floor(nums.length / 2); const root = new TreeNode(nums[mid]); root.left = sortedArrayToBST(nums.slice(0, mid)); root.right = sortedArrayToBST(nums.slice(mid + 1)); return root; }",No,No,O(n),3
"const mergeTwoLists = (l1, l2) => { const dummy = new ListNode(0); let current = dummy; while (l1 && l2) { if (l1.val < l2.val) { current.next = l1; l1 = l1.next; } else { current.next = l2; l2 = l2.next; } current = current.next; } current.next = l1 || l2; return dummy.next; }",No,No,O(n),3
"const removeNthFromEnd = (head, n) => { const dummy = new ListNode(0, head); let fast = dummy, slow = dummy; for (let i = 0; i <= n; i++) fast = fast.next; while (fast) { slow = slow.next; fast = fast.next; } slow.next = slow.next.next; return dummy.next; }",No,No,O(n),3
"const hasCycle = (head) => { let slow = head, fast = head; while (fast && fast.next) { if (slow === fast) return true; slow = slow.next; fast = fast.next.next; } return false; }",No,No,O(n),3
"const flattenList = (head) => { const flatten = (node) => { if (!node) return null; const temp = node.next; node.next = flatten(node.child); let tail = node; while (tail.next) tail = tail.next; tail.next = flatten(temp); node.child = null; return node; }; return flatten(head); }",No,No,O(n),3
"const groupAnagrams = (strs) => { const map = new Map(); for (const str of strs) { const key = [...str].sort().join(''); if (!map.has(key)) map.set(key, []); map.get(key).push(str); } return [...map.values()]; }",No,No,O(n * k log k),3
"const longestCommonPrefix = (strs) => { if (!strs.length) return ''; let prefix = strs[0]; for (let i = 1; i < strs.length; i++) { while (strs[i].indexOf(prefix) !== 0) { prefix = prefix.substring(0, prefix.length - 1); if (!prefix) return ''; } } return prefix; }",No,No,O(n * m),3
"const letterCombinations = (digits) => { if (!digits.length) return []; const phoneMap = { 2: 'abc', 3: 'def', 4: 'ghi', 5: 'jkl', 6: 'mno', 7: 'pqrs', 8: 'tuv', 9: 'wxyz' }; const result = []; const backtrack = (combination, nextDigits) => { if (nextDigits.length === 0) result.push(combination); else { const digit = nextDigits[0]; for (const letter of phoneMap[digit]) backtrack(combination + letter, nextDigits.slice(1)); } }; backtrack('', digits); return result; }",No,No,O(3^n),3
"const uniquePaths = (m, n) => { const dp = Array(m).fill().map(() => Array(n).fill(0)); for (let i = 0; i < m; i++) dp[i][0] = 1; for (let j = 0; j < n; j++) dp[0][j] = 1; for (let i = 1; i < m; i++) { for (let j = 1; j < n; j++) { dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } return dp[m - 1][n - 1]; }",No,No,O(m * n),3
"const minimumPathSum = (grid) => { const dp = Array.from({ length: grid.length }, () => Array(grid[0].length).fill(0)); dp[0][0] = grid[0][0]; for (let i = 1; i < grid.length; i++) dp[i][0] = dp[i - 1][0] + grid[i][0]; for (let j = 1; j < grid[0].length; j++) dp[0][j] = dp[0][j - 1] + grid[0][j]; for (let i = 1; i < grid.length; i++) { for (let j = 1; j < grid[0].length; j++) { dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]; } } return dp[grid.length - 1][grid[0].length - 1]; }",No,No,O(m * n),3
"const uniquePathsWithObstacles = (obstacleGrid) => { const m = obstacleGrid.length, n = obstacleGrid[0].length; if (obstacleGrid[0][0] === 1 || obstacleGrid[m - 1][n - 1] === 1) return 0; const dp = Array(m).fill().map(() => Array(n).fill(0)); dp[0][0] = 1; for (let i = 0; i < m; i++) { for (let j = 0; j < n; j++) { if (obstacleGrid[i][j] === 1) continue; if (i > 0) dp[i][j] += dp[i - 1][j]; if (j > 0) dp[i][j] += dp[i][j - 1]; } } return dp[m - 1][n - 1]; }",No,No,O(m * n),3
"const canJump = (nums) => { let reach = 0; for (let i = 0; i < nums.length; i++) { if (i > reach) return false; reach = Math.max(reach, i + nums[i]); } return true; }",No,No,O(n),3
"const jumpGameII = (nums) => { let jumps = 0, currentEnd = 0, farthest = 0; for (let i = 0; i < nums.length - 1; i++) { farthest = Math.max(farthest, i + nums[i]); if (i === currentEnd) { jumps++; currentEnd = farthest; } } return jumps; }",No,No,O(n),3
"const longestIncreasingSubsequence = (nums) => { const dp = []; for (const num of nums) { const index = dp.findIndex((x) => x >= num); if (index === -1) dp.push(num); else dp[index] = num; } return dp.length; }",No,No,O(n log n),3
"const canConstruct = (ransomNote, magazine) => { const count = {}; for (const letter of magazine) count[letter] = (count[letter] || 0) + 1; for (const letter of ransomNote) { if (!count[letter]) return false; count[letter]--; } return true; }",No,No,O(m + n),3
"const findKthLargest = (nums, k) => { const quickSelect = (left, right) => { if (left === right) return nums[left]; const pivotIndex = Math.floor(Math.random() * (right - left + 1)) + left; const pivot = nums[pivotIndex]; [nums[pivotIndex], nums[right]] = [nums[right], nums[pivotIndex]]; let currentIndex = left; for (let i = left; i < right; i++) { if (nums[i] > pivot) { [nums[currentIndex], nums[i]] = [nums[i], nums[currentIndex]]; currentIndex++; } } [nums[currentIndex], nums[right]] = [nums[right], nums[currentIndex]]; if (currentIndex === k - 1) return nums[currentIndex]; return currentIndex < k - 1 ? quickSelect(currentIndex + 1, right) : quickSelect(left, currentIndex - 1); }; return quickSelect(0, nums.length - 1); }",No,No,O(n),3
"const topKFrequent = (nums, k) => { const freqMap = {}; nums.forEach(num => freqMap[num] = (freqMap[num] || 0) + 1); return Object.entries(freqMap).sort((a, b) => b[1] - a[1]).slice(0, k).map(([num]) => num); }",No,No,O(n log n),3
"const findPeakElement = (nums) => { const binarySearch = (left, right) => { const mid = Math.floor((left + right) / 2); if (mid > 0 && nums[mid - 1] > nums[mid]) return binarySearch(left, mid - 1); if (mid < nums.length - 1 && nums[mid + 1] > nums[mid]) return binarySearch(mid + 1, right); return mid; }; return binarySearch(0, nums.length - 1); }",No,No,O(log n),3
"const missingNumber = (nums) => { const n = nums.length; const expectedSum = (n * (n + 1)) / 2; const actualSum = nums.reduce((sum, num) => sum + num, 0); return expectedSum - actualSum; }",No,No,O(n),3
"const longestSubstring = (s, k) => { const charCount = {}; for (const char of s) { charCount[char] = (charCount[char] || 0) + 1; } let left = 0; for (let right = 0; right < s.length; right++) { while (Object.keys(charCount).filter(char => charCount[char] < k).length) { charCount[s[left]]--; if (charCount[s[left]] === 0) delete charCount[s[left]]; left++; } } return right - left + 1; }",No,No,O(n),3
"const arrayPairSum = (nums) => { nums.sort((a, b) => a - b); let sum = 0; for (let i = 0; i < nums.length; i += 2) { sum += nums[i]; } return sum; }",No,No,O(n log n),3
"const numberOfArithmeticSlices = (nums) => { let count = 0; let total = 0; for (let i = 2; i < nums.length; i++) { if (nums[i] - nums[i - 1] === nums[i - 1] - nums[i - 2]) { count++; total += count; } else { count = 0; } } return total; }",No,No,O(n),3
"const maxProfit = (prices) => { let minPrice = Infinity; let maxProfit = 0; for (const price of prices) { if (price < minPrice) minPrice = price; else if (price - minPrice > maxProfit) maxProfit = price - minPrice; } return maxProfit; }",No,No,O(n),3
"const coinChange = (coins, amount) => { const dp = Array(amount + 1).fill(Infinity); dp[0] = 0; for (const coin of coins) { for (let i = coin; i <= amount; i++) { dp[i] = Math.min(dp[i], dp[i - coin] + 1); } } return dp[amount] === Infinity ? -1 : dp[amount]; }",No,No,O(n * amount),3
"const reverseWords = (s) => { return s.split(' ').reverse().join(' '); }",No,No,O(n),3
"const removeNthFromEnd = (head, n) => { let dummy = new ListNode(0, head); let fast = dummy, slow = dummy; for (let i = 0; i < n + 1; i++) fast = fast.next; while (fast) { fast = fast.next; slow = slow.next; } slow.next = slow.next.next; return dummy.next; }",No,No,O(n),3
"const validParentheses = (s) => { const stack = []; for (const char of s) { if (char === '(') stack.push(')'); else if (char === '{') stack.push('}'); else if (char === '[') stack.push(']'); else if (stack.pop() !== char) return false; } return stack.length === 0; }",No,No,O(n),3
"const isValidBST = (root) => { const helper = (node, low, high) => { if (!node) return true; if (node.val <= low || node.val >= high) return false; return helper(node.left, low, node.val) && helper(node.right, node.val, high); }; return helper(root, -Infinity, Infinity); }",No,No,O(n),3
"const serialize = (root) => { const result = []; const helper = (node) => { if (!node) { result.push(null); return; } result.push(node.val); helper(node.left); helper(node.right); }; helper(root); return result; }; const deserialize = (data) => { const helper = () => { if (data[index] === null) { index++; return null; } const node = new TreeNode(data[index++]); node.left = helper(); node.right = helper(); return node; }; let index = 0; return helper(); };",No,No,O(n),3
"const inorderTraversal = (root) => { const result = []; const helper = (node) => { if (!node) return; helper(node.left); result.push(node.val); helper(node.right); }; helper(root); return result; }",No,No,O(n),3
"const maxDepth = (root) => { if (!root) return 0; return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1; }",No,No,O(n),3
"const mergeTwoLists = (l1, l2) => { const dummy = new ListNode(0); let tail = dummy; while (l1 && l2) { if (l1.val < l2.val) { tail.next = l1; l1 = l1.next; } else { tail.next = l2; l2 = l2.next; } tail = tail.next; } tail.next = l1 || l2; return dummy.next; }",No,No,O(n),3
"const rotateRight = (head, k) => { if (!head || !head.next || k === 0) return head; let length = 1, tail = head; while (tail.next) { length++; tail = tail.next; } k %= length; if (k === 0) return head; let current = head; for (let i = 0; i < length - k - 1; i++) current = current.next; tail.next = head; const newHead = current.next; current.next = null; return newHead; }",No,No,O(n),3
"const isPalindrome = (head) => { let slow = head, fast = head, prev = null; while (fast && fast.next) { const next = slow.next; slow.next = prev; prev = slow; slow = next; fast = fast.next.next; } if (fast) slow = slow.next; while (slow) { if (slow.val !== prev.val) return false; slow = slow.next; prev = prev.next; } return true; }",No,No,O(n),3
"const copyRandomList = (head) => { if (!head) return null; const map = new Map(); let curr = head; while (curr) { map.set(curr, new Node(curr.val)); curr = curr.next; } curr = head; while (curr) { map.get(curr).next = map.get(curr.next) || null; map.get(curr).random = map.get(curr.random) || null; curr = curr.next; } return map.get(head); }",No,No,O(n),3
"const mergeKLists = (lists) => { const mergeTwoLists = (l1, l2) => { const dummy = new ListNode(0); let tail = dummy; while (l1 && l2) { if (l1.val < l2.val) { tail.next = l1; l1 = l1.next; } else { tail.next = l2; l2 = l2.next; } tail = tail.next; } tail.next = l1 || l2; return dummy.next; }; return lists.reduce((acc, list) => mergeTwoLists(acc, list), null); }",No,No,O(n log k),3
"const combinationSum = (candidates, target) => { const result = []; const backtrack = (combination, sum, start) => { if (sum === target) result.push([...combination]); if (sum > target) return; for (let i = start; i < candidates.length; i++) { combination.push(candidates[i]); backtrack(combination, sum + candidates[i], i); combination.pop(); } }; backtrack([], 0, 0); return result; }",No,No,O(2^n),3
"const permutations = (nums) => { const result = []; const backtrack = (path) => { if (path.length === nums.length) result.push([...path]); for (let num of nums) { if (!path.includes(num)) { path.push(num); backtrack(path); path.pop(); } } }; backtrack([]); return result; }",No,No,O(n!),3
"const subsets = (nums) => { const result = []; const backtrack = (path, start) => { result.push([...path]); for (let i = start; i < nums.length; i++) { path.push(nums[i]); backtrack(path, i + 1); path.pop(); } }; backtrack([], 0); return result; }",No,No,O(2^n),3
"const nthUglyNumber = (n) => { const dp = [1]; let i2 = 0, i3 = 0, i5 = 0; while (dp.length < n) { const next2 = dp[i2] * 2, next3 = dp[i3] * 3, next5 = dp[i5] * 5; const next = Math.min(next2, next3, next5); dp.push(next); if (next === next2) i2++; if (next === next3) i3++; if (next === next5) i5++; } return dp[n - 1]; }",No,No,O(n),3
"const wordBreak = (s, wordDict) => { const dp = Array(s.length + 1).fill(false); dp[0] = true; for (let i = 1; i <= s.length; i++) { for (const word of wordDict) { if (i >= word.length && dp[i - word.length] && s.slice(i - word.length, i) === word) { dp[i] = true; break; } } } return dp[s.length]; }",No,No,O(n * m),3
"const numDecodings = (s) => { const dp = Array(s.length + 1).fill(0); dp[0] = 1; if (s[0] !== '0') dp[1] = 1; for (let i = 2; i <= s.length; i++) { if (s[i - 1] !== '0') dp[i] += dp[i - 1]; if (s[i - 2] === '1' || (s[i - 2] === '2' && s[i - 1] <= '6')) dp[i] += dp[i - 2]; } return dp[s.length]; }",No,No,O(n),3
"const canIWin = (maxChoosableInteger, desiredTotal) => { const memo = {}; const canWin = (total, used) => { if (total >= desiredTotal) return false; if (memo[used] !== undefined) return memo[used]; for (let i = 1; i <= maxChoosableInteger; i++) { if ((used & (1 << i)) === 0 && !canWin(total + i, used | (1 << i))) { return memo[used] = true; } } return memo[used] = false; }; return canWin(0, 0); }",No,No,O(2^n),3
"const uniquePaths = (m, n) => { const dp = Array(m).fill().map(() => Array(n).fill(1)); for (let i = 1; i < m; i++) { for (let j = 1; j < n; j++) { dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } return dp[m - 1][n - 1]; }",No,No,O(m * n),3
"const countBits = (n) => { const res = []; for (let i = 0; i <= n; i++) { res[i] = res[i >> 1] + (i & 1); } return res; }",No,No,O(n),3
"const minPathSum = (grid) => { const m = grid.length, n = grid[0].length; const dp = Array(m).fill().map(() => Array(n).fill(0)); dp[0][0] = grid[0][0]; for (let i = 1; i < m; i++) dp[i][0] = dp[i - 1][0] + grid[i][0]; for (let j = 1; j < n; j++) dp[0][j] = dp[0][j - 1] + grid[0][j]; for (let i = 1; i < m; i++) { for (let j = 1; j < n; j++) { dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]; } } return dp[m - 1][n - 1]; }",No,No,O(m * n),3
"const largestRectangleArea = (heights) => { const stack = []; let maxArea = 0; heights.push(0); for (let i = 0; i < heights.length; i++) { while (stack.length && heights[i] < heights[stack[stack.length - 1]]) { const height = heights[stack.pop()]; const width = stack.length ? i - stack[stack.length - 1] - 1 : i; maxArea = Math.max(maxArea, height * width); } stack.push(i); } return maxArea; }",No,No,O(n),3
"const searchRange = (nums, target) => { const binarySearch = (left) => { let lo = 0, hi = nums.length; while (lo < hi) { const mid = Math.floor((lo + hi) / 2); if (nums[mid] < target || (left && target === nums[mid])) lo = mid + 1; else hi = mid; } return lo; }; return [binarySearch(true), binarySearch(false) - 1]; }",No,No,O(log n),3
"const longestValidParentheses = (s) => { const stack = [-1]; let maxLen = 0; for (let i = 0; i < s.length; i++) { if (s[i] === '(') stack.push(i); else { stack.pop(); if (stack.length === 0) stack.push(i); else maxLen = Math.max(maxLen, i - stack[stack.length - 1]); } } return maxLen; }",No,No,O(n),3
"const topKFrequent = (nums, k) => { const freqMap = new Map(); for (const num of nums) { freqMap.set(num, (freqMap.get(num) || 0) + 1); } return [...freqMap.entries()].sort((a, b) => b[1] - a[1]).slice(0, k).map(([num]) => num); }",No,No,O(n log n),3
"const lengthOfLIS = (nums) => { const dp = []; for (const num of nums) { let left = 0, right = dp.length; while (left < right) { const mid = Math.floor((left + right) / 2); if (dp[mid] < num) left = mid + 1; else right = mid; } dp[left] = num; } return dp.length; }",No,No,O(n log n),3
"const canJump = (nums) => { let maxReach = 0; for (let i = 0; i < nums.length; i++) { if (i > maxReach) return false; maxReach = Math.max(maxReach, i + nums[i]); } return true; }",No,No,O(n),3
"const generateMatrix = (n) => { const matrix = Array.from({ length: n }, () => Array(n).fill(0)); let left = 0, right = n - 1, top = 0, bottom = n - 1, num = 1; while (left <= right && top <= bottom) { for (let i = left; i <= right; i++) matrix[top][i] = num++; top++; for (let i = top; i <= bottom; i++) matrix[i][right] = num++; right--; for (let i = right; i >= left; i--) matrix[bottom][i] = num++; bottom--; for (let i = bottom; i >= top; i--) matrix[i][left] = num++; left++; } return matrix; }",No,No,O(n^2),3
"const findDuplicate = (nums) => { let slow = nums[0], fast = nums[0]; do { slow = nums[slow]; fast = nums[nums[fast]]; } while (slow !== fast); let ptr1 = nums[0], ptr2 = slow; while (ptr1 !== ptr2) { ptr1 = nums[ptr1]; ptr2 = nums[ptr2]; } return ptr1; }",No,No,O(n),3
"const longestSubstring = (s, k) => { const charCount = {}; for (const char of s) charCount[char] = (charCount[char] || 0) + 1; let maxLen = 0; for (let i = 1; i <= 26; i++) { let left = 0, right = 0, uniqueCount = 0; const count = {}; while (right < s.length) { if (uniqueCount <= i) { if (count[s[right]] === undefined) uniqueCount++; count[s[right]] = (count[s[right]] || 0) + 1; right++; } else { if (count[s[left]] === 1) uniqueCount--; count[s[left]]--; left++; } } if (uniqueCount <= i) maxLen = Math.max(maxLen, right - left); } } return maxLen; }",No,No,O(n^2),3
"const combinationSum4 = (nums, target) => { const dp = Array(target + 1).fill(0); dp[0] = 1; for (let i = 1; i <= target; i++) { for (const num of nums) { if (i - num >= 0) dp[i] += dp[i - num]; } } return dp[target]; }",No,No,O(n * target),3
"const trap = (height) => { const n = height.length; const leftMax = Array(n).fill(0); const rightMax = Array(n).fill(0); leftMax[0] = height[0]; rightMax[n - 1] = height[n - 1]; for (let i = 1; i < n; i++) leftMax[i] = Math.max(leftMax[i - 1], height[i]); for (let i = n - 2; i >= 0; i--) rightMax[i] = Math.max(rightMax[i + 1], height[i]); let waterTrapped = 0; for (let i = 0; i < n; i++) waterTrapped += Math.min(leftMax[i], rightMax[i]) - height[i]; return waterTrapped; }",No,No,O(n),3
"const longestSubstringWithoutRepeatingChars = (s) => { const charSet = new Set(); let left = 0, maxLen = 0; for (let right = 0; right < s.length; right++) { while (charSet.has(s[right])) charSet.delete(s[left++]); charSet.add(s[right]); maxLen = Math.max(maxLen, right - left + 1); } return maxLen; }",No,No,O(n),3
"const minimumWindowSubstring = (s, t) => { const charCount = {}; for (const char of t) charCount[char] = (charCount[char] || 0) + 1; let left = 0, right = 0, minLen = Infinity, minWindow = ''; let required = Object.keys(charCount).length, formed = 0; const windowCount = {}; while (right < s.length) { const char = s[right]; windowCount[char] = (windowCount[char] || 0) + 1; if (charCount[char] && windowCount[char] === charCount[char]) formed++; while (left <= right && formed === required) { const charLeft = s[left]; if (right - left + 1 < minLen) { minLen = right - left + 1; minWindow = s.slice(left, right + 1); } windowCount[charLeft]--; if (charCount[charLeft] && windowCount[charLeft] < charCount[charLeft]) formed--; left++; } right++; } return minWindow; }",No,No,O(n),3
"const leastInterval = (tasks, n) => { const freqMap = Array(26).fill(0); for (const task of tasks) freqMap[task.charCodeAt(0) - 65]++; const maxFreq = Math.max(...freqMap); const maxFreqCount = freqMap.filter(freq => freq === maxFreq).length; return Math.max(tasks.length, (maxFreq - 1) * (n + 1) + maxFreqCount); }",No,No,O(n),3
"const reverseString = (s) => { return s.split('').reverse().join(''); }",No,No,O(n),3
"const isAnagram = (s, t) => { if (s.length !== t.length) return false; const count = {}; for (const char of s) { count[char] = (count[char] || 0) + 1; } for (const char of t) { if (!count[char]) return false; count[char]--; } return true; }",No,No,O(n),3
"const groupAnagrams = (strs) => { const anagrams = {}; for (const str of strs) { const sortedStr = str.split('').sort().join(''); if (!anagrams[sortedStr]) anagrams[sortedStr] = []; anagrams[sortedStr].push(str); } return Object.values(anagrams); }",No,No,O(n * k log k),3
"const merge = (intervals) => { intervals.sort((a, b) => a[0] - b[0]); const merged = []; for (const interval of intervals) { if (!merged.length || merged[merged.length - 1][1] < interval[0]) merged.push(interval); else merged[merged.length - 1][1] = Math.max(merged[merged.length - 1][1], interval[1]); } return merged; }",No,No,O(n log n),3
"const climbStairs = (n) => { if (n <= 2) return n; const dp = Array(n + 1).fill(0); dp[1] = 1; dp[2] = 2; for (let i = 3; i <= n; i++) dp[i] = dp[i - 1] + dp[i - 2]; return dp[n]; }",No,No,O(n),3
"const sumZero = (n) => { return Array.from({ length: n }, (_, i) => i - Math.floor(n / 2)); }",No,No,O(n),3
"const maximumProduct = (nums) => { nums.sort((a, b) => a - b); return Math.max(nums[0] * nums[1] * nums[nums.length - 1], nums[nums.length - 1] * nums[nums.length - 2] * nums[nums.length - 3]); }",No,No,O(n log n),3
"const largestSumAfterKNegations = (nums, k) => { nums.sort((a, b) => a - b); for (let i = 0; i < k; i++) { nums[0] = -nums[0]; nums.sort((a, b) => a - b); } return nums.reduce((a, b) => a + b, 0); }",No,No,O(n log n),3
"const maxProduct = (nums) => { let maxProduct = nums[0]; let currentMax = nums[0]; let currentMin = nums[0]; for (let i = 1; i < nums.length; i++) { if (nums[i] < 0) [currentMax, currentMin] = [currentMin, currentMax]; currentMax = Math.max(nums[i], currentMax * nums[i]); currentMin = Math.min(nums[i], currentMin * nums[i]); maxProduct = Math.max(maxProduct, currentMax); } return maxProduct; }",No,No,O(n),3
"const productExceptSelf = (nums) => { const output = Array(nums.length).fill(1); let left = 1; for (let i = 0; i < nums.length; i++) { output[i] *= left; left *= nums[i]; } let right = 1; for (let i = nums.length - 1; i >= 0; i--) { output[i] *= right; right *= nums[i]; } return output; }",No,No,O(n),3
"const canPlaceFlowers = (flowerbed, n) => { let count = 0; for (let i = 0; i < flowerbed.length; i++) { if (flowerbed[i] === 0 && (i === 0 || flowerbed[i - 1] === 0) && (i === flowerbed.length - 1 || flowerbed[i + 1] === 0)) { flowerbed[i] = 1; count++; } } return count >= n; }",No,No,O(n),3
"const maxArea = (height) => { let maxArea = 0, left = 0, right = height.length - 1; while (left < right) { maxArea = Math.max(maxArea, Math.min(height[left], height[right]) * (right - left)); height[height[left] < height[right] ? left++ : right--]; } return maxArea; }",No,No,O(n),3
"const subsetsWithDup = (nums) => { const res = []; const backtrack = (start, path) => { res.push(path); for (let i = start; i < nums.length; i++) { if (i > start && nums[i] === nums[i - 1]) continue; backtrack(i + 1, path.concat(nums[i])); } }; nums.sort((a, b) => a - b); backtrack(0, []); return res; }",No,No,O(2^n),3
"const longestCommonPrefix = (strs) => { if (!strs.length) return ''; let prefix = strs[0]; for (let i = 1; i < strs.length; i++) { while (strs[i].indexOf(prefix) !== 0) { prefix = prefix.slice(0, -1); if (!prefix) return ''; } } return prefix; }",No,No,O(n * m),3
"const permute = (nums) => { const res = []; const backtrack = (path) => { if (path.length === nums.length) res.push(path); for (const num of nums) { if (path.includes(num)) continue; backtrack([...path, num]); } }; backtrack([]); return res; }",No,No,O(n!),3
"const twoSum = (nums, target) => { const map = new Map(); for (let i = 0; i < nums.length; i++) { const complement = target - nums[i]; if (map.has(complement)) return [map.get(complement), i]; map.set(nums[i], i); } return []; }",No,No,O(n),3
"const isValid = (s) => { const stack = []; const pairs = { '(': ')', '{': '}', '[': ']' }; for (const char of s) { if (pairs[char]) stack.push(char); else if (stack.length && pairs[stack.pop()] !== char) return false; } return stack.length === 0; }",No,No,O(n),3
"const removeDuplicates = (nums) => { if (nums.length === 0) return 0; let j = 0; for (let i = 1; i < nums.length; i++) { if (nums[i] !== nums[j]) { j++; nums[j] = nums[i]; } } return j + 1; }",No,No,O(n),3
"const rotate = (nums, k) => { const n = nums.length; k %= n; const reverse = (arr, left, right) => { while (left < right) { [arr[left], arr[right]] = [arr[right], arr[left]]; left++; right--; } }; reverse(nums, 0, n - 1); reverse(nums, 0, k - 1); reverse(nums, k, n - 1); };",No,No,O(n),3
"const lengthOfLastWord = (s) => { return s.trim().split(' ').pop().length; }",No,No,O(n),3
"const validPalindrome = (s) => { const isPalindrome = (s, left, right) => { while (left < right) { if (s[left] !== s[right]) return false; left++; right--; } return true; }; for (let i = 0; i < s.length; i++) { if (isPalindrome(s, i, s.length - 1 - i)) return true; } return false; }",No,No,O(n^2),3
"const firstUniqChar = (s) => { const charCount = {}; for (const char of s) charCount[char] = (charCount[char] || 0) + 1; for (let i = 0; i < s.length; i++) { if (charCount[s[i]] === 1) return i; } return -1; }",No,No,O(n),3
"const trap = (height) => { const n = height.length; if (n === 0) return 0; let left = 0, right = n - 1, leftMax = 0, rightMax = 0, waterTrapped = 0; while (left < right) { if (height[left] < height[right]) { leftMax = Math.max(leftMax, height[left]); waterTrapped += leftMax - height[left]; left++; } else { rightMax = Math.max(rightMax, height[right]); waterTrapped += rightMax - height[right]; right--; } } return waterTrapped; }",No,No,O(n),3
"const fourSum = (nums, target) => { const res = []; nums.sort((a, b) => a - b); for (let i = 0; i < nums.length - 3; i++) { if (i > 0 && nums[i] === nums[i - 1]) continue; for (let j = i + 1; j < nums.length - 2; j++) { if (j > i + 1 && nums[j] === nums[j - 1]) continue; let left = j + 1, right = nums.length - 1; while (left < right) { const sum = nums[i] + nums[j] + nums[left] + nums[right]; if (sum === target) { res.push([nums[i], nums[j], nums[left], nums[right]]); while (left < right && nums[left] === nums[left + 1]) left++; while (left < right && nums[right] === nums[right - 1]) right--; left++; right--; } else if (sum < target) left++; else right--; } } } return res; }",No,No,O(n^3),3
"const longestSubstring = (s, k) => { const charCount = {}; for (const char of s) charCount[char] = (charCount[char] || 0) + 1; let maxLen = 0; for (let left = 0; left < s.length; left++) { let uniqueChars = 0; const countMap = {}; for (let right = left; right < s.length; right++) { countMap[s[right]] = (countMap[s[right]] || 0) + 1; if (countMap[s[right]] === 1) uniqueChars++; while (uniqueChars > k) { countMap[s[left]]--; if (countMap[s[left]] === 0) uniqueChars--; left++; } maxLen = Math.max(maxLen, right - left + 1); } } return maxLen; }",No,No,O(n^2),3
"const minimumWindowSubstring = (s, t) => { const charCount = {}; const windowCount = {}; for (const char of t) charCount[char] = (charCount[char] || 0) + 1; const required = Object.keys(charCount).length; let left = 0, right = 0, formed = 0, minLen = Infinity, minWindow = ''; while (right < s.length) { const char = s[right]; windowCount[char] = (windowCount[char] || 0) + 1; if (charCount[char] && windowCount[char] === charCount[char]) formed++; while (left <= right && formed === required) { const charLeft = s[left]; if (right - left + 1 < minLen) { minLen = right - left + 1; minWindow = s.slice(left, right + 1); } windowCount[charLeft]--; if (charCount[charLeft] && windowCount[charLeft] < charCount[charLeft]) formed--; left++; } right++; } return minWindow; }",No,No,O(n),3
"const leastInterval = (tasks, n) => { const freqMap = Array(26).fill(0); for (const task of tasks) freqMap[task.charCodeAt(0) - 65]++; const maxFreq = Math.max(...freqMap); const maxFreqCount = freqMap.filter(freq => freq === maxFreq).length; return Math.max(tasks.length, (maxFreq - 1) * (n + 1) + maxFreqCount); }",No,No,O(n),3
"const reverseString = (s) => { return s.split('').reverse().join(''); }",No,No,O(n),3
"const isAnagram = (s, t) => { if (s.length !== t.length) return false; const count = {}; for (const char of s) { count[char] = (count[char] || 0) + 1; } for (const char of t) { if (!count[char]) return false; count[char]--; } return true; }",No,No,O(n),3
"const groupAnagrams = (strs) => { const anagrams = {}; for (const str of strs) { const sortedStr = str.split('').sort().join(''); if (!anagrams[sortedStr]) anagrams[sortedStr] = []; anagrams[sortedStr].push(str); } return Object.values(anagrams); }",No,No,O(n * k log k),3
"const merge = (intervals) => { intervals.sort((a, b) => a[0] - b[0]); const merged = []; for (const interval of intervals) { if (!merged.length || merged[merged.length - 1][1] < interval[0]) merged.push(interval); else merged[merged.length - 1][1] = Math.max(merged[merged.length - 1][1], interval[1]); } return merged; }",No,No,O(n log n),3
"const climbStairs = (n) => { if (n <= 2) return n; const dp = Array(n + 1).fill(0); dp[1] = 1; dp[2] = 2; for (let i = 3; i <= n; i++) dp[i] = dp[i - 1] + dp[i - 2]; return dp[n]; }",No,No,O(n),3
"const sumZero = (n) => { return Array.from({ length: n }, (_, i) => i - Math.floor(n / 2)); }",No,No,O(n),3
"const maximumProduct = (nums) => { nums.sort((a, b) => a - b); return Math.max(nums[0] * nums[1] * nums[nums.length - 1], nums[nums.length - 1] * nums[nums.length - 2] * nums[nums.length - 3]); }",No,No,O(n log n),3
"const largestSumAfterKNegations = (nums, k) => { nums.sort((a, b) => a - b); for (let i = 0; i < k; i++) { nums[0] = -nums[0]; nums.sort((a, b) => a - b); } return nums.reduce((a, b) => a + b, 0); }",No,No,O(n log n),3
"const maxProduct = (nums) => { let maxProduct = nums[0]; let currentMax = nums[0]; let currentMin = nums[0]; for (let i = 1; i < nums.length; i++) { if (nums[i] < 0) [currentMax, currentMin] = [currentMin, currentMax]; currentMax = Math.max(nums[i], currentMax * nums[i]); currentMin = Math.min(nums[i], currentMin * nums[i]); maxProduct = Math.max(maxProduct, currentMax); } return maxProduct; }",No,No,O(n),3
"const productExceptSelf = (nums) => { const output = Array(nums.length).fill(1); let left = 1; for (let i = 0; i < nums.length; i++) { output[i] *= left; left *= nums[i]; } let right = 1; for (let i = nums.length - 1; i >= 0; i--) { output[i] *= right; right *= nums[i]; } return output; }",No,No,O(n),3
"const canPlaceFlowers = (flowerbed, n) => { let count = 0; for (let i = 0; i < flowerbed.length; i++) { if (flowerbed[i] === 0 && (i === 0 || flowerbed[i - 1] === 0) && (i === flowerbed.length - 1 || flowerbed[i + 1] === 0)) { flowerbed[i] = 1; count++; } } return count >= n; }",No,No,O(n),3
"const maxArea = (height) => { let maxArea = 0, left = 0, right = height.length - 1; while (left < right) { maxArea = Math.max(maxArea, Math.min(height[left], height[right]) * (right - left)); if (height[left] < height[right]) left++; else right--; } return maxArea; }",No,No,O(n),3
"const minSubArrayLen = (target, nums) => { let left = 0, sum = 0, minLen = Infinity; for (let right = 0; right < nums.length; right++) { sum += nums[right]; while (sum >= target) { minLen = Math.min(minLen, right - left + 1); sum -= nums[left++]; } } return minLen === Infinity ? 0 : minLen; }",No,No,O(n),3
"const findLength = (A, B) => { const dp = Array(A.length + 1).fill(0).map(() => Array(B.length + 1).fill(0)); let maxLen = 0; for (let i = 1; i <= A.length; i++) { for (let j = 1; j <= B.length; j++) { if (A[i - 1] === B[j - 1]) { dp[i][j] = dp[i - 1][j - 1] + 1; maxLen = Math.max(maxLen, dp[i][j]); } } } return maxLen; }",No,No,O(n * m),3
"const numSquares = (n) => { const dp = Array(n + 1).fill(Infinity); dp[0] = 0; for (let i = 1; i <= n; i++) { for (let j = 1; j * j <= i; j++) { dp[i] = Math.min(dp[i], dp[i - j * j] + 1); } } return dp[n]; }",No,No,O(n * sqrt(n)),3
"const canJump = (nums) => { let maxReach = 0; for (let i = 0; i < nums.length; i++) { if (i > maxReach) return false; maxReach = Math.max(maxReach, i + nums[i]); } return true; }",No,No,O(n),3
"const jump = (nums) => { let jumps = 0, currentEnd = 0, farthest = 0; for (let i = 0; i < nums.length - 1; i++) { farthest = Math.max(farthest, i + nums[i]); if (i === currentEnd) { jumps++; currentEnd = farthest; } } return jumps; }",No,No,O(n),3
"const search = (nums, target) => { let left = 0, right = nums.length - 1; while (left <= right) { const mid = Math.floor((left + right) / 2); if (nums[mid] === target) return mid; if (nums[mid] < target) left = mid + 1; else right = mid - 1; } return -1; }",No,No,O(log n),3
"const mergeSortedArray = (nums1, m, nums2, n) => { let i = m + n - 1; while (m > 0 && n > 0) { if (nums1[m - 1] > nums2[n - 1]) { nums1[i--] = nums1[--m]; } else { nums1[i--] = nums2[--n]; } } while (n > 0) { nums1[i--] = nums2[--n]; } return nums1; }",No,No,O(m + n),3
"const lengthOfLIS = (nums) => { const dp = Array(nums.length).fill(1); for (let i = 1; i < nums.length; i++) { for (let j = 0; j < i; j++) { if (nums[i] > nums[j]) { dp[i] = Math.max(dp[i], dp[j] + 1); } } } return Math.max(...dp); }",No,No,O(n^2),3
"const longestPalindrome = (s) => { if (s.length < 2) return s; let start = 0, end = 0; for (let i = 0; i < s.length; i++) { const len1 = expandAroundCenter(s, i, i); const len2 = expandAroundCenter(s, i, i + 1); const len = Math.max(len1, len2); if (len > end - start) { start = i - Math.floor((len - 1) / 2); end = i + Math.floor(len / 2); } } return s.slice(start, end + 1); } function expandAroundCenter(s, left, right) { while (left >= 0 && right < s.length && s[left] === s[right]) { left--; right++; } return right - left - 1; }",No,No,O(n^2),3
"const isValid = (s) => { const stack = []; const map = { '(': ')', '{': '}', '[': ']' }; for (const char of s) { if (char in map) stack.push(char); else { if (map[stack.pop()] !== char) return false; } } return stack.length === 0; }",No,No,O(n),3
"const generateParenthesis = (n) => { const result = []; const backtrack = (current, open, close) => { if (current.length === 2 * n) result.push(current); if (open < n) backtrack(current + '(', open + 1, close); if (close < open) backtrack(current + ')', open, close + 1); }; backtrack('', 0, 0); return result; }",No,No,O(2^n),3
"const combine = (n, k) => { const result = []; const backtrack = (start, path) => { if (path.length === k) result.push([...path]); for (let i = start; i <= n; i++) { path.push(i); backtrack(i + 1, path); path.pop(); } }; backtrack(1, []); return result; }",No,No,O(n^k),3
"const subsets = (nums) => { const result = []; const backtrack = (start, path) => { result.push([...path]); for (let i = start; i < nums.length; i++) { path.push(nums[i]); backtrack(i + 1, path); path.pop(); } }; backtrack(0, []); return result; }",No,No,O(2^n),3
"const findMedianSortedArrays = (nums1, nums2) => { const merged = [...nums1, ...nums2].sort((a, b) => a - b); const mid = Math.floor(merged.length / 2); return merged.length % 2 === 0 ? (merged[mid - 1] + merged[mid]) / 2 : merged[mid]; }",No,No,O((m + n) log(m + n)),3
"const maxProfit = (prices) => { let maxProfit = 0; let minPrice = Infinity; for (const price of prices) { minPrice = Math.min(minPrice, price); maxProfit = Math.max(maxProfit, price - minPrice); } return maxProfit; }",No,No,O(n),3
"const lemonadeChange = (bills) => { const five = 0, ten = 0; for (const bill of bills) { if (bill === 5) five++; else if (bill === 10) { if (five === 0) return false; five--; ten++; } else { if (ten > 0 && five > 0) { ten--; five--; } else if (five >= 3) five -= 3; else return false; } } return true; }",No,No,O(n),3
"const longestCommonPrefix = (strs) => { if (strs.length === 0) return ''; let prefix = strs[0]; for (let i = 1; i < strs.length; i++) { while (strs[i].indexOf(prefix) !== 0) prefix = prefix.slice(0, -1); } return prefix; }",No,No,O(n * m),3
"const longestSubstringWithoutRepeating = (s) => { const charMap = {}; let left = 0, maxLength = 0; for (let right = 0; right < s.length; right++) { if (charMap[s[right]] !== undefined) left = Math.max(charMap[s[right]] + 1, left); charMap[s[right]] = right; maxLength = Math.max(maxLength, right - left + 1); } return maxLength; }",No,No,O(n),3
"const permute = (nums) => { const result = []; const backtrack = (path) => { if (path.length === nums.length) result.push([...path]); for (let num of nums) { if (!path.includes(num)) { path.push(num); backtrack(path); path.pop(); } } }; backtrack([]); return result; }",No,No,O(n!),3
"const searchInsert = (nums, target) => { let left = 0, right = nums.length - 1; while (left <= right) { const mid = Math.floor((left + right) / 2); if (nums[mid] === target) return mid; if (nums[mid] < target) left = mid + 1; else right = mid - 1; } return left; }",No,No,O(log n),3
"const rotateArray = (nums, k) => { const n = nums.length; k = k % n; reverse(nums, 0, n - 1); reverse(nums, 0, k - 1); reverse(nums, k, n - 1); }; const reverse = (arr, start, end) => { while (start < end) { [arr[start], arr[end]] = [arr[end], arr[start]]; start++; end--; } };",No,No,O(n),3
"const twoSum = (nums, target) => { const map = {}; for (let i = 0; i < nums.length; i++) { const complement = target - nums[i]; if (map[complement] !== undefined) return [map[complement], i]; map[nums[i]] = i; } return []; }",No,No,O(n),3
"const threeSum = (nums) => { const result = []; nums.sort((a, b) => a - b); for (let i = 0; i < nums.length; i++) { if (i > 0 && nums[i] === nums[i - 1]) continue; let left = i + 1, right = nums.length - 1; while (left < right) { const sum = nums[i] + nums[left] + nums[right]; if (sum === 0) { result.push([nums[i], nums[left], nums[right]]); while (left < right && nums[left] === nums[left + 1]) left++; while (left < right && nums[right] === nums[right - 1]) right--; left++; right--; } else if (sum < 0) left++; else right--; } } return result; }",No,No,O(n^2),3
"const climbStairs = (n) => { if (n <= 2) return n; let first = 1, second = 2; for (let i = 3; i <= n; i++) { [first, second] = [second, first + second]; } return second; }",No,No,O(n),3
"const maxAreaOfIsland = (grid) => { const dfs = (i, j) => { if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] === 0) return 0; grid[i][j] = 0; return 1 + dfs(i + 1, j) + dfs(i - 1, j) + dfs(i, j + 1) + dfs(i, j - 1); }; let maxArea = 0; for (let i = 0; i < grid.length; i++) { for (let j = 0; j < grid[0].length; j++) { maxArea = Math.max(maxArea, dfs(i, j)); } } return maxArea; }",No,No,O(m * n),3
"const pacificAtlantic = (heights) => { const m = heights.length, n = heights[0].length; const pacific = Array.from({ length: m }, () => Array(n).fill(false)); const atlantic = Array.from({ length: m }, () => Array(n).fill(false)); const dfs = (i, j, visited) => { visited[i][j] = true; for (const [dx, dy] of [[0, 1], [0, -1], [1, 0], [-1, 0]]) { const x = i + dx, y = j + dy; if (x >= 0 && x < m && y >= 0 && y < n && heights[x][y] >= heights[i][j] && !visited[x][y]) dfs(x, y, visited); } }; for (let i = 0; i < m; i++) { dfs(i, 0, pacific); dfs(i, n - 1, atlantic); } for (let j = 0; j < n; j++) { dfs(0, j, pacific); dfs(m - 1, j, atlantic); } const result = []; for (let i = 0; i < m; i++) { for (let j = 0; j < n; j++) { if (pacific[i][j] && atlantic[i][j]) result.push([i, j]); } } return result; }",No,No,O(m * n),3
"const productExceptSelf = (nums) => { const result = Array(nums.length).fill(1); let prefix = 1; for (let i = 0; i < nums.length; i++) { result[i] *= prefix; prefix *= nums[i]; } let suffix = 1; for (let i = nums.length - 1; i >= 0; i--) { result[i] *= suffix; suffix *= nums[i]; } return result; }",No,No,O(n),3
"const numIslands = (grid) => { if (grid.length === 0) return 0; let count = 0; const dfs = (i, j) => { if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] === '0') return; grid[i][j] = '0'; dfs(i + 1, j); dfs(i - 1, j); dfs(i, j + 1); dfs(i, j - 1); }; for (let i = 0; i < grid.length; i++) { for (let j = 0; j < grid[0].length; j++) { if (grid[i][j] === '1') { count++; dfs(i, j); } } } return count; }",No,No,O(m * n),3
"const setZeroes = (matrix) => { const rows = new Set(), cols = new Set(); for (let i = 0; i < matrix.length; i++) { for (let j = 0; j < matrix[0].length; j++) { if (matrix[i][j] === 0) { rows.add(i); cols.add(j); } } } for (const row of rows) { for (let j = 0; j < matrix[0].length; j++) matrix[row][j] = 0; } for (const col of cols) { for (let i = 0; i < matrix.length; i++) matrix[i][col] = 0; } },No,No,O(m * n),3
"const spiralOrder = (matrix) => { const result = []; if (matrix.length === 0) return result; let left = 0, right = matrix[0].length - 1, top = 0, bottom = matrix.length - 1; while (left <= right && top <= bottom) { for (let i = left; i <= right; i++) result.push(matrix[top][i]); top++; for (let i = top; i <= bottom; i++) result.push(matrix[i][right]); right--; if (top <= bottom) { for (let i = right; i >= left; i--) result.push(matrix[bottom][i]); bottom--; } if (left <= right) { for (let i = bottom; i >= top; i--) result.push(matrix[i][left]); left++; } } return result; }",No,No,O(m * n),3
"const coinChange = (coins, amount) => { const dp = Array(amount + 1).fill(Infinity); dp[0] = 0; for (let coin of coins) { for (let x = coin; x <= amount; x++) { dp[x] = Math.min(dp[x], dp[x - coin] + 1); } } return dp[amount] === Infinity ? -1 : dp[amount]; }",No,No,O(n * amount),3
"const wordBreak = (s, wordDict) => { const dp = Array(s.length + 1).fill(false); dp[0] = true; for (let i = 1; i <= s.length; i++) { for (let j = 0; j < i; j++) { if (dp[j] && wordDict.includes(s.slice(j, i))) { dp[i] = true; break; } } } return dp[s.length]; }",No,No,O(n^2),3
"const lengthOfLongestSubstring = (s) => { let left = 0, right = 0, maxLen = 0; const charIndexMap = {}; while (right < s.length) { if (charIndexMap[s[right]] !== undefined) { left = Math.max(charIndexMap[s[right]] + 1, left); } charIndexMap[s[right]] = right; maxLen = Math.max(maxLen, right - left + 1); right++; } return maxLen; }",No,No,O(n),3
"const largestRectangleArea = (heights) => { const stack = []; let maxArea = 0; heights.push(0); for (let i = 0; i < heights.length; i++) { while (stack.length > 0 && heights[stack[stack.length - 1]] > heights[i]) { const height = heights[stack.pop()]; const width = stack.length > 0 ? i - stack[stack.length - 1] - 1 : i; maxArea = Math.max(maxArea, height * width); } stack.push(i); } return maxArea; }",No,No,O(n),3
"const findMedianSortedArrays = (nums1, nums2) => { const merged = [...nums1, ...nums2].sort((a, b) => a - b); const mid = Math.floor(merged.length / 2); return merged.length % 2 === 0 ? (merged[mid - 1] + merged[mid]) / 2 : merged[mid]; }",No,No,O(n log n),3
"const maximumSubarray = (nums) => { let maxSum = nums[0], currentSum = nums[0]; for (let i = 1; i < nums.length; i++) { currentSum = Math.max(nums[i], currentSum + nums[i]); maxSum = Math.max(maxSum, currentSum); } return maxSum; }",No,No,O(n),3
"const searchRange = (nums, target) => { const findLeft = () => { let left = 0, right = nums.length - 1; while (left <= right) { const mid = Math.floor((left + right) / 2); if (nums[mid] < target) left = mid + 1; else right = mid - 1; } return left; }; const findRight = () => { let left = 0, right = nums.length - 1; while (left <= right) { const mid = Math.floor((left + right) / 2); if (nums[mid] <= target) left = mid + 1; else right = mid - 1; } return right; }; const leftIndex = findLeft(); const rightIndex = findRight(); return leftIndex <= rightIndex ? [leftIndex, rightIndex] : [-1, -1]; };",No,No,O(log n),3
"const groupAnagrams = (strs) => { const map = new Map(); for (let str of strs) { const sorted = str.split('').sort().join(''); if (!map.has(sorted)) map.set(sorted, []); map.get(sorted).push(str); } return Array.from(map.values()); }",No,No,O(n * k log k),3
"const searchInsert = (nums, target) => { let left = 0, right = nums.length - 1; while (left <= right) { const mid = Math.floor((left + right) / 2); if (nums[mid] === target) return mid; if (nums[mid] < target) left = mid + 1; else right = mid - 1; } return left; }",No,No,O(log n),3
"const rotateArray = (nums, k) => { const n = nums.length; k = k % n; reverse(nums, 0, n - 1); reverse(nums, 0, k - 1); reverse(nums, k, n - 1); }; const reverse = (arr, start, end) => { while (start < end) { [arr[start], arr[end]] = [arr[end], arr[start]]; start++; end--; } };",No,No,O(n),3
"const twoSum = (nums, target) => { const map = {}; for (let i = 0; i < nums.length; i++) { const complement = target - nums[i]; if (map[complement] !== undefined) return [map[complement], i]; map[nums[i]] = i; } return []; }",No,No,O(n),3
"const threeSum = (nums) => { const result = []; nums.sort((a, b) => a - b); for (let i = 0; i < nums.length; i++) { if (i > 0 && nums[i] === nums[i - 1]) continue; let left = i + 1, right = nums.length - 1; while (left < right) { const sum = nums[i] + nums[left] + nums[right]; if (sum === 0) { result.push([nums[i], nums[left], nums[right]]); while (left < right && nums[left] === nums[left + 1]) left++; while (left < right && nums[right] === nums[right - 1]) right--; left++; right--; } else if (sum < 0) left++; else right--; } } return result; }",No,No,O(n^2),3
"const climbStairs = (n) => { if (n <= 2) return n; let first = 1, second = 2; for (let i = 3; i <= n; i++) { [first, second] = [second, first + second]; } return second; }",No,No,O(n),3
"const maxAreaOfIsland = (grid) => { const dfs = (i, j) => { if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] === 0) return 0; grid[i][j] = 0; return 1 + dfs(i + 1, j) + dfs(i - 1, j) + dfs(i, j + 1) + dfs(i, j - 1); }; let maxArea = 0; for (let i = 0; i < grid.length; i++) { for (let j = 0; j < grid[0].length; j++) { maxArea = Math.max(maxArea, dfs(i, j)); } } return maxArea; }",No,No,O(m * n),3
"const pacificAtlantic = (heights) => { const m = heights.length, n = heights[0].length; const pacific = Array.from({ length: m }, () => Array(n).fill(false)); const atlantic = Array.from({ length: m }, () => Array(n).fill(false)); const dfs = (i, j, visited) => { visited[i][j] = true; for (const [dx, dy] of [[0, 1], [0, -1], [1, 0], [-1, 0]]) { const x = i + dx, y = j + dy; if (x >= 0 && x < m && y >= 0 && y < n && heights[x][y] >= heights[i][j] && !visited[x][y]) dfs(x, y, visited); } }; for (let i = 0; i < m; i++) { dfs(i, 0, pacific); dfs(i, n - 1, atlantic); } for (let j = 0; j < n; j++) { dfs(0, j, pacific); dfs(m - 1, j, atlantic); } const result = []; for (let i = 0; i < m; i++) { for (let j = 0; j < n; j++) { if (pacific[i][j] && atlantic[i][j]) result.push([i, j]); } } return result; }",No,No,O(m * n),3
"const productExceptSelf = (nums) => { const result = Array(nums.length).fill(1); let prefix = 1; for (let i = 0; i < nums.length; i++) { result[i] *= prefix; prefix *= nums[i]; } let suffix = 1; for (let i = nums.length - 1; i >= 0; i--) { result[i] *= suffix; suffix *= nums[i]; } return result; }",No,No,O(n),3
"const numIslands = (grid) => { if (grid.length === 0) return 0; let count = 0; const dfs = (i, j) => { if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] === '0') return; grid[i][j] = '0'; dfs(i + 1, j); dfs(i - 1, j); dfs(i, j + 1); dfs(i, j - 1); }; for (let i = 0; i < grid.length; i++) { for (let j = 0; j < grid[0].length; j++) { if (grid[i][j] === '1') { count++; dfs(i, j); } } } return count; }",No,No,O(m * n),3
"const setZeroes = (matrix) => { const rows = new Set(), cols = new Set(); for (let i = 0; i < matrix.length; i++) { for (let j = 0; j < matrix[0].length; j++) { if (matrix[i][j] === 0) { rows.add(i); cols.add(j); } } } for (const row of rows) { for (let j = 0; j < matrix[0].length; j++) matrix[row][j] = 0; } for (const col of cols) { for (let i = 0; i < matrix.length; i++) matrix[i][col] = 0; } },No,No,O(m * n),3
"const spiralOrder = (matrix) => { const result = []; if (matrix.length === 0) return result; let left = 0, right = matrix[0].length - 1, top = 0, bottom = matrix.length - 1; while (left <= right && top <= bottom) { for (let i = left; i <= right; i++) result.push(matrix[top][i]); top++; for (let i = top; i <= bottom; i++) result.push(matrix[i][right]); right--; if (top <= bottom) { for (let i = right; i >= left; i--) result.push(matrix[bottom][i]); bottom--; } if (left <= right) { for (let i = bottom; i >= top; i--) result.push(matrix[i][left]); left++; } } return result; }",No,No,O(m * n),3
"const findDuplicate = (nums) => { let slow = nums[0], fast = nums[0]; while (true) { slow = nums[slow]; fast = nums[nums[fast]]; if (slow === fast) break; } let ptr1 = nums[0], ptr2 = slow; while (ptr1 !== ptr2) { ptr1 = nums[ptr1]; ptr2 = nums[ptr2]; } return ptr1; }",No,No,O(n),3
"const longestConsecutive = (nums) => { const numSet = new Set(nums); let longestStreak = 0; for (let num of numSet) { if (!numSet.has(num - 1)) { let currentNum = num, currentStreak = 1; while (numSet.has(currentNum + 1)) { currentNum++; currentStreak++; } longestStreak = Math.max(longestStreak, currentStreak); } } return longestStreak; }",No,No,O(n),3
"const reverseLinkedList = (head) => { let prev = null; let curr = head; while (curr) { const nextTemp = curr.next; curr.next = prev; prev = curr; curr = nextTemp; } return prev; }",No,No,O(n),3
"const minStack = () => { const stack = []; const minStack = []; return { push: (val) => { stack.push(val); if (minStack.length === 0 || val <= minStack[minStack.length - 1]) minStack.push(val); }, pop: () => { if (stack.pop() === minStack[minStack.length - 1]) minStack.pop(); }, top: () => stack[stack.length - 1], getMin: () => minStack[minStack.length - 1] }; }",No,No,O(1),3
"const longestPalindrome = (s) => { let start = 0, end = 0; const expandAroundCenter = (left, right) => { while (left >= 0 && right < s.length && s[left] === s[right]) { left--; right++; } return right - left - 1; }; for (let i = 0; i < s.length; i++) { const len1 = expandAroundCenter(i, i); const len2 = expandAroundCenter(i, i + 1); const maxLen = Math.max(len1, len2); if (maxLen > end - start) { start = i - Math.floor((maxLen - 1) / 2); end = i + Math.floor(maxLen / 2); } } return s.substring(start, end + 1); }",No,No,O(n^2),3
"const isValid = (s) => { const stack = []; const map = { '(': ')', '{': '}', '[': ']' }; for (const char of s) { if (char in map) stack.push(char); else if (stack.length === 0 || map[stack.pop()] !== char) return false; } return stack.length === 0; }",No,No,O(n),3
"const dailyTemperatures = (T) => { const result = new Array(T.length).fill(0); const stack = []; for (let i = 0; i < T.length; i++) { while (stack.length > 0 && T[i] > T[stack[stack.length - 1]]) { const j = stack.pop(); result[j] = i - j; } stack.push(i); } return result; }",No,No,O(n),3
"const binaryTreePaths = (root) => { const paths = []; const constructPaths = (node, path) => { if (node) { path += node.val + '>'; if (!node.left && !node.right) paths.push(path.slice(0, -1)); constructPaths(node.left, path); constructPaths(node.right, path); } }; constructPaths(root, ''); return paths; }",No,No,O(n),3
"const subsets = (nums) => { const result = []; const backtrack = (start, path) => { result.push([...path]); for (let i = start; i < nums.length; i++) { path.push(nums[i]); backtrack(i + 1, path); path.pop(); } }; backtrack(0, []); return result; }",No,No,O(2^n),3
"const findKthLargest = (nums, k) => { const quickSelect = (left, right) => { const pivot = nums[right]; let partitionIndex = left; for (let i = left; i < right; i++) { if (nums[i] > pivot) { [nums[i], nums[partitionIndex]] = [nums[partitionIndex], nums[i]]; partitionIndex++; } } [nums[right], nums[partitionIndex]] = [nums[partitionIndex], nums[right]]; return partitionIndex; }; let left = 0, right = nums.length - 1; while (left <= right) { const partitionIndex = quickSelect(left, right); if (partitionIndex === nums.length - k) return nums[partitionIndex]; if (partitionIndex < nums.length - k) left = partitionIndex + 1; else right = partitionIndex - 1; } return -1; }",No,No,O(n),3
"const maxSlidingWindow = (nums, k) => { const result = []; const deque = []; for (let i = 0; i < nums.length; i++) { if (deque.length && deque[0] < i - k + 1) deque.shift(); while (deque.length && nums[deque[deque.length - 1]] < nums[i]) deque.pop(); deque.push(i); if (i >= k - 1) result.push(nums[deque[0]]); } return result; }",No,No,O(n),3
"const longestSubarray = (nums, limit) => { const deque = []; let left = 0; for (let right = 0; right < nums.length; right++) { while (deque.length && nums[right] > nums[deque[deque.length - 1]]) deque.pop(); deque.push(right); while (nums[deque[0]] - nums[deque[deque.length - 1]] > limit) left++; if (right - left + 1 > maxLen) maxLen = right - left + 1; } return maxLen; }",No,No,O(n),3
"const longestValidParentheses = (s) => { const stack = [-1]; let maxLength = 0; for (let i = 0; i < s.length; i++) { if (s[i] === '(') stack.push(i); else { stack.pop(); if (stack.length === 0) stack.push(i); else maxLength = Math.max(maxLength, i - stack[stack.length - 1]); } } return maxLength; }",No,No,O(n),3
"const numSquares = (n) => { const dp = Array(n + 1).fill(Infinity); dp[0] = 0; for (let i = 1; i <= n; i++) { for (let j = 1; j * j <= i; j++) { dp[i] = Math.min(dp[i], dp[i - j * j] + 1); } } return dp[n]; }",No,No,O(n * sqrt(n)),3
"const coinChange = (coins, amount) => { const dp = Array(amount + 1).fill(Infinity); dp[0] = 0; for (const coin of coins) { for (let i = coin; i <= amount; i++) { dp[i] = Math.min(dp[i], dp[i - coin] + 1); } } return dp[amount] === Infinity ? -1 : dp[amount]; }",No,No,O(n * amount),3
"const minPathSum = (grid) => { const m = grid.length, n = grid[0].length; const dp = Array.from({ length: m }, () => Array(n).fill(0)); dp[0][0] = grid[0][0]; for (let i = 1; i < m; i++) dp[i][0] = dp[i - 1][0] + grid[i][0]; for (let j = 1; j < n; j++) dp[0][j] = dp[0][j - 1] + grid[0][j]; for (let i = 1; i < m; i++) { for (let j = 1; j < n; j++) dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]; } return dp[m - 1][n - 1]; }",No,No,O(m
"const removeDuplicates = (nums) => { let i = 0; for (let j = 1; j < nums.length; j++) { if (nums[j] !== nums[i]) { i++; nums[i] = nums[j]; } } return i + 1; };",No,No,O(n),2
"function longestPalindrome(s) { let start = 0, maxLength = 1; const expand = (l, r) => { while (l >= 0 && r < s.length && s[l] === s[r]) { l--; r++; } return r - l - 1; }; for (let i = 0; i < s.length; i++) { const len1 = expand(i, i); const len2 = expand(i, i + 1); const len = Math.max(len1, len2); if (len > maxLength) { maxLength = len; start = i - Math.floor((len - 1) / 2); } } return s.substring(start, start + maxLength); }",No,No,O(n^2),3
"function isValidBST(root, min = -Infinity, max = Infinity) { if (!root) return true; if (root.val <= min || root.val >= max) return false; return isValidBST(root.left, min, root.val) && isValidBST(root.right, root.val, max); }",No,No,O(n),3
"const getPermutation = (n, k) => { const factorial = Array(n + 1).fill(1); const nums = Array.from({ length: n }, (_, i) => i + 1); for (let i = 1; i <= n; i++) factorial[i] = factorial[i - 1] * i; k--; let res = ''; for (let i = n; i > 0; i--) { const index = Math.floor(k / factorial[i - 1]); res += nums[index]; nums.splice(index, 1); k %= factorial[i - 1]; } return res; };",No,No,O(n^2),3
"function maxProduct(nums) { let maxSoFar = nums[0], minSoFar = nums[0], result = nums[0]; for (let i = 1; i < nums.length; i++) { const curr = nums[i]; const tempMax = Math.max(curr, maxSoFar * curr, minSoFar * curr); minSoFar = Math.min(curr, maxSoFar * curr, minSoFar * curr); maxSoFar = tempMax; result = Math.max(maxSoFar, result); } return result; }",No,No,O(n),3
"const rotate = (matrix) => { const n = matrix.length; for (let i = 0; i < n; i++) { for (let j = i; j < n; j++) { [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]]; } } for (let i = 0; i < n; i++) { matrix[i].reverse(); } };",No,No,O(n^2),3
"function reverseWords(s) { return s.trim().split(/\s+/).reverse().join(' '); }",No,No,O(n),2
"const rob = (nums) => { if (nums.length === 0) return 0; let prev1 = 0, prev2 = 0; for (let num of nums) { let temp = prev1; prev1 = Math.max(prev2 + num, prev1); prev2 = temp; } return prev1; };",No,No,O(n),2
"function climbStairs(n) { const dp = [1, 1]; for (let i = 2; i <= n; i++) { dp[i] = dp[i - 1] + dp[i - 2]; } return dp[n]; }",No,No,O(n),2
"const mergeKLists = (lists) => { const mergeTwoLists = (l1, l2) => { let dummy = new ListNode(0); let current = dummy; while (l1 && l2) { if (l1.val < l2.val) { current.next = l1; l1 = l1.next; } else { current.next = l2; l2 = l2.next; } current = current.next; } current.next = l1 || l2; return dummy.next; }; if (lists.length === 0) return null; while (lists.length > 1) { lists.push(mergeTwoLists(lists.shift(), lists.shift())); } return lists[0]; };",No,No,O(n log k),3
"function isSymmetric(root) { const isMirror = (t1, t2) => { if (!t1 && !t2) return true; if (!t1 || !t2) return false; return (t1.val === t2.val) && isMirror(t1.right, t2.left) && isMirror(t1.left, t2.right); }; return isMirror(root, root); }",No,No,O(n),3
"const jump = (nums) => { let jumps = 0, currentEnd = 0, farthest = 0; for (let i = 0; i < nums.length - 1; i++) { farthest = Math.max(farthest, i + nums[i]); if (i === currentEnd) { jumps++; currentEnd = farthest; } } return jumps; };",No,No,O(n),2
"function inorderTraversal(root) { const res = []; const stack = []; let curr = root; while (curr || stack.length) { while (curr) { stack.push(curr); curr = curr.left; } curr = stack.pop(); res.push(curr.val); curr = curr.right; } return res; }",No,No,O(n),3
"const findPeakElement = (nums) => { let left = 0, right = nums.length - 1; while (left < right) { const mid = Math.floor((left + right) / 2); if (nums[mid] > nums[mid + 1]) right = mid; else left = mid + 1; } return left; };",No,No,O(log n),2
"function countAndSay(n) { if (n === 1) return '1'; let prev = countAndSay(n - 1); let result = ''; let count = 1; for (let i = 1; i < prev.length; i++) { if (prev[i] === prev[i - 1]) count++; else { result += count + prev[i - 1]; count = 1; } } result += count + prev[prev.length - 1]; return result; }",No,No,O(2^n),3
"const exist = (board, word) => { const dfs = (i, j, k) => { if (i < 0 || i >= board.length || j < 0 || j >= board[0].length || board[i][j] !== word[k]) return false; if (k === word.length - 1) return true; board[i][j] = '*'; const res = dfs(i + 1, j, k + 1) || dfs(i - 1, j, k + 1) || dfs(i, j + 1, k + 1) || dfs(i, j - 1, k + 1); board[i][j] = word[k]; return res; }; for (let i = 0; i < board.length; i++) { for (let j = 0; j < board[0].length; j++) { if (dfs(i, j, 0)) return true; } } return false; };",No,No,O(m * n * 4^k),3
"function minPathSum(grid) { const dp = Array(grid.length).fill(null).map(() => Array(grid[0].length).fill(0)); dp[0][0] = grid[0][0]; for (let i = 1; i < grid.length; i++) dp[i][0] = dp[i - 1][0] + grid[i][0]; for (let j = 1; j < grid[0].length; j++) dp[0][j] = dp[0][j - 1] + grid[0][j]; for (let i = 1; i < grid.length; i++) { for (let j = 1; j < grid[0].length; j++) { dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]; } } return dp[grid.length - 1][grid[0].length - 1]; }",No,No,O(m * n),2
"const canJump = (nums) => { let reachable = 0; for (let i = 0; i < nums.length; i++) { if (i > reachable) return false; reachable = Math.max(reachable, i + nums[i]); } return true; };",No,No,O(n),2
"function majorityElement(nums) { let count = 0, candidate = null; for (let num of nums) { if (count === 0) candidate = num; count += (num === candidate) ? 1 : -1; } return candidate; }",No,No,O(n),2
"const findKthLargest = (nums, k) => { nums.sort((a, b) => b - a); return nums[k - 1]; };",No,No,O(n log n),2
"function singleNumber(nums) { let result = 0; for (let num of nums) { result ^= num; } return result; }",No,No,O(n),2
"const combinationSum = (candidates, target) => { const result = []; const dfs = (i, current, total) => { if (total === target) { result.push([...current]); return; } if (i >= candidates.length || total > target) return; current.push(candidates[i]); dfs(i, current, total + candidates[i]); current.pop(); dfs(i + 1, current, total); }; dfs(0, [], 0); return result; };",No,No,O(2^n),3
"function groupAnagrams(strs) { const map = {}; for (let str of strs) { const key = [...str].sort().join(''); if (!map[key]) map[key] = []; map[key].push(str); } return Object.values(map); }",No,No,O(n * k log k),2
"const nextPermutation = (nums) => { let i = nums.length - 2; while (i >= 0 && nums[i] >= nums[i + 1]) i--; if (i >= 0) { let j = nums.length - 1; while (nums[j] <= nums[i]) j--; [nums[i], nums[j]] = [nums[j], nums[i]]; } nums = nums.slice(0, i + 1).concat(nums.slice(i + 1).reverse()); };",No,No,O(n),2
"function merge(intervals) { if (!intervals.length) return []; intervals.sort((a, b) => a[0] - b[0]); const merged = [intervals[0]]; for (let i = 1; i < intervals.length; i++) { const current = intervals[i]; const lastMerged = merged[merged.length - 1]; if (current[0] <= lastMerged[1]) lastMerged[1] = Math.max(lastMerged[1], current[1]); else merged.push(current); } return merged; }",No,No,O(n log n),3
"const permute = (nums) => { const result = []; const backtrack = (path) => { if (path.length === nums.length) { result.push([...path]); return; } for (let num of nums) { if (!path.includes(num)) { path.push(num); backtrack(path); path.pop(); } } }; backtrack([]); return result; };",No,No,O(n!),3
"function search(nums, target) { let left = 0, right = nums.length - 1; while (left <= right) { const mid = Math.floor((left + right) / 2); if (nums[mid] === target) return mid; if (nums[mid] < target) left = mid + 1; else right = mid - 1; } return -1; }",No,No,O(log n),2
"const subsets = (nums) => { const result = []; const backtrack = (start, path) => { result.push([...path]); for (let i = start; i < nums.length; i++) { path.push(nums[i]); backtrack(i + 1, path); path.pop(); } }; backtrack(0, []); return result; };",No,No,O(2^n),2
"function longestConsecutive(nums) { if (!nums.length) return 0; const set = new Set(nums); let maxStreak = 0; for (let num of set) { if (!set.has(num - 1)) { let currentNum = num; let currentStreak = 1; while (set.has(currentNum + 1)) { currentNum++; currentStreak++; } maxStreak = Math.max(maxStreak, currentStreak); } } return maxStreak; }",No,No,O(n),2
"const maxSubArray = (nums) => { let maxSum = nums[0]; let currentSum = nums[0]; for (let i = 1; i < nums.length; i++) { currentSum = Math.max(nums[i], currentSum + nums[i]); maxSum = Math.max(maxSum, currentSum); } return maxSum; };",No,No,O(n),2
"function canFinish(numCourses, prerequisites) { const graph = new Map(); const visited = new Array(numCourses).fill(false); const dfs = (course) => { if (visited[course]) return false; visited[course] = true; for (let pre of graph.get(course) || []) { if (!dfs(pre)) return false; } visited[course] = false; return true; }; for (let [course, pre] of prerequisites) { if (!graph.has(course)) graph.set(course, []); graph.get(course).push(pre); } for (let course of graph.keys()) { if (!dfs(course)) return false; } return true; }",No,No,O(n + p),3
"const productExceptSelf = (nums) => { const result = Array(nums.length).fill(1); let left = 1; for (let i = 0; i < nums.length; i++) { result[i] = left; left *= nums[i]; } let right = 1; for (let i = nums.length - 1; i >= 0; i--) { result[i] *= right; right *= nums[i]; } return result; };",No,No,O(n),2
"function minWindow(s, t) { const map = {}; for (let char of t) map[char] = (map[char] || 0) + 1; let start = 0, end = 0, minStart = 0, minLen = Infinity, counter = t.length; while (end < s.length) { if (map[s[end]] > 0) counter--; map[s[end]]--; end++; while (counter === 0) { if (end - start < minLen) { minLen = end - start; minStart = start; } map[s[start]]++; if (map[s[start]] > 0) counter++; start++; } } return minLen === Infinity ? '' : s.substr(minStart, minLen); }",No,No,O(s + t),3
"const twoSum = (nums, target) => { const map = new Map(); for (let i = 0; i < nums.length; i++) { if (map.has(target - nums[i])) return [map.get(target - nums[i]), i]; map.set(nums[i], i); } };",No,No,O(n),2
"function threeSum(nums) { nums.sort((a, b) => a - b); const result = []; for (let i = 0; i < nums.length - 2; i++) { if (i > 0 && nums[i] === nums[i - 1]) continue; let left = i + 1, right = nums.length - 1; while (left < right) { const sum = nums[i] + nums[left] + nums[right]; if (sum === 0) { result.push([nums[i], nums[left], nums[right]]); while (nums[left] === nums[left + 1]) left++; while (nums[right] === nums[right - 1]) right--; left++; right--; } else if (sum < 0) left++; else right--; } } return result; }",No,No,O(n^2),3
"const findMedianSortedArrays = (nums1, nums2) => { const merge = (a, b) => { const merged = []; let i = 0, j = 0; while (i < a.length && j < b.length) { if (a[i] < b[j]) merged.push(a[i++]); else merged.push(b[j++]); } return merged.concat(a.slice(i)).concat(b.slice(j)); }; const merged = merge(nums1, nums2); const mid = Math.floor(merged.length / 2); return merged.length % 2 === 0 ? (merged[mid - 1] + merged[mid]) / 2 : merged[mid]; };",No,No,O(n + m),2
"function letterCombinations(digits) { if (!digits.length) return []; const map = { 2: 'abc', 3: 'def', 4: 'ghi', 5: 'jkl', 6: 'mno', 7: 'pqrs', 8: 'tuv', 9: 'wxyz' }; const result = []; const backtrack = (index, path) => { if (path.length === digits.length) { result.push(path); return; } for (let char of map[digits[index]]) backtrack(index + 1, path + char); }; backtrack(0, ''); return result; }",No,No,O(4^n),3
"const searchMatrix = (matrix, target) => { if (!matrix.length || !matrix[0].length) return false; let row = 0, col = matrix[0].length - 1; while (row < matrix.length && col >= 0) { if (matrix[row][col] === target) return true; if (matrix[row][col] > target) col--; else row++; } return false; };",No,No,O(m + n),2
"function findDuplicates(nums) { const result = []; for (let num of nums) { const index = Math.abs(num) - 1; if (nums[index] < 0) result.push(index + 1); else nums[index] = -nums[index]; } return result; }",No,No,O(n),2
"const rob = (nums) => { let prev = 0, curr = 0; for (let num of nums) { let temp = Math.max(num + prev, curr); prev = curr; curr = temp; } return curr; };",No,No,O(n),2
"function coinChange(coins, amount) { const dp = Array(amount + 1).fill(Infinity); dp[0] = 0; for (let coin of coins) { for (let i = coin; i <= amount; i++) dp[i] = Math.min(dp[i], dp[i - coin] + 1); } return dp[amount] === Infinity ? -1 : dp[amount]; }",No,No,O(n),2
"const addBinary = (a, b) => { let i = a.length - 1, j = b.length - 1, carry = 0, result = ''; while (i >= 0 || j >= 0 || carry) { const sum = (i >= 0 ? +a[i--] : 0) + (j >= 0 ? +b[j--] : 0) + carry; carry = Math.floor(sum / 2); result = (sum % 2) + result; } return result; };",No,No,O(n),2
"function rotate(matrix) { for (let i = 0; i < matrix.length; i++) { for (let j = i; j < matrix[0].length; j++) { [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]]; } } for (let row of matrix) row.reverse(); }",No,No,O(n^2),2
"const maxProfit = (prices) => { let minPrice = prices[0], maxProfit = 0; for (let price of prices) { minPrice = Math.min(minPrice, price); maxProfit = Math.max(maxProfit, price - minPrice); } return maxProfit; };",No,No,O(n),2
"function flatten(root) { let prev = null; const dfs = (node) => { if (!node) return; dfs(node.right); dfs(node.left); node.right = prev; node.left = null; prev = node; }; dfs(root); }",No,No,O(n),2
"const zigzagLevelOrder = (root) => { if (!root) return []; const result = []; let queue = [root], direction = true; while (queue.length) { const level = []; const size = queue.length; for (let i = 0; i < size; i++) { const node = queue.shift(); if (direction) level.push(node.val); else level.unshift(node.val); if (node.left) queue.push(node.left); if (node.right) queue.push(node.right); } result.push(level); direction = !direction; } return result; };",No,No,O(n),2
"function longestPalindrome(s) { let res = ''; for (let i = 0; i < s.length; i++) { let odd = expandFromCenter(s, i, i); let even = expandFromCenter(s, i, i + 1); let longer = odd.length > even.length ? odd : even; res = longer.length > res.length ? longer : res; } return res; } function expandFromCenter(s, left, right) { while (left >= 0 && right < s.length && s[left] === s[right]) { left--; right++; } return s.slice(left + 1, right); }",No,No,O(n^2),3
"const inorderTraversal = (root) => { const result = []; const stack = []; let current = root; while (current || stack.length) { while (current) { stack.push(current); current = current.left; } current = stack.pop(); result.push(current.val); current = current.right; } return result; };",No,No,O(n),2
"function maxDepth(root) { if (!root) return 0; let maxDepth = 0; const dfs = (node, depth) => { if (!node) return; maxDepth = Math.max(maxDepth, depth); dfs(node.left, depth + 1); dfs(node.right, depth + 1); }; dfs(root, 1); return maxDepth; }",No,No,O(n),2
"const reverseList = (head) => { let prev = null; while (head) { let next = head.next; head.next = prev; prev = head; head = next; } return prev; };",No,No,O(n),2
"function hasCycle(head) { let slow = head, fast = head; while (fast && fast.next) { slow = slow.next; fast = fast.next.next; if (slow === fast) return true; } return false; }",No,No,O(n),2
"const addTwoNumbers = (l1, l2) => { let carry = 0, result = new ListNode(0), current = result; while (l1 || l2 || carry) { let sum = (l1 ? l1.val : 0) + (l2 ? l2.val : 0) + carry; carry = Math.floor(sum / 10); current.next = new ListNode(sum % 10); current = current.next; l1 = l1 ? l1.next : null; l2 = l2 ? l2.next : null; } return result.next; };",No,No,O(n),2
"function deleteNode(node) { node.val = node.next.val; node.next = node.next.next; }",No,No,O(1),1
"const mergeTwoLists = (l1, l2) => { if (!l1) return l2; if (!l2) return l1; if (l1.val < l2.val) { l1.next = mergeTwoLists(l1.next, l2); return l1; } else { l2.next = mergeTwoLists(l2.next, l1); return l2; } };",No,No,O(n + m),2
"function removeNthFromEnd(head, n) { let dummy = new ListNode(0); dummy.next = head; let first = dummy, second = dummy; for (let i = 0; i <= n; i++) first = first.next; while (first) { first = first.next; second = second.next; } second.next = second.next.next; return dummy.next; }",No,No,O(n),2
"const isValidBST = (root) => { const validate = (node, low = -Infinity, high = Infinity) => { if (!node) return true; if (node.val <= low || node.val >= high) return false; return validate(node.left, low, node.val) && validate(node.right, node.val, high); }; return validate(root); };",No,No,O(n),2
"function buildTree(preorder, inorder) { if (!preorder.length || !inorder.length) return null; const root = new TreeNode(preorder[0]); const mid = inorder.indexOf(preorder[0]); root.left = buildTree(preorder.slice(1, mid + 1), inorder.slice(0, mid)); root.right = buildTree(preorder.slice(mid + 1), inorder.slice(mid + 1)); return root; }",No,No,O(n),2
"const levelOrder = (root) => { if (!root) return []; const result = []; const queue = [root]; while (queue.length) { const level = []; const size = queue.length; for (let i = 0; i < size; i++) { const node = queue.shift(); level.push(node.val); if (node.left) queue.push(node.left); if (node.right) queue.push(node.right); } result.push(level); } return result; };",No,No,O(n),2
"function kthSmallest(root, k) { const inorder = (node) => { if (!node) return []; return [...inorder(node.left), node.val, ...inorder(node.right)]; }; return inorder(root)[k - 1]; }",No,No,O(n),2
"const lowestCommonAncestor = (root, p, q) => { if (!root || root === p || root === q) return root; const left = lowestCommonAncestor(root.left, p, q); const right = lowestCommonAncestor(root.right, p, q); return left && right ? root : left || right; };",No,No,O(n),2
"function rightSideView(root) { if (!root) return []; const result = []; let queue = [root]; while (queue.length) { const size = queue.length; result.push(queue[size - 1].val); for (let i = 0; i < size; i++) { const node = queue.shift(); if (node.left) queue.push(node.left); if (node.right) queue.push(node.right); } } return result; }",No,No,O(n),2
"const isSymmetric = (root) => { if (!root) return true; const isMirror = (t1, t2) => { if (!t1 && !t2) return true; if (!t1 || !t2 || t1.val !== t2.val) return false; return isMirror(t1.left, t2.right) && isMirror(t1.right, t2.left); }; return isMirror(root.left, root.right); };",No,No,O(n),2
"function pathSum(root, targetSum) { if (!root) return []; const result = []; const dfs = (node, currentSum, path) => { if (!node) return; currentSum += node.val; path.push(node.val); if (!node.left && !node.right && currentSum === targetSum) result.push([...path]); dfs(node.left, currentSum, path); dfs(node.right, currentSum, path); path.pop(); }; dfs(root, 0, []); return result; }",No,No,O(n),2
"const invertTree = (root) => { if (!root) return null; const left = invertTree(root.left); const right = invertTree(root.right); root.left = right; root.right = left; return root; };",No,No,O(n),2
"function sumNumbers(root) { let sum = 0; const dfs = (node, currentSum) => { if (!node) return; currentSum = currentSum * 10 + node.val; if (!node.left && !node.right) sum += currentSum; dfs(node.left, currentSum); dfs(node.right, currentSum); }; dfs(root, 0); return sum; }",No,No,O(n),2
"const flatten = (root) => { if (!root) return; flatten(root.right); flatten(root.left); root.right = prev; root.left = null; prev = root; }; let prev = null;",No,No,O(n),2
"function findDuplicate(nums) { let slow = nums[0], fast = nums[0]; do { slow = nums[slow]; fast = nums[nums[fast]]; } while (slow !== fast); slow = nums[0]; while (slow !== fast) { slow = nums[slow]; fast = nums[fast]; } return slow; }",No,No,O(n),2
"const majorityElement = (nums) => { let count = 0, candidate = null; for (let num of nums) { if (count === 0) candidate = num; count += (num === candidate) ? 1 : -1; } return candidate; };",No,No,O(n),2
"function rotate(nums, k) { k %= nums.length; reverse(nums, 0, nums.length - 1); reverse(nums, 0, k - 1); reverse(nums, k, nums.length - 1); } function reverse(nums, start, end) { while (start < end) { [nums[start], nums[end]] = [nums[end], nums[start]]; start++; end--; } }",No,No,O(n),2
"const containsDuplicate = (nums) => { const set = new Set(); for (let num of nums) { if (set.has(num)) return true; set.add(num); } return false; };",No,No,O(n),2
"function maxProduct(nums) { let max = -Infinity, min = Infinity, result = -Infinity; for (let num of nums) { if (num < 0) [max, min] = [min, max]; max = Math.max(num, max * num); min = Math.min(num, min * num); result = Math.max(result, max); } return result; }",No,No,O(n),2
"function singleNumber(nums) { return nums.reduce((acc, num) => acc ^ num, 0); }",No,No,O(n),2
"const twoSum = (nums, target) => { const map = new Map(); for (let i = 0; i < nums.length; i++) { const complement = target - nums[i]; if (map.has(complement)) return [map.get(complement), i]; map.set(nums[i], i); } return []; };",No,No,O(n),2
"function merge(intervals) { if (!intervals.length) return []; intervals.sort((a, b) => a[0] - b[0]); const merged = [intervals[0]]; for (let i = 1; i < intervals.length; i++) { const current = intervals[i]; const last = merged[merged.length - 1]; if (current[0] <= last[1]) last[1] = Math.max(last[1], current[1]); else merged.push(current); } return merged; }",No,No,O(n log n),3
"const maxSubArray = (nums) => { let maxSoFar = nums[0], maxEndingHere = nums[0]; for (let i = 1; i < nums.length; i++) { maxEndingHere = Math.max(nums[i], maxEndingHere + nums[i]); maxSoFar = Math.max(maxSoFar, maxEndingHere); } return maxSoFar; };",No,No,O(n),2
"function climbStairs(n) { if (n <= 2) return n; let prev = 1, current = 2; for (let i = 3; i <= n; i++) { const next = prev + current; prev = current; current = next; } return current; }",No,No,O(n),2
"const coinChange = (coins, amount) => { const dp = Array(amount + 1).fill(Infinity); dp[0] = 0; for (let coin of coins) { for (let i = coin; i <= amount; i++) { dp[i] = Math.min(dp[i], dp[i - coin] + 1); } } return dp[amount] === Infinity ? -1 : dp[amount]; };",No,No,O(n * m),3
"function minPathSum(grid) { const rows = grid.length, cols = grid[0].length; const dp = Array(rows).fill(0).map(() => Array(cols).fill(0)); dp[0][0] = grid[0][0]; for (let i = 1; i < rows; i++) dp[i][0] = dp[i - 1][0] + grid[i][0]; for (let j = 1; j < cols; j++) dp[0][j] = dp[0][j - 1] + grid[0][j]; for (let i = 1; i < rows; i++) { for (let j = 1; j < cols; j++) { dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]; } } return dp[rows - 1][cols - 1]; }",No,No,O(n * m),3
"const rob = (nums) => { let prev1 = 0, prev2 = 0; for (let num of nums) { let temp = prev1; prev1 = Math.max(prev1, prev2 + num); prev2 = temp; } return prev1; };",No,No,O(n),2
"function jump(nums) { let jumps = 0, farthest = 0, end = 0; for (let i = 0; i < nums.length - 1; i++) { farthest = Math.max(farthest, i + nums[i]); if (i === end) { jumps++; end = farthest; } } return jumps; }",No,No,O(n),2
"const lengthOfLIS = (nums) => { const dp = Array(nums.length).fill(1); for (let i = 1; i < nums.length; i++) { for (let j = 0; j < i; j++) { if (nums[i] > nums[j]) dp[i] = Math.max(dp[i], dp[j] + 1); } } return Math.max(...dp); };",No,No,O(n^2),3
"function canJump(nums) { let maxReach = 0; for (let i = 0; i < nums.length; i++) { if (i > maxReach) return false; maxReach = Math.max(maxReach, i + nums[i]); } return true; }",No,No,O(n),2
"const uniquePaths = (m, n) => { const dp = Array(m).fill(0).map(() => Array(n).fill(1)); for (let i = 1; i < m; i++) { for (let j = 1; j < n; j++) { dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } return dp[m - 1][n - 1]; };",No,No,O(m * n),3
"function countSubstrings(s) { let count = 0; for (let i = 0; i < s.length; i++) { count += expandFromCenter(s, i, i); count += expandFromCenter(s, i, i + 1); } return count; } function expandFromCenter(s, left, right) { let count = 0; while (left >= 0 && right < s.length && s[left] === s[right]) { count++; left--; right++; } return count; }",No,No,O(n^2),3
"const numIslands = (grid) => { let count = 0; const dfs = (i, j) => { if (i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || grid[i][j] === '0') return; grid[i][j] = '0'; dfs(i + 1, j); dfs(i - 1, j); dfs(i, j + 1); dfs(i, j - 1); }; for (let i = 0; i < grid.length; i++) { for (let j = 0; j < grid[0].length; j++) { if (grid[i][j] === '1') { count++; dfs(i, j); } } } return count; };",No,No,O(n * m),3
"function maxArea(height) { let maxArea = 0, left = 0, right = height.length - 1; while (left < right) { const area = Math.min(height[left], height[right]) * (right - left); maxArea = Math.max(maxArea, area); if (height[left] < height[right]) left++; else right--; } return maxArea; }",No,No,O(n),2
"const trap = (height) => { let left = 0, right = height.length - 1, leftMax = 0, rightMax = 0, result = 0; while (left < right) { if (height[left] < height[right]) { leftMax = Math.max(leftMax, height[left]); result += leftMax - height[left]; left++; } else { rightMax = Math.max(rightMax, height[right]); result += rightMax - height[right]; right--; } } return result; };",No,No,O(n),2
"function longestValidParentheses(s) { let maxLen = 0; const stack = [-1]; for (let i = 0; i < s.length; i++) { if (s[i] === '(') stack.push(i); else { stack.pop(); if (stack.length) maxLen = Math.max(maxLen, i - stack[stack.length - 1]); else stack.push(i); } } return maxLen; }",No,No,O(n),2
"const dailyTemperatures = (T) => { const result = Array(T.length).fill(0); const stack = []; for (let i = 0; i < T.length; i++) { while (stack.length && T[i] > T[stack[stack.length - 1]]) { const idx = stack.pop(); result[idx] = i - idx; } stack.push(i); } return result; };",No,No,O(n),2
"function largestRectangleArea(heights) { const stack = [], result = 0; for (let i = 0; i <= heights.length; i++) { while (stack.length && (i === heights.length || heights[i] < heights[stack[stack.length - 1]])) { const height = heights[stack.pop()]; const width = stack.length ? i - stack[stack.length - 1] - 1 : i; result = Math.max(result, height * width); } stack.push(i); } return result; }",No,No,O(n),2
"const maximalRectangle = (matrix) => { if (!matrix.length) return 0; const heights = Array(matrix[0].length).fill(0); let maxArea = 0; for (let row of matrix) { for (let i = 0; i < row.length; i++) { heights[i] = row[i] === '1' ? heights[i] + 1 : 0; } maxArea = Math.max(maxArea, largestRectangleArea(heights)); } return maxArea; };",No,No,O(n * m),3
"function maximalSquare(matrix) { if (!matrix.length) return 0; const dp = Array(matrix.length).fill(0).map(() => Array(matrix[0].length).fill(0)); let maxSide = 0; for (let i = 0; i < matrix.length; i++) { for (let j = 0; j < matrix[0].length; j++) { if (matrix[i][j] === '1') { dp[i][j] = i === 0 || j === 0 ? 1 : Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1; maxSide = Math.max(maxSide, dp[i][j]); } } } return maxSide * maxSide; }",No,No,O(n * m),3
"const wordBreak = (s, wordDict) => { const dp = Array(s.length + 1).fill(false); dp[0] = true; for (let i = 1; i <= s.length; i++) { for (let word of wordDict) { if (i >= word.length && dp[i - word.length] && s.slice(i - word.length, i) === word) { dp[i] = true; break; } } } return dp[s.length]; };",No,No,O(n * m),3
"function numDecodings(s) { if (!s.length) return 0; const dp = Array(s.length + 1).fill(0); dp[0] = 1; dp[1] = s[0] === '0' ? 0 : 1; for (let i = 2; i <= s.length; i++) { const oneDigit = s.slice(i - 1, i); const twoDigits = s.slice(i - 2, i); if (oneDigit >= '1' && oneDigit <= '9') dp[i] += dp[i - 1]; if (twoDigits >= '10' && twoDigits <= '26') dp[i] += dp[i - 2]; } return dp[s.length]; }",No,No,O(n),2
"const generateParenthesis = (n) => { const result = []; const backtrack = (open, close, path) => { if (open === n && close === n) return result.push(path); if (open < n) backtrack(open + 1, close, path + '('); if (close < open) backtrack(open, close + 1, path + ')'); }; backtrack(0, 0, ''); return result; };",No,No,O(4^n / sqrt(n)),3
"function findMin(nums) { let left = 0, right = nums.length - 1; while (left < right) { const mid = Math.floor((left + right) / 2); if (nums[mid] > nums[right]) left = mid + 1; else right = mid; } return nums[left]; }",No,No,O(log n),2
"const searchRange = (nums, target) => { const binarySearch = (left, right) => { if (left > right) return [-1, -1]; const mid = Math.floor((left + right) / 2); if (nums[mid] === target) { let l = mid, r = mid; while (nums[l - 1] === target) l--; while (nums[r + 1] === target) r++; return [l, r]; } if (nums[mid] > target) return binarySearch(left, mid - 1); else return binarySearch(mid + 1, right); }; return binarySearch(0, nums.length - 1); };",No,No,O(log n),2
"function findKthLargest(nums, k) { const quickSelect = (left, right, kSmallest) => { if (left === right) return nums[left]; const pivotIndex = Math.floor(Math.random() * (right - left + 1)) + left; const pivotValue = nums[pivotIndex]; let index = partition(left, right, pivotIndex, pivotValue); if (kSmallest === index) return nums[index]; else if (kSmallest < index) return quickSelect(left, index - 1, kSmallest); else return quickSelect(index + 1, right, kSmallest); }; const partition = (left, right, pivotIndex, pivotValue) => { [nums[pivotIndex], nums[right]] = [nums[right], nums[pivotIndex]]; let storeIndex = left; for (let i = left; i < right; i++) { if (nums[i] < pivotValue) { [nums[storeIndex], nums[i]] = [nums[i], nums[storeIndex]]; storeIndex++; } } [nums[storeIndex], nums[right]] = [nums[right], nums[storeIndex]]; return storeIndex; }; return quickSelect(0, nums.length - 1, nums.length - k); }",No,No,O(n),3
"const mergeKLists = (lists) => { if (!lists.length) return null; const mergeTwoLists = (l1, l2) => { const dummy = new ListNode(0); let tail = dummy; while (l1 && l2) { if (l1.val < l2.val) { tail.next = l1; l1 = l1.next; } else { tail.next = l2; l2 = l2.next; } tail = tail.next; } tail.next = l1 || l2; return dummy.next; }; let mergedList = lists[0]; for (let i = 1; i < lists.length; i++) mergedList = mergeTwoLists(mergedList, lists[i]); return mergedList; };",No,No,O(n log k),3
"function longestPalindromeSubseq(s) { const dp = Array(s.length).fill(0).map(() => Array(s.length).fill(0)); for (let i = 0; i < s.length; i++) dp[i][i] = 1; for (let len = 2; len <= s.length; len++) { for (let i = 0; i <= s.length - len; i++) { const j = i + len - 1; if (s[i] === s[j]) dp[i][j] = dp[i + 1][j - 1] + 2; else dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]); } } return dp[0][s.length - 1]; }",No,No,O(n^2),3
"const combinationSum = (candidates, target) => { const result = []; const backtrack = (start, path, remain) => { if (remain === 0) return result.push(path); if (remain < 0) return; for (let i = start; i < candidates.length; i++) backtrack(i, [...path, candidates[i]], remain - candidates[i]); }; backtrack(0, [], target); return result; };",No,No,O(2^n),3
"function permute(nums) { const result = []; const backtrack = (path) => { if (path.length === nums.length) return result.push(path); for (let i = 0; i < nums.length; i++) { if (path.includes(nums[i])) continue; backtrack([...path, nums[i]]); } }; backtrack([]); return result; }",No,No,O(n!),3
"const subsets = (nums) => { const result = []; const backtrack = (start, path) => { result.push(path); for (let i = start; i < nums.length; i++) backtrack(i + 1, [...path, nums[i]]); }; backtrack(0, []); return result; };",No,No,O(2^n),3
"function letterCombinations(digits) { if (!digits.length) return []; const digitToChar = { '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz' }; const result = []; const backtrack = (index, path) => { if (path.length === digits.length) return result.push(path); for (let char of digitToChar[digits[index]]) backtrack(index + 1, path + char); }; backtrack(0, ''); return result; }",No,No,O(3^n),3
"const isValidSudoku = (board) => { const rows = Array(9).fill().map(() => new Set()), cols = Array(9).fill().map(() => new Set()), boxes = Array(9).fill().map(() => new Set()); for (let i = 0; i < 9; i++) { for (let j = 0; j < 9; j++) { if (board[i][j] !== '.') { const num = board[i][j]; const boxIndex = Math.floor(i / 3) * 3 + Math.floor(j / 3); if (rows[i].has(num) || cols[j].has(num) || boxes[boxIndex].has(num)) return false; rows[i].add(num); cols[j].add(num); boxes[boxIndex].add(num); } } } return true; };",No,No,O(1),2
"function solveSudoku(board) { const isValid = (row, col, num) => { for (let i = 0; i < 9; i++) { if (board[row][i] === num || board[i][col] === num) return false; } const boxRow = Math.floor(row / 3) * 3; const boxCol = Math.floor(col / 3) * 3; for (let i = boxRow; i < boxRow + 3; i++) { for (let j = boxCol; j < boxCol + 3; j++) { if (board[i][j] === num) return false; } } return true; }; const backtrack = () => { for (let i = 0; i < 9; i++) { for (let j = 0; j < 9; j++) { if (board[i][j] === '.') { for (let num = 1; num <= 9; num++) { if (isValid(i, j, num.toString())) { board[i][j] = num.toString(); if (backtrack()) return true; board[i][j] = '.'; } } return false; } } } return true; }; backtrack(); }",No,No,O(9^(n*n)),3
"const searchInsert = (nums, target) => { let left = 0, right = nums.length - 1; while (left <= right) { const mid = Math.floor((left + right) / 2); if (nums[mid] === target) return mid; if (nums[mid] < target) left = mid + 1; else right = mid - 1; } return left; };",No,No,O(log n),2
"function isAnagram(s, t) { if (s.length !== t.length) return false; const count = {}; for (let char of s) count[char] = (count[char] || 0) + 1; for (let char of t) { if (!count[char]) return false; count[char]--; } return true; }",No,No,O(n),2
"const groupAnagrams = (strs) => { const map = {}; for (let str of strs) { const sortedStr = str.split('').sort().join(''); if (!map[sortedStr]) map[sortedStr] = []; map[sortedStr].push(str); } return Object.values(map); };",No,No,O(n * k log k),3
"const topKFrequent = (nums, k) => { const freqMap = {}; for (let num of nums) freqMap[num] = (freqMap[num] || 0) + 1; const sorted = Object.entries(freqMap).sort((a, b) => b[1] - a[1]); return sorted.slice(0, k).map(item => item[0]); };",No,No,O(n log n),3
"function findMode(root) { const count = {}, maxCount = [0], modes = []; const traverse = (node) => { if (!node) return; count[node.val] = (count[node.val] || 0) + 1; if (count[node.val] > maxCount[0]) { maxCount[0] = count[node.val]; modes.length = 0; modes.push(node.val); } else if (count[node.val] === maxCount[0]) modes.push(node.val); traverse(node.left); traverse(node.right); }; traverse(root); return modes; }",No,No,O(n),2
"const constructBinaryTree = (preorder, inorder) => { if (!preorder.length) return null; const root = new TreeNode(preorder[0]); const index = inorder.indexOf(preorder[0]); root.left = constructBinaryTree(preorder.slice(1, index + 1), inorder.slice(0, index)); root.right = constructBinaryTree(preorder.slice(index + 1), inorder.slice(index + 1)); return root; };",No,No,O(n),3
"const binaryTreePaths = (root) => { const paths = []; const dfs = (node, path) => { if (!node) return; path += node.val; if (!node.left && !node.right) paths.push(path); else { path += '->'; dfs(node.left, path); dfs(node.right, path); } }; dfs(root, ''); return paths; };",No,No,O(n),3
"function maxDepth(root) { if (!root) return 0; return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1; }",No,No,O(n),2
"function lowestCommonAncestor(root, p, q) { if (!root || root === p || root === q) return root; const left = lowestCommonAncestor(root.left, p, q); const right = lowestCommonAncestor(root.right, p, q); if (left && right) return root; return left || right; }",No,No,O(n),2
"const numTrees = (n) => { const dp = Array(n + 1).fill(0); dp[0] = 1; for (let i = 1; i <= n; i++) { for (let j = 0; j < i; j++) dp[i] += dp[j] * dp[i - j - 1]; } return dp[n]; };",No,No,O(n^2),3
"const uniquePaths = (m, n) => { const dp = Array(m).fill(0).map(() => Array(n).fill(0)); for (let i = 0; i < m; i++) dp[i][0] = 1; for (let j = 0; j < n; j++) dp[0][j] = 1; for (let i = 1; i < m; i++) { for (let j = 1; j < n; j++) dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } return dp[m - 1][n - 1]; };",No,No,O(m * n),3
"const climbStairs = (n) => { if (n <= 2) return n; let first = 1, second = 2; for (let i = 3; i <= n; i++) { const temp = second; second += first; first = temp; } return second; };",No,No,O(n),2
"const coinChange = (coins, amount) => { const dp = Array(amount + 1).fill(Infinity); dp[0] = 0; for (let coin of coins) { for (let i = coin; i <= amount; i++) { dp[i] = Math.min(dp[i], dp[i - coin] + 1); } } return dp[amount] === Infinity ? -1 : dp[amount]; };",No,No,O(n * amount),3
"function lengthOfLIS(nums) { const dp = Array(nums.length).fill(1); let maxLength = 1; for (let i = 0; i < nums.length; i++) { for (let j = 0; j < i; j++) { if (nums[i] > nums[j]) { dp[i] = Math.max(dp[i], dp[j] + 1); maxLength = Math.max(maxLength, dp[i]); } } } return maxLength; }",No,No,O(n^2),3
"function maxProfit(prices) { let maxProfit = 0; for (let i = 0; i < prices.length; i++) { for (let j = i + 1; j < prices.length; j++) { maxProfit = Math.max(maxProfit, prices[j] - prices[i]); } } return maxProfit; }",No,No,O(n^2),3
"function containsDuplicate(nums) { const set = new Set(); for (let num of nums) { if (set.has(num)) return true; set.add(num); } return false; }",No,No,O(n),2
"const singleNumber = (nums) => { return nums.reduce((acc, num) => acc ^ num, 0); };",No,No,O(n),2
"function intersect(nums1, nums2) { const count = {}; const result = []; for (let num of nums1) count[num] = (count[num] || 0) + 1; for (let num of nums2) { if (count[num] > 0) { result.push(num); count[num]--; } } return result; }",No,No,O(n),2
"const isSubsequence = (s, t) => { let sIndex = 0; for (let char of t) { if (s[sIndex] === char) sIndex++; if (sIndex === s.length) return true; } return sIndex === s.length; };",No,No,O(n),2
"const minimumWindowSubstring = (s, t) => { const countT = {}; const windowCount = {}; for (let char of t) countT[char] = (countT[char] || 0) + 1; let left = 0, right = 0, required = Object.keys(countT).length, formed = 0; let ans = [Infinity, 0, 0]; while (right < s.length) { const char = s[right]; windowCount[char] = (windowCount[char] || 0) + 1; if (char in countT && windowCount[char] === countT[char]) formed++; while (left <= right && formed === required) { const charLeft = s[left]; if (right - left + 1 < ans[0]) ans = [right - left + 1, left, right]; windowCount[charLeft]--; if (charLeft in countT && windowCount[charLeft] < countT[charLeft]) formed--; left++; } right++; } return ans[0] === Infinity ? "" : s.substring(ans[1], ans[2] + 1); };",No,No,O(n),3
"const threeSum = (nums) => { nums.sort((a, b) => a - b); const result = []; for (let i = 0; i < nums.length - 2; i++) { if (i > 0 && nums[i] === nums[i - 1]) continue; let left = i + 1, right = nums.length - 1; while (left < right) { const sum = nums[i] + nums[left] + nums[right]; if (sum < 0) left++; else if (sum > 0) right--; else { result.push([nums[i], nums[left], nums[right]]); while (nums[left] === nums[left + 1]) left++; while (nums[right] === nums[right - 1]) right--; left++; right--; } } } return result; };",No,No,O(n^2),3
"function generateParenthesis(n) { const result = []; const backtrack = (open, close, path) => { if (open === n && close === n) return result.push(path); if (open < n) backtrack(open + 1, close, path + '('); if (close < open) backtrack(open, close + 1, path + ')'); }; backtrack(0, 0, ''); return result; }",No,No,O(4^n / sqrt(n)),3
"const validPalindrome = (s) => { const isPalindrome = (str, left, right) => { while (left < right) { if (str[left] !== str[right]) return false; left++; right--; } return true; }; let left = 0, right = s.length - 1; while (left < right) { if (s[left] !== s[right]) return isPalindrome(s, left + 1, right) || isPalindrome(s, left, right - 1); left++; right--; } return true; };",No,No,O(n),2
"const numIslands = (grid) => { if (!grid.length) return 0; let count = 0; const dfs = (i, j) => { if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] === '0') return; grid[i][j] = '0'; dfs(i + 1, j); dfs(i - 1, j); dfs(i, j + 1); dfs(i, j - 1); }; for (let i = 0; i < grid.length; i++) { for (let j = 0; j < grid[0].length; j++) { if (grid[i][j] === '1') { count++; dfs(i, j); } } } return count; };",No,No,O(m * n),3
"function countBattleships(board) { let count = 0; for (let i = 0; i < board.length; i++) { for (let j = 0; j < board[0].length; j++) { if (board[i][j] === 'X') { count++; while (i < board.length && board[i][j] === 'X') i++; while (j < board[0].length && board[i][j] === 'X') j++; } } } return count; }",No,No,O(m * n),3
"const numberOfSteps = (num) => { let steps = 0; while (num > 0) { num = num % 2 === 0 ? num / 2 : num - 1; steps++; } return steps; };",No,No,O(log n),2
"const majorityElement = (nums) => { let count = 0, candidate; for (let num of nums) { if (count === 0) candidate = num; count += (num === candidate) ? 1 : -1; } return candidate; };",No,No,O(n),2
"const rearrangeArray = (nums) => { const pos = [], neg = []; for (let num of nums) (num > 0 ? pos : neg).push(num); return pos.flatMap((p, i) => [p, neg[i]]); };",No,No,O(n),2
"const checkIfExist = (arr) => { const set = new Set(); for (let num of arr) { if (set.has(num * 2) || (num % 2 === 0 && set.has(num / 2))) return true; set.add(num); } return false; };",No,No,O(n),2
"function maximumWealth(accounts) { let maxWealth = 0; for (let account of accounts) { maxWealth = Math.max(maxWealth, account.reduce((a, b) => a + b, 0)); } return maxWealth; }",No,No,O(m * n),2
"const maxArea = (height) => { let left = 0, right = height.length - 1; let maxArea = 0; while (left < right) { maxArea = Math.max(maxArea, Math.min(height[left], height[right]) * (right - left)); height[left] < height[right] ? left++ : right--; } return maxArea; };",No,No,O(n),2
"const longestCommonPrefix = (strs) => { if (!strs.length) return ''; let prefix = strs[0]; for (let i = 1; i < strs.length; i++) { while (strs[i].indexOf(prefix) !== 0) { prefix = prefix.substring(0, prefix.length - 1); } } return prefix; };",No,No,O(n * m),3
"const twoSum = (nums, target) => { const map = new Map(); for (let i = 0; i < nums.length; i++) { const complement = target - nums[i]; if (map.has(complement)) return [map.get(complement), i]; map.set(nums[i], i); } };",No,No,O(n),2
"function addTwoNumbers(l1, l2) { const dummyHead = new ListNode(0); let p = l1, q = l2, current = dummyHead, carry = 0; while (p || q || carry) { const sum = (p ? p.val : 0) + (q ? q.val : 0) + carry; carry = Math.floor(sum / 10); current.next = new ListNode(sum % 10); current = current.next; if (p) p = p.next; if (q) q = q.next; } return dummyHead.next; }",No,No,O(n),3
"function reverseList(head) { let prev = null; while (head) { const nextTemp = head.next; head.next = prev; prev = head; head = nextTemp; } return prev; }",No,No,O(n),2
"function isPalindrome(head) { let slow = head, fast = head; while (fast && fast.next) { slow = slow.next; fast = fast.next.next; } let prev = null; while (slow) { const nextTemp = slow.next; slow.next = prev; prev = slow; slow = nextTemp; } slow = head; while (prev) { if (prev.val !== slow.val) return false; prev = prev.next; slow = slow.next; } return true; }",No,No,O(n),3
"function mergeTwoLists(l1, l2) { const dummy = new ListNode(0); let current = dummy; while (l1 && l2) { if (l1.val < l2.val) { current.next = l1; l1 = l1.next; } else { current.next = l2; l2 = l2.next; } current = current.next; } current.next = l1 || l2; return dummy.next; }",No,No,O(n),3
"const lengthOfLastWord = (s) => { const words = s.trim().split(' '); return words.length ? words[words.length - 1].length : 0; };",No,No,O(n),2
"const myAtoi = (s) => { s = s.trim(); const sign = s[0] === '-' ? -1 : 1; let result = 0, i = s[0] === '+' || s[0] === '-' ? 1 : 0; while (i < s.length && !isNaN(s[i])) { result = result * 10 + (s[i] - '0'); i++; } return Math.max(Math.min(result * sign, 2 ** 31 - 1), -2 ** 31); };",No,No,O(n),2
"const climbStairs = (n) => { const dp = [1, 1]; for (let i = 2; i <= n; i++) { dp[i] = dp[i - 1] + dp[i - 2]; } return dp[n]; };",No,No,O(n),2
"const rotate = (nums, k) => { k %= nums.length; reverse(nums, 0, nums.length - 1); reverse(nums, 0, k - 1); reverse(nums, k, nums.length - 1); }; const reverse = (arr, start, end) => { while (start < end) { [arr[start], arr[end]] = [arr[end], arr[start]]; start++; end--; } };",No,No,O(n),2
"function searchInsert(nums, target) { let left = 0, right = nums.length - 1; while (left <= right) { const mid = Math.floor((left + right) / 2); if (nums[mid] === target) return mid; else if (nums[mid] < target) left = mid + 1; else right = mid - 1; } return left; }",No,No,O(log n),2
"function singleNumber(nums) { const unique = new Set(); for (const num of nums) { if (unique.has(num)) unique.delete(num); else unique.add(num); } return [...unique][0]; }",No,No,O(n),2
"const sortedSquares = (nums) => { return nums.map(num => num * num).sort((a, b) => a - b); };",No,No,O(n log n),3
"function plusOne(digits) { for (let i = digits.length - 1; i >= 0; i--) { if (digits[i] < 9) { digits[i]++; return digits; } digits[i] = 0; } return [1, ...digits]; }",No,No,O(n),2
"const twoSum = (nums, target) => { const map = new Map(); for (let i = 0; i < nums.length; i++) { const complement = target - nums[i]; if (map.has(complement)) return [map.get(complement), i]; map.set(nums[i], i); } return []; };",No,No,O(n),2
"function merge(nums1, m, nums2, n) { let i = m - 1, j = n - 1, k = m + n - 1; while (i >= 0 && j >= 0) { nums1[k--] = nums1[i] > nums2[j] ? nums1[i--] : nums2[j--]; } while (j >= 0) { nums1[k--] = nums2[j--]; } }",No,No,O(m + n),2
"const validAnagram = (s, t) => { if (s.length !== t.length) return false; const count = {}; for (const char of s) { count[char] = (count[char] || 0) + 1; } for (const char of t) { if (!count[char]) return false; count[char]--; } return true; };",No,No,O(n),2
"const longestSubstring = (s) => { const set = new Set(); let left = 0, maxLength = 0; for (let right = 0; right < s.length; right++) { while (set.has(s[right])) set.delete(s[left++]); set.add(s[right]); maxLength = Math.max(maxLength, right - left + 1); } return maxLength; };",No,No,O(n),2
"const numSquares = (n) => { const dp = Array(n + 1).fill(Infinity); dp[0] = 0; for (let i = 1; i <= n; i++) { for (let j = 1; j * j <= i; j++) { dp[i] = Math.min(dp[i], dp[i - j * j] + 1); } } return dp[n]; };",No,No,O(n * sqrt(n)),3
"const largestRectangleArea = (heights) => { const stack = []; heights.push(0); let maxArea = 0; for (let i = 0; i < heights.length; i++) { while (stack.length && heights[i] < heights[stack[stack.length - 1]]) { const h = heights[stack.pop()]; const width = stack.length ? i - stack[stack.length - 1] - 1 : i; maxArea = Math.max(maxArea, h * width); } stack.push(i); } return maxArea; };",No,No,O(n),3
"function numIslands(grid) { if (!grid.length) return 0; let count = 0; const dfs = (i, j) => { if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] === '0') return; grid[i][j] = '0'; dfs(i + 1, j); dfs(i - 1, j); dfs(i, j + 1); dfs(i, j - 1); }; for (let i = 0; i < grid.length; i++) { for (let j = 0; j < grid[0].length; j++) { if (grid[i][j] === '1') { count++; dfs(i, j); } } } return count; };",No,No,O(m * n),3
"const findMedianSortedArrays = (nums1, nums2) => { const merged = [...nums1, ...nums2].sort((a, b) => a - b); const mid = merged.length / 2; return merged.length % 2 === 0 ? (merged[mid - 1] + merged[mid]) / 2 : merged[Math.floor(mid)]; };",No,No,O((m+n) log(m+n)),3
"const generate = (numRows) => { const result = []; for (let i = 0; i < numRows; i++) { const row = Array(i + 1).fill(1); for (let j = 1; j < i; j++) { row[j] = result[i - 1][j - 1] + result[i - 1][j]; } result.push(row); } return result; };",No,No,O(numRows^2),3
"const isHappy = (n) => { const seen = new Set(); while (n !== 1 && !seen.has(n)) { seen.add(n); n = n.toString().split('').reduce((acc, digit) => acc + Math.pow(digit, 2), 0); } return n === 1; };",No,No,O(log n),2
"function countVowelStrings(n) { return Math.pow(5, n); }",No,No,O(1),1
"const minPathSum = (grid) => { const m = grid.length, n = grid[0].length; for (let i = 1; i < m; i++) grid[i][0] += grid[i - 1][0]; for (let j = 1; j < n; j++) grid[0][j] += grid[0][j - 1]; for (let i = 1; i < m; i++) { for (let j = 1; j < n; j++) { grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]); } } return grid[m - 1][n - 1]; };",No,No,O(m * n),3
"const searchMatrix = (matrix, target) => { if (!matrix.length) return false; let row = 0, col = matrix[0].length - 1; while (row < matrix.length && col >= 0) { if (matrix[row][col] === target) return true; if (matrix[row][col] > target) col--; else row++; } return false; };",No,No,O(m + n),2
"const uniquePaths = (m, n) => { const dp = Array(m).fill(null).map(() => Array(n).fill(1)); for (let i = 1; i < m; i++) { for (let j = 1; j < n; j++) { dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } return dp[m - 1][n - 1]; };",No,No,O(m * n),3
"const findKthLargest = (nums, k) => { const sorted = nums.sort((a, b) => b - a); return sorted[k - 1]; };",No,No,O(n log n),2
"function getRow(rowIndex) { const row = [1]; for (let i = 1; i <= rowIndex; i++) { for (let j = i - 1; j > 0; j--) { row[j] = row[j - 1] + row[j]; } row.push(1); } return row; }",No,No,O(rowIndex^2),3
"function countNegatives(grid) { let count = 0; for (const row of grid) { for (const num of row) { if (num < 0) count++; } } return count; }",No,No,O(m * n),2
"const longestPalindrome = (s) => { if (s.length < 1) return ''; let start = 0, end = 0; for (let i = 0; i < s.length; i++) { const len1 = expandAroundCenter(s, i, i); const len2 = expandAroundCenter(s, i, i + 1); const len = Math.max(len1, len2); if (len > end - start) { start = i - Math.floor((len - 1) / 2); end = i + Math.floor(len / 2); } } return s.substring(start, end + 1); }; const expandAroundCenter = (s, left, right) => { while (left >= 0 && right < s.length && s[left] === s[right]) { left--; right++; } return right - left - 1; };",No,No,O(n^2),3
"const backspaceCompare = (s, t) => { const buildString = (str) => { const stack = []; for (const char of str) { if (char !== '#') stack.push(char); else stack.pop(); } return stack.join(''); }; return buildString(s) === buildString(t); };",No,No,O(n),2
"const maxProfit = (prices) => { let minPrice = Infinity, maxProfit = 0; for (const price of prices) { minPrice = Math.min(minPrice, price); maxProfit = Math.max(maxProfit, price - minPrice); } return maxProfit; };",No,No,O(n),2
"function lowestCommonAncestor(root, p, q) { if (!root || root === p || root === q) return root; const left = lowestCommonAncestor(root.left, p, q); const right = lowestCommonAncestor(root.right, p, q); return left && right ? root : left || right; }",No,No,O(n),3
"const diameterOfBinaryTree = (root) => { let maxDiameter = 0; const dfs = (node) => { if (!node) return 0; const left = dfs(node.left); const right = dfs(node.right); maxDiameter = Math.max(maxDiameter, left + right); return 1 + Math.max(left, right); }; dfs(root); return maxDiameter; };",No,No,O(n),3
"const maxDepth = (root) => { if (!root) return 0; return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1; };",No,No,O(n),2
"function mergeKLists(lists) { const minHeap = new MinHeap(); for (const list of lists) { if (list) minHeap.insert(list); } const dummy = new ListNode(0); let current = dummy; while (minHeap.size()) { const node = minHeap.extractMin(); current.next = node; current = current.next; if (node.next) minHeap.insert(node.next); } return dummy.next; }",No,No,O(n log k),3
"const binaryTreePaths = (root) => { const paths = []; const dfs = (node, path) => { if (!node) return; path += node.val; if (!node.left && !node.right) { paths.push(path); return; } path += '->'; dfs(node.left, path); dfs(node.right, path); }; dfs(root, ''); return paths; };",No,No,O(n),3
"const preorderTraversal = (root) => { const result = []; const dfs = (node) => { if (!node) return; result.push(node.val); dfs(node.left); dfs(node.right); }; dfs(root); return result; };",No,No,O(n),2
"const inorderTraversal = (root) => { const result = []; const dfs = (node) => { if (!node) return; dfs(node.left); result.push(node.val); dfs(node.right); }; dfs(root); return result; };",No,No,O(n),2
"const postorderTraversal = (root) => { const result = []; const dfs = (node) => { if (!node) return; dfs(node.left); dfs(node.right); result.push(node.val); }; dfs(root); return result; };",No,No,O(n),2
"const isSymmetric = (root) => { const checkSymmetry = (left, right) => { if (!left && !right) return true; if (!left || !right) return false; return left.val === right.val && checkSymmetry(left.left, right.right) && checkSymmetry(left.right, right.left); }; return checkSymmetry(root, root); };",No,No,O(n),3
"const isSubtree = (root, subRoot) => { if (!root) return false; if (isSameTree(root, subRoot)) return true; return isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot); }; const isSameTree = (p, q) => { if (!p && !q) return true; if (!p || !q) return false; return p.val === q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right); };",No,No,O(m * n),3
"const sumNumbers = (root) => { let totalSum = 0; const dfs = (node, currentSum) => { if (!node) return; currentSum = currentSum * 10 + node.val; if (!node.left && !node.right) totalSum += currentSum; dfs(node.left, currentSum); dfs(node.right, currentSum); }; dfs(root, 0); return totalSum; };",No,No,O(n),3
"const fib = (n) => { if (n <= 1) return n; return fib(n - 1) + fib(n - 2); };",No,No,O(2^n),3
"const isValidBST = (root, min = null, max = null) => { if (!root) return true; if ((min !== null && root.val <= min) || (max !== null && root.val >= max)) return false; return isValidBST(root.left, min, root.val) && isValidBST(root.right, root.val, max); };",No,No,O(n),3
"const spiralOrder = (matrix) => { const result = []; while (matrix.length) { result.push(...matrix.shift()); if (matrix.length) { for (const row of matrix) result.push(row.pop()); } if (matrix.length) result.push(...(matrix.pop().reverse())); if (matrix.length) { for (const row of matrix.reverse()) result.push(row.shift()); } } return result; };",No,No,O(m * n),3
"const maxArea = (height) => { let maxArea = 0, left = 0, right = height.length - 1; while (left < right) { const area = Math.min(height[left], height[right]) * (right - left); maxArea = Math.max(maxArea, area); if (height[left] < height[right]) left++; else right--; } return maxArea; };",No,No,O(n),2
"const combinationSum = (candidates, target) => { const result = []; const backtrack = (start, path, sum) => { if (sum === target) result.push(path.slice()); if (sum >= target) return; for (let i = start; i < candidates.length; i++) { path.push(candidates[i]); backtrack(i, path, sum + candidates[i]); path.pop(); } }; backtrack(0, [], 0); return result; };",No,No,O(2^(m+n)),3
"const permute = (nums) => { const result = []; const backtrack = (path) => { if (path.length === nums.length) { result.push(path.slice()); return; } for (const num of nums) { if (path.includes(num)) continue; path.push(num); backtrack(path); path.pop(); } }; backtrack([]); return result; };",No,No,O(n!),3
"const groupAnagrams = (strs) => { const map = {}; for (const str of strs) { const key = str.split('').sort().join(''); if (!map[key]) map[key] = []; map[key].push(str); } return Object.values(map); };",No,No,O(n * k log k),3
"const combinationSum2 = (candidates, target) => { const result = []; candidates.sort((a, b) => a - b); const backtrack = (start, path, sum) => { if (sum === target) result.push(path.slice()); if (sum >= target) return; for (let i = start; i < candidates.length; i++) { if (i > start && candidates[i] === candidates[i - 1]) continue; path.push(candidates[i]); backtrack(i + 1, path, sum + candidates[i]); path.pop(); } }; backtrack(0, [], 0); return result; };",No,No,O(2^(m+n)),3
"const longestCommonPrefix = (strs) => { if (!strs.length) return ''; let prefix = strs[0]; for (let i = 1; i < strs.length; i++) { while (strs[i].indexOf(prefix) !== 0) { prefix = prefix.slice(0, -1); } } return prefix; };",No,No,O(n * m),2
"const restoreIPAddresses = (s) => { const result = []; const backtrack = (start, path) => { if (path.length === 4 && start === s.length) { result.push(path.join('.')); return; } if (path.length >= 4) return; for (let len = 1; len <= 3; len++) { const part = s.substring(start, start + len); if (part.length > 1 && part[0] === '0' || +part > 255) return; path.push(part); backtrack(start + len, path); path.pop(); } }; backtrack(0, []); return result; };",No,No,O(1),3
"const nextPermutation = (nums) => { let i = nums.length - 2; while (i >= 0 && nums[i] >= nums[i + 1]) i--; if (i >= 0) { let j = nums.length - 1; while (j >= 0 && nums[j] <= nums[i]) j--; [nums[i], nums[j]] = [nums[j], nums[i]]; } nums.reverse(i + 1); };",No,No,O(n),2
"const canJump = (nums) => { let reachable = 0; for (let i = 0; i < nums.length; i++) { if (i > reachable) return false; reachable = Math.max(reachable, i + nums[i]); } return true; };",No,No,O(n),2
"const trap = (height) => { const leftMax = [], rightMax = []; let water = 0; for (let i = 0; i < height.length; i++) { leftMax[i] = i === 0 ? height[i] : Math.max(leftMax[i - 1], height[i]); } for (let i = height.length - 1; i >= 0; i--) { rightMax[i] = i === height.length - 1 ? height[i] : Math.max(rightMax[i + 1], height[i]); } for (let i = 0; i < height.length; i++) { water += Math.min(leftMax[i], rightMax[i]) - height[i]; } return water; };",No,No,O(n),3
"const permuteUnique = (nums) => { const result = []; const backtrack = (path, used) => { if (path.length === nums.length) { result.push(path.slice()); return; } for (let i = 0; i < nums.length; i++) { if (used[i] || (i > 0 && nums[i] === nums[i - 1] && !used[i - 1])) continue; used[i] = true; path.push(nums[i]); backtrack(path, used); path.pop(); used[i] = false; } }; nums.sort((a, b) => a - b); backtrack([], Array(nums.length).fill(false)); return result; };",No,No,O(n!),3
"const search = (nums, target) => { let left = 0, right = nums.length - 1; while (left <= right) { const mid = Math.floor((left + right) / 2); if (nums[mid] === target) return mid; if (nums[left] <= nums[mid]) { if (nums[left] <= target && target < nums[mid]) right = mid - 1; else left = mid + 1; } else { if (nums[mid] < target && target <= nums[right]) left = mid + 1; else right = mid - 1; } } return -1; };",No,No,O(log n),2
"const sortedArrayToBST = (nums) => { if (!nums.length) return null; const mid = Math.floor(nums.length / 2); const node = new TreeNode(nums[mid]); node.left = sortedArrayToBST(nums.slice(0, mid)); node.right = sortedArrayToBST(nums.slice(mid + 1)); return node; };",No,No,O(n),3
"const majorityElement = (nums) => { const count = {}; for (const num of nums) { count[num] = (count[num] || 0) + 1; if (count[num] > nums.length / 2) return num; } };",No,No,O(n),2
"const deleteDuplicates = (head) => { if (!head) return head; let current = head; while (current.next) { if (current.val === current.next.val) current.next = current.next.next; else current = current.next; } return head; };",No,No,O(n),2
"const rotate = (nums, k) => { k %= nums.length; const reverse = (arr, start, end) => { while (start < end) { [arr[start], arr[end]] = [arr[end], arr[start]]; start++; end--; } }; reverse(nums, 0, nums.length - 1); reverse(nums, 0, k - 1); reverse(nums, k, nums.length - 1); };",No,No,O(n),2
"const lengthOfLastWord = (s) => { const words = s.trim().split(' '); return words.length ? words[words.length - 1].length : 0; };",No,No,O(n),1
"const strStr = (haystack, needle) => { if (!needle) return 0; return haystack.indexOf(needle); };",No,No,O(n),1
"const reverseWords = (s) => { return s.split(' ').reverse().join(' '); };",No,No,O(n),1
"const maxProfitSingleTransaction = (prices) => { let minPrice = Infinity, maxProfit = 0; for (const price of prices) { minPrice = Math.min(minPrice, price); maxProfit = Math.max(maxProfit, price - minPrice); } return maxProfit; };",No,No,O(n),2
"const maxProfitMultipleTransactions = (prices) => { let maxProfit = 0; for (let i = 1; i < prices.length; i++) { if (prices[i] > prices[i - 1]) maxProfit += prices[i] - prices[i - 1]; } return maxProfit; };",No,No,O(n),2
"const threeSum = (nums) => { const result = []; nums.sort((a, b) => a - b); for (let i = 0; i < nums.length; i++) { if (i > 0 && nums[i] === nums[i - 1]) continue; let left = i + 1, right = nums.length - 1; while (left < right) { const sum = nums[i] + nums[left] + nums[right]; if (sum < 0) left++; else if (sum > 0) right--; else { result.push([nums[i], nums[left], nums[right]]); while (left < right && nums[left] === nums[left + 1]) left++; while (left < right && nums[right] === nums[right - 1]) right--; left++; right--; } } } return result; };",No,No,O(n^2),3
"const twoSum = (nums, target) => { const map = new Map(); for (let i = 0; i < nums.length; i++) { const complement = target - nums[i]; if (map.has(complement)) return [map.get(complement), i]; map.set(nums[i], i); } return []; };",No,No,O(n),2
"const findMedianSortedArrays = (nums1, nums2) => { const merged = [...nums1, ...nums2].sort((a, b) => a - b); const mid = Math.floor(merged.length / 2); return merged.length % 2 === 0 ? (merged[mid - 1] + merged[mid]) / 2 : merged[mid]; };",No,No,O((n+m) log(n+m)),2
"const lengthOfLongestSubstring = (s) => { const set = new Set(); let left = 0, maxLength = 0; for (let right = 0; right < s.length; right++) { while (set.has(s[right])) { set.delete(s[left]); left++; } set.add(s[right]); maxLength = Math.max(maxLength, right - left + 1); } return maxLength; };",No,No,O(n),2
"const longestPalindrome = (s) => { let maxLength = 0, start = 0; for (let i = 0; i < s.length; i++) { let len1 = expandAroundCenter(s, i, i); let len2 = expandAroundCenter(s, i, i + 1); let len = Math.max(len1, len2); if (len > maxLength) { maxLength = len; start = i - Math.floor((len - 1) / 2); } } return s.substring(start, start + maxLength); }; const expandAroundCenter = (s, left, right) => { while (left >= 0 && right < s.length && s[left] === s[right]) { left--; right++; } return right - left - 1; };",No,No,O(n^2),3
"const coinChange = (coins, amount) => { const dp = Array(amount + 1).fill(Infinity); dp[0] = 0; for (const coin of coins) { for (let i = coin; i <= amount; i++) { dp[i] = Math.min(dp[i], dp[i - coin] + 1); } } return dp[amount] === Infinity ? -1 : dp[amount]; };",No,No,O(n * amount),3
"const removeDuplicatesSortedArray = (nums) => { if (nums.length === 0) return 0; let j = 1; for (let i = 1; i < nums.length; i++) { if (nums[i] !== nums[i - 1]) { nums[j] = nums[i]; j++; } } return j; };",No,No,O(n),2
"const mergeSortedArray = (nums1, m, nums2, n) => { let i = m - 1, j = n - 1, k = m + n - 1; while (j >= 0) { if (i >= 0 && nums1[i] > nums2[j]) { nums1[k--] = nums1[i--]; } else { nums1[k--] = nums2[j--]; } } };",No,No,O(n + m),2
"const plusOne = (digits) => { for (let i = digits.length - 1; i >= 0; i--) { if (digits[i] < 9) { digits[i]++; return digits; } digits[i] = 0; } return [1, ...digits]; };",No,No,O(n),1
"const climbStairs = (n) => { if (n <= 2) return n; let first = 1, second = 2; for (let i = 3; i <= n; i++) { [first, second] = [second, first + second]; } return second; };",No,No,O(n),2
"const maxSubArray = (nums) => { let maxSum = nums[0], currentSum = nums[0]; for (let i = 1; i < nums.length; i++) { currentSum = Math.max(nums[i], currentSum + nums[i]); maxSum = Math.max(maxSum, currentSum); } return maxSum; };",No,No,O(n),2
"const isValidPalindrome = (s) => { const cleaned = s.replace(/[^A-Za-z0-9]/g, '').toLowerCase(); return cleaned === cleaned.split('').reverse().join(''); };",No,No,O(n),2
"const binarySearch = (nums, target) => { let left = 0, right = nums.length - 1; while (left <= right) { const mid = Math.floor((left + right) / 2); if (nums[mid] === target) return mid; else if (nums[mid] < target) left = mid + 1; else right = mid - 1; } return -1; };",No,No,O(log n),2
"const groupAnagrams = (strs) => { const map = new Map(); for (const str of strs) { const sorted = str.split('').sort().join(''); if (!map.has(sorted)) map.set(sorted, []); map.get(sorted).push(str); } return Array.from(map.values()); };",No,No,O(nk log k),3
"const validParentheses = (s) => { const stack = []; const mapping = { ')': '(', '}': '{', ']': '[' }; for (const char of s) { if (mapping[char]) { const topElement = stack.length === 0 ? '#' : stack.pop(); if (mapping[char] !== topElement) return false; } else stack.push(char); } return stack.length === 0; };",No,No,O(n),2
"const rotateArray = (nums, k) => { k %= nums.length; reverse(nums, 0, nums.length - 1); reverse(nums, 0, k - 1); reverse(nums, k, nums.length - 1); }; const reverse = (arr, start, end) => { while (start < end) { [arr[start], arr[end]] = [arr[end], arr[start]]; start++; end--; } };",No,No,O(n),2
"const generateParenthesis = (n) => { const result = []; const backtrack = (current, open, close) => { if (current.length === 2 * n) result.push(current); if (open < n) backtrack(current + '(', open + 1, close); if (close < open) backtrack(current + ')', open, close + 1); }; backtrack('', 0, 0); return result; };",No,No,O(4^n/sqrt(n)),3
"const minPathSum = (grid) => { const m = grid.length, n = grid[0].length; for (let i = 1; i < m; i++) grid[i][0] += grid[i - 1][0]; for (let j = 1; j < n; j++) grid[0][j] += grid[0][j - 1]; for (let i = 1; i < m; i++) { for (let j = 1; j < n; j++) { grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]); } } return grid[m - 1][n - 1]; };",No,No,O(m * n),3
"const uniquePaths = (m, n) => { const dp = Array(m).fill(1).map(() => Array(n).fill(1)); for (let i = 1; i < m; i++) { for (let j = 1; j < n; j++) { dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } return dp[m - 1][n - 1]; };",No,No,O(m * n),3
"const searchMatrix = (matrix, target) => { if (!matrix.length) return false; let row = 0, col = matrix[0].length - 1; while (row < matrix.length && col >= 0) { if (matrix[row][col] === target) return true; if (matrix[row][col] < target) row++; else col--; } return false; };",No,No,O(m + n),2
"const removeDuplicates = (nums) => { let i = 0; for (let j = 1; j < nums.length; j++) { if (nums[i] !== nums[j]) { i++; nums[i] = nums[j]; } } return i + 1; };",No,No,O(n),2
"const climbStairs = (n) => { if (n <= 2) return n; let dp = new Array(n + 1); dp[1] = 1; dp[2] = 2; for (let i = 3; i <= n; i++) { dp[i] = dp[i - 1] + dp[i - 2]; } return dp[n]; };",No,No,O(n),2
"const longestCommonPrefix = (strs) => { if (!strs.length) return ''; let prefix = strs[0]; for (let i = 1; i < strs.length; i++) { while (strs[i].indexOf(prefix) !== 0) { prefix = prefix.substring(0, prefix.length - 1); } } return prefix; };",No,No,O(n * m),2
"const mergeSortedArrays = (arr1, arr2) => { const merged = []; let i = 0, j = 0; while (i < arr1.length && j < arr2.length) { if (arr1[i] < arr2[j]) { merged.push(arr1[i++]); } else { merged.push(arr2[j++]); } } return [...merged, ...arr1.slice(i), ...arr2.slice(j)]; };",No,No,O(n + m),2
"const powerSet = (nums) => { const result = []; const backtrack = (start, path) => { result.push([...path]); for (let i = start; i < nums.length; i++) { path.push(nums[i]); backtrack(i + 1, path); path.pop(); } }; backtrack(0, []); return result; };",No,No,O(2^n),3
"const coinChange = (coins, amount) => { const dp = new Array(amount + 1).fill(Infinity); dp[0] = 0; for (const coin of coins) { for (let i = coin; i <= amount; i++) { dp[i] = Math.min(dp[i], dp[i - coin] + 1); } } return dp[amount] === Infinity ? -1 : dp[amount]; };",No,No,O(n * amount),3
"const isAnagram = (s, t) => { if (s.length !== t.length) return false; const count = new Array(26).fill(0); for (let i = 0; i < s.length; i++) { count[s.charCodeAt(i) - 'a'.charCodeAt(0)]++; count[t.charCodeAt(i) - 'a'.charCodeAt(0)]--; } return count.every(c => c === 0); };",No,No,O(n),2
"const findMedianSortedArrays = (nums1, nums2) => { const merged = [...nums1, ...nums2].sort((a, b) => a - b); const mid = Math.floor(merged.length / 2); return merged.length % 2 === 0 ? (merged[mid - 1] + merged[mid]) / 2 : merged[mid]; };",No,No,O((n + m) log(n + m)),3
"const threeSum = (nums) => { const result = []; nums.sort((a, b) => a - b); for (let i = 0; i < nums.length - 2; i++) { if (i > 0 && nums[i] === nums[i - 1]) continue; let left = i + 1, right = nums.length - 1; while (left < right) { const sum = nums[i] + nums[left] + nums[right]; if (sum < 0) left++; else if (sum > 0) right--; else { result.push([nums[i], nums[left], nums[right]]); while (left < right && nums[left] === nums[left + 1]) left++; while (left < right && nums[right] === nums[right - 1]) right--; left++; right--; } } } return result; };",No,No,O(n^2),3
"const rotateArray = (nums, k) => { k %= nums.length; const reverse = (arr, start, end) => { while (start < end) { [arr[start], arr[end]] = [arr[end], arr[start]]; start++; end--; } }; reverse(nums, 0, nums.length - 1); reverse(nums, 0, k - 1); reverse(nums, k, nums.length - 1); };",No,No,O(n),3
"const reverseWords = (s) => { return s.split(' ').reverse().join(' '); };",No,No,O(n),2
"const maxSubArray = (nums) => { let maxSum = nums[0], currentSum = nums[0]; for (let i = 1; i < nums.length; i++) { currentSum = Math.max(nums[i], currentSum + nums[i]); maxSum = Math.max(maxSum, currentSum); } return maxSum; };",No,No,O(n),2
"const productExceptSelf = (nums) => { const output = new Array(nums.length); output[0] = 1; for (let i = 1; i < nums.length; i++) { output[i] = output[i - 1] * nums[i - 1]; } let right = 1; for (let i = nums.length - 1; i >= 0; i--) { output[i] *= right; right *= nums[i]; } return output; };",No,No,O(n),3
"const groupAnagrams = (strs) => { const map = new Map(); for (const str of strs) { const key = str.split('').sort().join(''); if (!map.has(key)) map.set(key, []); map.get(key).push(str); } return Array.from(map.values()); };",No,No,O(n * k log k),3
"const validParentheses = (s) => { const stack = []; const map = { ')': '(', '}': '{', ']': '[' }; for (const char of s) { if (map[char]) { if (stack.pop() !== map[char]) return false; } else stack.push(char); } return stack.length === 0; };",No,No,O(n),2
"const twoSum = (nums, target) => { const map = new Map(); for (let i = 0; i < nums.length; i++) { const complement = target - nums[i]; if (map.has(complement)) return [map.get(complement), i]; map.set(nums[i], i); } return []; };",No,No,O(n),2
"const longestSubstring = (s) => { const map = new Map(); let left = 0, maxLength = 0; for (let right = 0; right < s.length; right++) { if (map.has(s[right])) left = Math.max(map.get(s[right]) + 1, left); map.set(s[right], right); maxLength = Math.max(maxLength, right - left + 1); } return maxLength; };",No,No,O(n),3
"const searchInsert = (nums, target) => { let left = 0, right = nums.length - 1; while (left <= right) { const mid = Math.floor((left + right) / 2); if (nums[mid] === target) return mid; if (nums[mid] < target) left = mid + 1; else right = mid - 1; } return left; };",No,No,O(log n),2
"const isPalindrome = (s) => { const cleaned = s.replace(/[^A-Za-z0-9]/g, '').toLowerCase(); return cleaned === cleaned.split('').reverse().join(''); };",No,No,O(n),2
"const climbStairs = (n) => { if (n <= 1) return 1; const dp = new Array(n + 1).fill(0); dp[0] = 1; dp[1] = 1; for (let i = 2; i <= n; i++) { dp[i] = dp[i - 1] + dp[i - 2]; } return dp[n]; };",No,No,O(n),3
"const mergeTwoLists = (l1, l2) => { const dummy = new ListNode(0); let tail = dummy; while (l1 && l2) { if (l1.val < l2.val) { tail.next = l1; l1 = l1.next; } else { tail.next = l2; l2 = l2.next; } tail = tail.next; } tail.next = l1 || l2; return dummy.next; };",No,No,O(n),3
"const minimumDepth = (root) => { if (!root) return 0; if (!root.left && !root.right) return 1; if (!root.left) return minimumDepth(root.right) + 1; if (!root.right) return minimumDepth(root.left) + 1; return Math.min(minimumDepth(root.left), minimumDepth(root.right)) + 1; };",No,No,O(n),3
"const twoSumSorted = (numbers, target) => { let left = 0, right = numbers.length - 1; while (left < right) { const sum = numbers[left] + numbers[right]; if (sum === target) return [left + 1, right + 1]; if (sum < target) left++; else right--; } return []; };",No,No,O(n),2
"const letterCombinations = (digits) => { if (!digits) return []; const map = { '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz' }; const result = []; const backtrack = (index, path) => { if (index === digits.length) result.push(path); else { for (const char of map[digits[index]]) { backtrack(index + 1, path + char); } } }; backtrack(0, ''); return result; };",No,No,O(3^n),3
"const uniquePaths = (m, n) => { const dp = Array.from({ length: m }, () => Array(n).fill(1)); for (let i = 1; i < m; i++) { for (let j = 1; j < n; j++) { dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } return dp[m - 1][n - 1]; };",No,No,O(m * n),3
"const lengthOfLongestSubstring = (s) => { const map = new Map(); let left = 0, maxLength = 0; for (let right = 0; right < s.length; right++) { if (map.has(s[right])) left = Math.max(map.get(s[right]) + 1, left); map.set(s[right], right); maxLength = Math.max(maxLength, right - left + 1); } return maxLength; };",No,No,O(n),2
"const longestCommonPrefix = (strs) => { if (!strs.length) return ''; let prefix = strs[0]; for (let i = 1; i < strs.length; i++) { while (strs[i].indexOf(prefix) !== 0) { prefix = prefix.slice(0, -1); } } return prefix; };",No,No,O(n * m),3
"const singleNumber = (nums) => { return nums.reduce((acc, num) => acc ^ num, 0); };",No,No,O(n),2
"const validSudoku = (board) => { const rows = Array(9).fill().map(() => new Set()); const cols = Array(9).fill().map(() => new Set()); const boxes = Array(9).fill().map(() => new Set()); for (let r = 0; r < 9; r++) { for (let c = 0; c < 9; c++) { const num = board[r][c]; if (num !== '.') { const boxIndex = Math.floor(r / 3) * 3 + Math.floor(c / 3); if (rows[r].has(num) || cols[c].has(num) || boxes[boxIndex].has(num)) return false; rows[r].add(num); cols[c].add(num); boxes[boxIndex].add(num); } } } return true; };",No,No,O(1),3
"const numberOfIslands = (grid) => { if (!grid.length) return 0; let count = 0; const dfs = (r, c) => { if (r < 0 || r >= grid.length || c < 0 || c >= grid[0].length || grid[r][c] === '0') return; grid[r][c] = '0'; dfs(r + 1, c); dfs(r - 1, c); dfs(r, c + 1); dfs(r, c - 1); }; for (let r = 0; r < grid.length; r++) { for (let c = 0; c < grid[0].length; c++) { if (grid[r][c] === '1') { count++; dfs(r, c); } } } return count; };",No,No,O(m * n),3
"const minimumWindowSubstring = (s, t) => { const map = {}; for (const char of t) map[char] = (map[char] || 0) + 1; let left = 0, right = 0, required = Object.keys(map).length, formed = 0; const windowCounts = {}; let ans = [Infinity, -1, -1]; while (right < s.length) { const char = s[right]; windowCounts[char] = (windowCounts[char] || 0) + 1; if (map[char] && windowCounts[char] === map[char]) formed++; while (left <= right && formed === required) { const char = s[left]; if (right - left + 1 < ans[0]) ans = [right - left + 1, left, right]; windowCounts[char]--; if (map[char] && windowCounts[char] < map[char]) formed--; left++; } right++; } return ans[0] === Infinity ? '' : s.slice(ans[1], ans[2] + 1); };",No,No,O(n),3
"const removeDuplicates = (nums) => { if (!nums.length) return 0; let uniqueIndex = 1; for (let i = 1; i < nums.length; i++) { if (nums[i] !== nums[i - 1]) { nums[uniqueIndex] = nums[i]; uniqueIndex++; } } return uniqueIndex; };",No,No,O(n),2
"const generateParenthesis = (n) => { const result = []; const backtrack = (current, open, close) => { if (current.length === 2 * n) result.push(current); if (open < n) backtrack(current + '(', open + 1, close); if (close < open) backtrack(current + ')', open, close + 1); }; backtrack('', 0, 0); return result; };",No,No,O(4^n / sqrt(n)),3
"const threeSum = (nums) => { nums.sort((a, b) => a - b); const result = []; for (let i = 0; i < nums.length - 2; i++) { if (i > 0 && nums[i] === nums[i - 1]) continue; let left = i + 1, right = nums.length - 1; while (left < right) { const sum = nums[i] + nums[left] + nums[right]; if (sum === 0) { result.push([nums[i], nums[left], nums[right]]); while (left < right && nums[left] === nums[left + 1]) left++; while (left < right && nums[right] === nums[right - 1]) right--; left++; right--; } else if (sum < 0) left++; else right--; } } return result; };",No,No,O(n^2),3
"const isValid = (s) => { const stack = []; const map = { '(': ')', '{': '}', '[': ']' }; for (const char of s) { if (map[char]) stack.push(char); else if (stack.length === 0 || map[stack.pop()] !== char) return false; } return stack.length === 0; };",No,No,O(n),2
"const kthLargestElement = (nums, k) => { const quickSelect = (left, right) => { if (left === right) return nums[left]; const pivotIndex = Math.floor(Math.random() * (right - left + 1)) + left; const pivotValue = nums[pivotIndex]; [nums[pivotIndex], nums[right]] = [nums[right], nums[pivotIndex]]; let storeIndex = left; for (let i = left; i < right; i++) { if (nums[i] > pivotValue) { [nums[storeIndex], nums[i]] = [nums[i], nums[storeIndex]]; storeIndex++; } } [nums[right], nums[storeIndex]] = [nums[storeIndex], nums[right]]; if (k === storeIndex + 1) return nums[storeIndex]; else if (k < storeIndex + 1) return quickSelect(left, storeIndex - 1); else return quickSelect(storeIndex + 1, right); }; return quickSelect(0, nums.length - 1); };",No,No,O(n),3
"const searchMatrix = (matrix, target) => { if (!matrix.length || !matrix[0].length) return false; let left = 0, right = matrix.length - 1; while (left <= right) { const mid = Math.floor((left + right) / 2); if (matrix[mid][0] > target) right = mid - 1; else if (matrix[mid][matrix[mid].length - 1] < target) left = mid + 1; else return matrix[mid].includes(target); } return false; };",No,No,O(m log n),3
"const validAnagram = (s, t) => { if (s.length !== t.length) return false; const count = {}; for (const char of s) count[char] = (count[char] || 0) + 1; for (const char of t) { if (!count[char]) return false; count[char]--; } return true; };",No,No,O(n),2
"const reverseLinkedList = (head) => { let prev = null, curr = head; while (curr) { const nextTemp = curr.next; curr.next = prev; prev = curr; curr = nextTemp; } return prev; };",No,No,O(n),2
"const middleNode = (head) => { let slow = head, fast = head; while (fast && fast.next) { slow = slow.next; fast = fast.next.next; } return slow; };",No,No,O(n),2
"const maxDepth = (root) => { if (!root) return 0; return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1; };",No,No,O(n),2
"const diameterOfBinaryTree = (root) => { let diameter = 0; const depth = (node) => { if (!node) return 0; const left = depth(node.left); const right = depth(node.right); diameter = Math.max(diameter, left + right); return Math.max(left, right) + 1; }; depth(root); return diameter; };",No,No,O(n),3
"const factorial = (n) => { return n === 0 ? 1 : n * factorial(n - 1); };",No,No,O(n),2
"const findMax = (nums) => { return Math.max(...nums); };",No,No,O(n),1
"const findMin = (nums) => { return Math.min(...nums); };",No,No,O(n),1
"const sumArray = (arr) => { return arr.reduce((acc, curr) => acc + curr, 0); };",No,No,O(n),1
"const filterEvenNumbers = (arr) => { return arr.filter(num => num % 2 === 0); };",No,No,O(n),1
"const capitalizeFirstLetter = (str) => { return str.charAt(0).toUpperCase() + str.slice(1); };",No,No,O(n),2
"const isEven = (num) => { return num % 2 === 0; };",No,No,O(1),1
"const isOdd = (num) => { return num % 2 !== 0; };",No,No,O(1),1
"const concatenateArrays = (arr1, arr2) => { return [...arr1, ...arr2]; };",No,No,O(n),1
"const reverseString = (str) => { return str.split('').reverse().join(''); };",No,No,O(n),2
"const bubbleSort = (arr) => { for (let i = 0; i < arr.length; i++) { for (let j = 0; j < arr.length - i - 1; j++) { if (arr[j] > arr[j + 1]) { [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]; } } } return arr; };",No,No,O(n^2),3
"const selectionSort = (arr) => { for (let i = 0; i < arr.length; i++) { let minIndex = i; for (let j = i + 1; j < arr.length; j++) { if (arr[j] < arr[minIndex]) { minIndex = j; } } [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]]; } return arr; };",No,No,O(n^2),3
"const insertionSort = (arr) => { for (let i = 1; i < arr.length; i++) { let key = arr[i]; let j = i - 1; while (j >= 0 && arr[j] > key) { arr[j + 1] = arr[j]; j--; } arr[j + 1] = key; } return arr; };",No,No,O(n^2),3
"const quickSort = (arr) => { if (arr.length <= 1) return arr; const pivot = arr[arr.length - 1]; const left = arr.filter(x => x < pivot); const right = arr.filter(x => x > pivot); return [...quickSort(left), pivot, ...quickSort(right)]; };",No,No,O(n log n),3
"const mergeSort = (arr) => { if (arr.length <= 1) return arr; const mid = Math.floor(arr.length / 2); const left = mergeSort(arr.slice(0, mid)); const right = mergeSort(arr.slice(mid)); return merge(left, right); }; const merge = (left, right) => { const result = []; let i = 0, j = 0; while (i < left.length && j < right.length) { if (left[i] < right[j]) result.push(left[i++]); else result.push(right[j++]); } return [...result, ...left.slice(i), ...right.slice(j)]; };",No,No,O(n log n),4
"const countVowels = (str) => { return str.match(/[aeiou]/gi)?.length || 0; };",No,No,O(n),2
"const isAnagram = (s, t) => { return s.split('').sort().join('') === t.split('').sort().join(''); };",No,No,O(n log n),2
"const longestSubstring = (s) => { let maxLength = 0; let start = 0; const map = {}; for (let i = 0; i < s.length; i++) { if (map[s[i]] >= start) start = map[s[i]] + 1; map[s[i]] = i; maxLength = Math.max(maxLength, i - start + 1); } return maxLength; };",No,No,O(n),2
"const removeDuplicates = (nums) => { return [...new Set(nums)]; };",No,No,O(n),2
"const countCharacterFrequency = (str) => { const freq = {}; for (const char of str) { freq[char] = (freq[char] || 0) + 1; } return freq; };",No,No,O(n),2
"const capitalizeWords = (str) => { return str.split(' ').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' '); };",No,No,O(n),2
"const flattenArray = (arr) => { return arr.flat(); };",No,No,O(n),1
"const findIntersection = (arr1, arr2) => { return arr1.filter(value => arr2.includes(value)); };",No,No,O(n * m),3
"const isSubsequence = (s, t) => { let sIndex = 0; for (let tIndex = 0; tIndex < t.length; tIndex++) { if (s[sIndex] === t[tIndex]) sIndex++; } return sIndex === s.length; };",No,No,O(n),2
"const rotateArray = (arr, k) => { const n = arr.length; k = k % n; return [...arr.slice(n - k), ...arr.slice(0, n - k)]; };",No,No,O(n),2
"const uniqueElements = (arr) => { return [...new Set(arr)]; };",No,No,O(n),1
"const sumOfSquares = (arr) => { return arr.reduce((acc, curr) => acc + curr ** 2, 0); };",No,No,O(n),2
"const flattenDeep = (arr) => { return arr.flat(Infinity); };",No,No,O(n),1
"const groupAnagrams = (strs) => { const map = {}; for (const str of strs) { const key = str.split('').sort().join(''); if (!map[key]) map[key] = []; map[key].push(str); } return Object.values(map); };",No,No,O(n * k log k),3
"const chunkArray = (arr, size) => { return Array.from({ length: Math.ceil(arr.length / size) }, (_, i) => arr.slice(i * size, i * size + size)); };",No,No,O(n),2
"const findMissingNumber = (nums) => { const n = nums.length; const expectedSum = (n * (n + 1)) / 2; const actualSum = nums.reduce((acc, curr) => acc + curr, 0); return expectedSum - actualSum; };",No,No,O(n),3
"const getPermutations = (nums) => { const result = []; const backtrack = (path) => { if (path.length === nums.length) result.push([...path]); for (let i = 0; i < nums.length; i++) { if (path.includes(nums[i])) continue; path.push(nums[i]); backtrack(path); path.pop(); } }; backtrack([]); return result; };",No,No,O(n!),4
"const majorityElement = (nums) => { const count = {}; for (const num of nums) { count[num] = (count[num] || 0) + 1; if (count[num] > nums.length / 2) return num; } };",No,No,O(n),3
"const twoSum = (nums, target) => { const map = {}; for (let i = 0; i < nums.length; i++) { const complement = target - nums[i]; if (map[complement] !== undefined) return [map[complement], i]; map[nums[i]] = i; } };",No,No,O(n),3
"const lengthOfLongestSubstring = (s) => { let map = {}, left = 0, maxLength = 0; for (let right = 0; right < s.length; right++) { if (map[s[right]] >= left) left = map[s[right]] + 1; map[s[right]] = right; maxLength = Math.max(maxLength, right - left + 1); } return maxLength; };",No,No,O(n),2
"const validParentheses = (s) => { const stack = []; const map = { '(': ')', '{': '}', '[': ']' }; for (const char of s) { if (map[char]) stack.push(char); else if (stack.length === 0 || map[stack.pop()] !== char) return false; } return stack.length === 0; };",No,No,O(n),3
"const searchInsert = (nums, target) => { let left = 0, right = nums.length - 1; while (left <= right) { const mid = Math.floor((left + right) / 2); if (nums[mid] === target) return mid; if (nums[mid] < target) left = mid + 1; else right = mid - 1; } return left; };",No,No,O(log n),3
"const longestCommonPrefix = (strs) => { if (!strs.length) return ''; let prefix = strs[0]; for (let i = 1; i < strs.length; i++) { while (strs[i].indexOf(prefix) !== 0) { prefix = prefix.slice(0, -1); } } return prefix; };",No,No,O(n * m),3
"const addTwoNumbers = (l1, l2) => { let dummyHead = new ListNode(0), p = l1, q = l2, curr = dummyHead; let carry = 0; while (p !== null || q !== null) { let x = (p !== null) ? p.val : 0; let y = (q !== null) ? q.val : 0; let sum = carry + x + y; carry = Math.floor(sum / 10); curr.next = new ListNode(sum % 10); curr = curr.next; if (p !== null) p = p.next; if (q !== null) q = q.next; } if (carry > 0) curr.next = new ListNode(carry); return dummyHead.next; };",No,No,O(max(n, m)),4
"const longestPalindromicSubstring = (s) => { let start = 0, end = 0; const expandFromCenter = (left, right) => { while (left >= 0 && right < s.length && s[left] === s[right]) { left--; right++; } return right - left - 1; }; for (let i = 0; i < s.length; i++) { const len1 = expandFromCenter(i, i); const len2 = expandFromCenter(i, i + 1); const maxLen = Math.max(len1, len2); if (maxLen > end - start) { start = i - Math.floor((maxLen - 1) / 2); end = i + Math.floor(maxLen / 2); } } return s.slice(start, end + 1); };",No,No,O(n^2),3
"const isPalindrome = (s) => { const cleaned = s.replace(/[^a-zA-Z0-9]/g, '').toLowerCase(); return cleaned === cleaned.split('').reverse().join(''); };",No,No,O(n),2
"const numberToWords = (num) => { if (num === 0) return 'Zero'; const belowTwenty = ['','One','Two','Three','Four','Five','Six','Seven','Eight','Nine','Ten','Eleven','Twelve','Thirteen','Fourteen','Fifteen','Sixteen','Seventeen','Eighteen','Nineteen']; const belowHundred = ['','Ten','Twenty','Thirty','Forty','Fifty','Sixty','Seventy','Eighty','Ninety']; const helper = (n) => { if (n < 20) return belowTwenty[n]; if (n < 100) return belowHundred[Math.floor(n / 10)] + (n % 10 ? ' ' + belowTwenty[n % 10] : ''); if (n < 1000) return belowTwenty[Math.floor(n / 100)] + ' Hundred' + (n % 100 ? ' ' + helper(n % 100) : ''); return helper(Math.floor(n / 1000)) + ' Thousand' + (n % 1000 ? ' ' + helper(n % 1000) : ''); }; return helper(num); };",No,No,O(n),4
"const lengthOfLastWord = (s) => { return s.trim().split(' ').pop().length; };",No,No,O(n),2
"const reverseWords = (s) => { return s.split(' ').reverse().join(' '); };",No,No,O(n),2
"const majorityElement = (nums) => { const count = {}; const threshold = nums.length / 2; for (const num of nums) { count[num] = (count[num] || 0) + 1; if (count[num] > threshold) return num; } };",No,No,O(n),3
"const romanToInt = (s) => { const map = { 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000 }; let total = 0; for (let i = 0; i < s.length; i++) { const value = map[s[i]]; const nextValue = map[s[i + 1]]; total += value < nextValue ? -value : value; } return total; };",No,No,O(n),3
"const isPowerOfThree = (n) => { if (n < 1) return false; while (n % 3 === 0) n /= 3; return n === 1; };",No,No,O(log n),1
"const climbStairs = (n) => { if (n <= 1) return 1; let first = 1, second = 1; for (let i = 2; i <= n; i++) { const temp = first; first = first + second; second = temp; } return first; };",No,No,O(n),2
"const findDuplicate = (nums) => { const seen = new Set(); for (const num of nums) { if (seen.has(num)) return num; seen.add(num); } };",No,No,O(n),3
"const canConstruct = (ransomNote, magazine) => { const count = {}; for (const char of magazine) { count[char] = (count[char] || 0) + 1; } for (const char of ransomNote) { if (!count[char]) return false; count[char]--; } return true; };",No,No,O(n + m),3
"const minimumAbsoluteDifference = (arr) => { arr.sort((a, b) => a - b); let minDiff = Infinity; for (let i = 1; i < arr.length; i++) { minDiff = Math.min(minDiff, arr[i] - arr[i - 1]); } return minDiff; };",No,No,O(n log n),3
"const mergeSortedArrays = (arr1, arr2) => { const merged = []; let i = 0, j = 0; while (i < arr1.length && j < arr2.length) { if (arr1[i] < arr2[j]) merged.push(arr1[i++]); else merged.push(arr2[j++]); } return merged.concat(arr1.slice(i)).concat(arr2.slice(j)); };",No,No,O(n + m),2
"const rotateArray = (nums, k) => { k %= nums.length; const reversed = (arr) => arr.reverse(); reversed(nums); reversed(nums.slice(0, k)); reversed(nums.slice(k)); };",No,No,O(n),2
"const countVowels = (s) => { return (s.match(/[aeiou]/gi) || []).length; };",No,No,O(n),2
"const getIntersection = (nums1, nums2) => { return [...new Set(nums1)].filter(num => nums2.includes(num)); };",No,No,O(n * m),3
"const longestSubarray = (nums, limit) => { let left = 0, max = 0, min = 0; for (let right = 0; right < nums.length; right++) { max = Math.max(max, nums[right]); min = Math.min(min, nums[right]); while (max - min > limit) { left++; max = Math.max(...nums.slice(left, right + 1)); min = Math.min(...nums.slice(left, right + 1)); } } return right - left + 1; };",No,No,O(n^2),4
"const findKthLargest = (nums, k) => { return nums.sort((a, b) => b - a)[k - 1]; };",No,No,O(n log n),3
"const longestSubstringWithoutRepeating = (s) => { const map = {}; let left = 0, maxLength = 0; for (let right = 0; right < s.length; right++) { if (map[s[right]] !== undefined) { left = Math.max(map[s[right]] + 1, left); } map[s[right]] = right; maxLength = Math.max(maxLength, right - left + 1); } return maxLength; };",No,No,O(n),3
"const singleNumber = (nums) => { return nums.reduce((acc, curr) => acc ^ curr); };",No,No,O(n),2
"const canJump = (nums) => { let maxReach = 0; for (let i = 0; i < nums.length; i++) { if (i > maxReach) return false; maxReach = Math.max(maxReach, i + nums[i]); } return true; };",No,No,O(n),3
"const spiralOrder = (matrix) => { const result = []; while (matrix.length) { result.push(...matrix.shift()); if (matrix.length) { for (const row of matrix) result.push(row.pop()); } if (matrix.length) result.push(...(matrix.pop().reverse())); if (matrix.length) { for (const row of matrix.reverse()) result.push(row.shift()); } } return result; };",No,No,O(n),3
"const isAnagram = (s, t) => { const count = {}; for (const char of s) { count[char] = (count[char] || 0) + 1; } for (const char of t) { if (!count[char]) return false; count[char]--; } return Object.values(count).every(val => val === 0); };",No,No,O(n),3
"const convertToTitle = (n) => { let result = ''; while (n > 0) { n--; result = String.fromCharCode(n % 26 + 65) + result; n = Math.floor(n / 26); } return result; };",No,No,O(log n),2
"const romanToInt = (s) => { const map = { 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000 }; let total = 0; for (let i = 0; i < s.length; i++) { const value = map[s[i]]; const nextValue = map[s[i + 1]]; total += value < nextValue ? -value : value; } return total; };",No,No,O(n),3
"const minStack = () => { const stack = [], minStack = []; this.push = (x) => { stack.push(x); if (minStack.length === 0 || x <= minStack[minStack.length - 1]) minStack.push(x); }; this.pop = () => { const popped = stack.pop(); if (popped === minStack[minStack.length - 1]) minStack.pop(); return popped; }; this.top = () => { return stack[stack.length - 1]; }; this.getMin = () => { return minStack[minStack.length - 1]; }; };",No,No,O(1),4
"const lengthOfLIS = (nums) => { const dp = []; for (let num of nums) { const index = dp.findIndex(d => d >= num); if (index === -1) dp.push(num); else dp[index] = num; } return dp.length; };",No,No,O(n log n),3
"const removeDuplicates = (nums) => { if (nums.length === 0) return 0; let count = 1; for (let i = 1; i < nums.length; i++) { if (nums[i] !== nums[i - 1]) { nums[count] = nums[i]; count++; } } return count; };",No,No,O(n),2
"const maxArea = (height) => { let left = 0, right = height.length - 1; let max = 0; while (left < right) { max = Math.max(max, Math.min(height[left], height[right]) * (right - left)); if (height[left] < height[right]) left++; else right--; } return max; };",No,No,O(n),3
"const uniquePaths = (m, n) => { const dp = Array.from({ length: m }, () => Array(n).fill(1)); for (let i = 1; i < m; i++) { for (let j = 1; j < n; j++) { dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } return dp[m - 1][n - 1]; };",No,No,O(m * n),4
"const pathSum = (root, sum) => { if (!root) return 0; let count = 0; const dfs = (node, currSum) => { if (!node) return; currSum += node.val; if (currSum === sum) count++; dfs(node.left, currSum); dfs(node.right, currSum); }; dfs(root, 0); return count; };",No,No,O(n),4
"const rotate = (matrix) => { const n = matrix.length; for (let layer = 0; layer < n / 2; layer++) { const first = layer; const last = n - 1 - layer; for (let i = first; i < last; i++) { const offset = i - first; const top = matrix[first][i]; matrix[first][i] = matrix[last - offset][first]; matrix[last - offset][first] = matrix[last][last - offset]; matrix[last][last - offset] = matrix[i][last]; matrix[i][last] = top; } } };",No,No,O(n^2),4
"const groupThePeople = (groupSizes) => { const map = {}; for (let i = 0; i < groupSizes.length; i++) { if (!map[groupSizes[i]]) map[groupSizes[i]] = []; map[groupSizes[i]].push(i); } const result = []; for (const size in map) { let group = []; for (const person of map[size]) { group.push(person); if (group.length === Number(size)) { result.push(group); group = []; } } } return result; };",No,No,O(n),4
"const subsetsWithDup = (nums) => { const result = []; nums.sort(); const backtrack = (start, path) => { result.push([...path]); for (let i = start; i < nums.length; i++) { if (i > start && nums[i] === nums[i - 1]) continue; path.push(nums[i]); backtrack(i + 1, path); path.pop(); } }; backtrack(0, []); return result; };",No,No,O(2^n),4
"const kthSmallest = (matrix, k) => { const nums = [].concat(...matrix).sort((a, b) => a - b); return nums[k - 1]; };",No,No,O(n log n),3
"const mergeKLists = (lists) => { const merged = []; for (const list of lists) { while (list) { merged.push(list.val); list = list.next; } } merged.sort((a, b) => a - b); const dummy = new ListNode(0); let curr = dummy; for (const val of merged) { curr.next = new ListNode(val); curr = curr.next; } return dummy.next; };",No,No,O(n log n),3
"const evalRPN = (tokens) => { const stack = []; for (const token of tokens) { if (!isNaN(token)) { stack.push(parseInt(token)); } else { const b = stack.pop(), a = stack.pop(); switch (token) { case '+': stack.push(a + b); break; case '-': stack.push(a - b); break; case '*': stack.push(a * b); break; case '/': stack.push(Math.trunc(a / b)); break; } } } return stack[0]; };",No,No,O(n),3
"const findMedianSortedArrays = (nums1, nums2) => { const merged = [...nums1, ...nums2].sort((a, b) => a - b); const mid = Math.floor(merged.length / 2); return merged.length % 2 === 0 ? (merged[mid - 1] + merged[mid]) / 2 : merged[mid]; };",No,No,O(n log n),3
"const longestCommonPrefix = (strs) => { if (!strs.length) return ''; let prefix = strs[0]; for (let i = 1; i < strs.length; i++) { while (strs[i].indexOf(prefix) !== 0) { prefix = prefix.substring(0, prefix.length - 1); } } return prefix; };",No,No,O(n * m),3
"const maximumProduct = (nums) => { nums.sort((a, b) => a - b); return Math.max(nums[0] * nums[1] * nums[nums.length - 1], nums[nums.length - 1] * nums[nums.length - 2] * nums[nums.length - 3]); };",No,No,O(n log n),3
"const generate = (numRows) => { const res = []; for (let i = 0; i < numRows; i++) { res[i] = []; for (let j = 0; j <= i; j++) { res[i][j] = (j === 0 || j === i) ? 1 : res[i - 1][j - 1] + res[i - 1][j]; } } return res; };",No,No,O(n^2),4
"const threeSum = (nums) => { nums.sort((a, b) => a - b); const res = []; for (let i = 0; i < nums.length - 2; i++) { if (i > 0 && nums[i] === nums[i - 1]) continue; let left = i + 1, right = nums.length - 1; while (left < right) { const sum = nums[i] + nums[left] + nums[right]; if (sum === 0) { res.push([nums[i], nums[left], nums[right]]); while (left < right && nums[left] === nums[left + 1]) left++; while (left < right && nums[right] === nums[right - 1]) right--; left++; right--; } else if (sum < 0) left++; else right--; } } return res; };",No,No,O(n^2),4
"const reverseString = (s) => { return s.split('').reverse().join(''); };",No,No,O(n),2
"const twoSum = (nums, target) => { const map = {}; for (let i = 0; i < nums.length; i++) { const complement = target - nums[i]; if (map[complement] !== undefined) return [map[complement], i]; map[nums[i]] = i; } };",No,No,O(n),3
"const climbStairs = (n) => { if (n <= 2) return n; let first = 1, second = 2; for (let i = 3; i <= n; i++) { [first, second] = [second, first + second]; } return second; };",No,No,O(n),3
"const maximumSubArray = (nums) => { let maxSum = nums[0], currentSum = nums[0]; for (let i = 1; i < nums.length; i++) { currentSum = Math.max(nums[i], currentSum + nums[i]); maxSum = Math.max(maxSum, currentSum); } return maxSum; };",No,No,O(n),3
"const rotateImage = (matrix) => { const n = matrix.length; for (let layer = 0; layer < n / 2; layer++) { const first = layer; const last = n - 1 - layer; for (let i = first; i < last; i++) { const offset = i - first; const top = matrix[first][i]; matrix[first][i] = matrix[last - offset][first]; matrix[last - offset][first] = matrix[last][last - offset]; matrix[last][last - offset] = matrix[i][last]; matrix[i][last] = top; } } };",No,No,O(n^2),4
"const productExceptSelf = (nums) => { const output = Array(nums.length).fill(1); let leftProduct = 1; for (let i = 0; i < nums.length; i++) { output[i] = leftProduct; leftProduct *= nums[i]; } let rightProduct = 1; for (let i = nums.length - 1; i >= 0; i--) { output[i] *= rightProduct; rightProduct *= nums[i]; } return output; };",No,No,O(n),3
"const longestPalindromicSubstring = (s) => { let start = 0, end = 0; const expandFromCenter = (left, right) => { while (left >= 0 && right < s.length && s[left] === s[right]) { left--; right++; } return right - left - 1; }; for (let i = 0; i < s.length; i++) { const len1 = expandFromCenter(i, i); const len2 = expandFromCenter(i, i + 1); const len = Math.max(len1, len2); if (len > end - start) { start = i - Math.floor((len - 1) / 2); end = i + Math.floor(len / 2); } } return s.substring(start, end + 1); };",No,No,O(n^2),4
"const isValid = (s) => { const stack = []; const map = { '(': ')', '{': '}', '[': ']' }; for (const char of s) { if (map[char]) { stack.push(map[char]); } else if (stack.length === 0 || stack.pop() !== char) { return false; } } return stack.length === 0; };",No,No,O(n),3
"const minPathSum = (grid) => { const m = grid.length, n = grid[0].length; for (let i = 0; i < m; i++) { for (let j = 0; j < n; j++) { if (i === 0 && j === 0) continue; grid[i][j] += Math.min(i > 0 ? grid[i - 1][j] : Infinity, j > 0 ? grid[i][j - 1] : Infinity); } } return grid[m - 1][n - 1]; };",No,No,O(m * n),4
"const climbStairs = (n) => { const dp = Array(n + 1).fill(0); dp[0] = 1; dp[1] = 1; for (let i = 2; i <= n; i++) { dp[i] = dp[i - 1] + dp[i - 2]; } return dp[n]; };",No,No,O(n),3
"const longestSubstringKDistinct = (s, k) => { const map = {}; let left = 0, maxLength = 0; for (let right = 0; right < s.length; right++) { map[s[right]] = (map[s[right]] || 0) + 1; while (Object.keys(map).length > k) { map[s[left]]--; if (map[s[left]] === 0) delete map[s[left]]; left++; } maxLength = Math.max(maxLength, right - left + 1); } return maxLength; };",No,No,O(n),4
"const dailyTemperatures = (T) => { const result = Array(T.length).fill(0); const stack = []; for (let i = 0; i < T.length; i++) { while (stack.length && T[i] > T[stack[stack.length - 1]]) { const j = stack.pop(); result[j] = i - j; } stack.push(i); } return result; };",No,No,O(n),3
"const randomPickIndex = (nums) => { this.nums = nums; }; randomPickIndex.prototype.pick = function() { const randIndex = Math.floor(Math.random() * this.nums.length); return this.nums[randIndex]; };",No,No,O(1),2
"const smallestRangeI = (A, K) => { const minA = Math.min(...A), maxA = Math.max(...A); return Math.max(0, maxA - minA - 2 * K); };",No,No,O(n),2
"const hIndex = (citations) => { citations.sort((a, b) => a - b); for (let i = 0; i < citations.length; i++) { if (citations[i] >= citations.length - i) return citations.length - i; } return 0; };",No,No,O(n log n),3
"const lemonadeChange = (bills) => { let five = 0, ten = 0; for (const bill of bills) { if (bill === 5) five++; else if (bill === 10) { if (five === 0) return false; five--; ten++; } else { if (ten > 0 && five > 0) { ten--; five--; } else if (five >= 3) { five -= 3; } else { return false; } } } return true; };",No,No,O(n),3
"const canPlaceFlowers = (flowerbed, n) => { let count = 0; for (let i = 0; i < flowerbed.length; i++) { if (flowerbed[i] === 0 && (i === 0 || flowerbed[i - 1] === 0) && (i === flowerbed.length - 1 || flowerbed[i + 1] === 0)) { flowerbed[i] = 1; count++; } } return count >= n; };",No,No,O(n),3
"const uniquePathsWithObstacles = (obstacleGrid) => { const m = obstacleGrid.length, n = obstacleGrid[0].length; const dp = Array.from({ length: m }, () => Array(n).fill(0)); dp[0][0] = obstacleGrid[0][0] === 0 ? 1 : 0; for (let i = 0; i < m; i++) { for (let j = 0; j < n; j++) { if (obstacleGrid[i][j] === 1) dp[i][j] = 0; else { if (i > 0) dp[i][j] += dp[i - 1][j]; if (j > 0) dp[i][j] += dp[i][j - 1]; } } } return dp[m - 1][n - 1]; };",No,No,O(m * n),4
"const longestSubarray = (nums) => { let left = 0, maxLen = 0, zeroCount = 0; for (let right = 0; right < nums.length; right++) { if (nums[right] === 0) zeroCount++; while (zeroCount > 1) { if (nums[left] === 0) zeroCount--; left++; } maxLen = Math.max(maxLen, right - left); } return maxLen; };",No,No,O(n),3
"const minCostClimbingStairs = (cost) => { const n = cost.length; for (let i = 2; i < n; i++) cost[i] += Math.min(cost[i - 1], cost[i - 2]); return Math.min(cost[n - 1], cost[n - 2]); };",No,No,O(n),3
"const findKthLargest = (nums, k) => { nums.sort((a, b) => b - a); return nums[k - 1]; };",No,No,O(n log n),3
"const isAnagram = (s, t) => { if (s.length !== t.length) return false; const count = {}; for (const char of s) { count[char] = (count[char] || 0) + 1; } for (const char of t) { if (!count[char]) return false; count[char]--; if (count[char] < 0) return false; } return true; };",No,No,O(n),3
"const removeDuplicates = (nums) => { let i = 0; for (let j = 1; j < nums.length; j++) { if (nums[i] !== nums[j]) { i++; nums[i] = nums[j]; } } return i + 1; };",No,No,O(n),3
"const findPeakElement = (nums) => { let left = 0, right = nums.length - 1; while (left < right) { const mid = Math.floor((left + right) / 2); if (nums[mid] < nums[mid + 1]) left = mid + 1; else right = mid; } return left; };",No,No,O(log n),3
"const searchInsert = (nums, target) => { let left = 0, right = nums.length - 1; while (left <= right) { const mid = Math.floor((left + right) / 2); if (nums[mid] === target) return mid; if (nums[mid] < target) left = mid + 1; else right = mid - 1; } return left; };",No,No,O(log n),3
"const mergeSortedArray = (nums1, m, nums2, n) => { let i = m + n - 1; while (m > 0 && n > 0) { if (nums1[m - 1] > nums2[n - 1]) { nums1[i] = nums1[m - 1]; m--; } else { nums1[i] = nums2[n - 1]; n--; } i--; } while (n > 0) { nums1[i] = nums2[n - 1]; n--; i--; } };",No,No,O(m + n),3
"const validateBinarySearchTree = (root) => { const helper = (node, low, high) => { if (!node) return true; if (node.val <= low || node.val >= high) return false; return helper(node.left, low, node.val) && helper(node.right, node.val, high); }; return helper(root, -Infinity, Infinity); };",No,No,O(n),3
"const twoSumLessThan = (A, target) => { let maxSum = -1; A.sort((a, b) => a - b); let left = 0, right = A.length - 1; while (left < right) { const sum = A[left] + A[right]; if (sum < target) { maxSum = Math.max(maxSum, sum); left++; } else { right--; } } return maxSum; };",No,No,O(n log n),4
"const canJump = (nums) => { let maxReach = 0; for (let i = 0; i < nums.length; i++) { if (i > maxReach) return false; maxReach = Math.max(maxReach, i + nums[i]); } return true; };",No,No,O(n),3
"const jump = (nums) => { if (nums.length === 0) return 0; let jumps = 0, maxReach = 0, currEnd = 0; for (let i = 0; i < nums.length - 1; i++) { maxReach = Math.max(maxReach, i + nums[i]); if (i === currEnd) { jumps++; currEnd = maxReach; } } return jumps; };",No,No,O(n),3
"const maxArea = (height) => { let left = 0, right = height.length - 1, maxArea = 0; while (left < right) { maxArea = Math.max(maxArea, (right - left) * Math.min(height[left], height[right])); height[left] < height[right] ? left++ : right--; } return maxArea; };",No,No,O(n),3
"const groupAnagrams = (strs) => { const map = {}; for (const str of strs) { const sortedStr = str.split('').sort().join(''); if (!map[sortedStr]) map[sortedStr] = []; map[sortedStr].push(str); } return Object.values(map); };",No,No,O(n * m log m),4
"const lengthOfLastWord = (s) => { const words = s.trim().split(' '); return words.length ? words[words.length - 1].length : 0; };",No,No,O(n),2
"const spiralOrder = (matrix) => { if (!matrix.length) return []; const result = []; let top = 0, bottom = matrix.length - 1, left = 0, right = matrix[0].length - 1; while (top <= bottom && left <= right) { for (let i = left; i <= right; i++) result.push(matrix[top][i]); top++; for (let i = top; i <= bottom; i++) result.push(matrix[i][right]); right--; if (top <= bottom) { for (let i = right; i >= left; i--) result.push(matrix[bottom][i]); bottom--; } if (left <= right) { for (let i = bottom; i >= top; i--) result.push(matrix[i][left]); left++; } } return result; };",No,No,O(n),4
"const smallestK = (arr, k) => { arr.sort((a, b) => a - b); return arr.slice(0, k); };",No,No,O(n log n),3
"const rotate = (nums, k) => { k %= nums.length; const reverse = (arr, start, end) => { while (start < end) { [arr[start], arr[end]] = [arr[end], arr[start]]; start++; end--; } }; reverse(nums, 0, nums.length - 1); reverse(nums, 0, k - 1); reverse(nums, k, nums.length - 1); };",No,No,O(n),3
"const isSymmetric = (root) => { const isMirror = (t1, t2) => { if (!t1 && !t2) return true; if (!t1 || !t2) return false; return (t1.val === t2.val) && isMirror(t1.right, t2.left) && isMirror(t1.left, t2.right); }; return isMirror(root, root); };",No,No,O(n),3
"const minWindow = (s, t) => { const need = {}, window = {}; for (const char of t) need[char] = (need[char] || 0) + 1; let left = 0, right = 0, valid = 0, minLen = Infinity, start = 0; while (right < s.length) { const c = s[right]; right++; if (need[c]) { window[c] = (window[c] || 0) + 1; if (window[c] === need[c]) valid++; } while (valid === Object.keys(need).length) { if (right - left < minLen) { minLen = right - left; start = left; } const d = s[left]; left++; if (need[d]) { if (window[d] === need[d]) valid--; window[d]--; } } } return minLen === Infinity ? '' : s.substring(start, start + minLen); };",No,No,O(n),4
"const reverseWords = (s) => { return s.trim().split(/\s+/).reverse().join(' '); };",No,No,O(n),2
"const subsets = (nums) => { const result = []; const backtrack = (start, path) => { result.push(path); for (let i = start; i < nums.length; i++) backtrack(i + 1, path.concat(nums[i])); }; backtrack(0, []); return result; };",No,No,O(2^n),4
"const productExceptSelf = (nums) => { const result = Array(nums.length).fill(1); let left = 1, right = 1; for (let i = 0; i < nums.length; i++) { result[i] *= left; left *= nums[i]; } for (let i = nums.length - 1; i >= 0; i--) { result[i] *= right; right *= nums[i]; } return result; };",No,No,O(n),3
"const canConstruct = (ransomNote, magazine) => { const count = {}; for (const char of magazine) count[char] = (count[char] || 0) + 1; for (const char of ransomNote) { if (!count[char]) return false; count[char]--; } return true; };",No,No,O(n),3
"const intersect = (nums1, nums2) => { const map = {}; const result = []; for (const num of nums1) { map[num] = (map[num] || 0) + 1; } for (const num of nums2) { if (map[num] > 0) { result.push(num); map[num]--; } } return result; };",No,No,O(n),3
"const uniquePaths = (m, n) => { const dp = Array(m).fill().map(() => Array(n).fill(1)); for (let i = 1; i < m; i++) { for (let j = 1; j < n; j++) { dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } return dp[m - 1][n - 1]; };",No,No,O(m * n),3
"const floodFill = (image, sr, sc, newColor) => { const originalColor = image[sr][sc]; if (originalColor === newColor) return image; const fill = (r, c) => { if (image[r][c] === originalColor) { image[r][c] = newColor; if (r > 0) fill(r - 1, c); if (r < image.length - 1) fill(r + 1, c); if (c > 0) fill(r, c - 1); if (c < image[0].length - 1) fill(r, c + 1); } }; fill(sr, sc); return image; };",No,No,O(n),3
"const search = (nums, target) => { let left = 0, right = nums.length - 1; while (left <= right) { const mid = Math.floor((left + right) / 2); if (nums[mid] === target) return mid; else if (nums[mid] < target) left = mid + 1; else right = mid - 1; } return -1; };",No,No,O(log n),3
"const countPrimes = (n) => { const isPrime = Array(n).fill(true); isPrime[0] = isPrime[1] = false; for (let i = 2; i * i < n; i++) { if (isPrime[i]) { for (let j = i * i; j < n; j += i) isPrime[j] = false; } } return isPrime.filter(Boolean).length; };",No,No,O(n log log n),4
"const maximumProduct = (nums) => { nums.sort((a, b) => a - b); const len = nums.length; return Math.max(nums[len - 1] * nums[len - 2] * nums[len - 3], nums[0] * nums[1] * nums[len - 1]); };",No,No,O(n log n),3
	"const addTwoNumbers = (l1, l2) => { let dummy = new ListNode(0), p = l1, q = l2, curr = dummy, carry = 0; while (p || q || carry) { const x = p ? p.val : 0; const y = q ? q.val : 0; const sum = carry + x + y; carry = Math.floor(sum / 10); curr.next = new ListNode(sum % 10); curr = curr.next; if (p) p = p.next; if (q) q = q.next; } return dummy.next; };",No,No,O(max(m, n)),3
"const combinationSum = (candidates, target) => { const result = []; const backtrack = (start, path, sum) => { if (sum === target) result.push([...path]); if (sum >= target) return; for (let i = start; i < candidates.length; i++) { path.push(candidates[i]); backtrack(i, path, sum + candidates[i]); path.pop(); } }; backtrack(0, [], 0); return result; };",No,No,O(2^n),4
"const maxSubArray = (nums) => { let maxSum = nums[0], currentSum = nums[0]; for (let i = 1; i < nums.length; i++) { currentSum = Math.max(nums[i], currentSum + nums[i]); maxSum = Math.max(maxSum, currentSum); } return maxSum; };",No,No,O(n),3
"const longestCommonPrefix = (strs) => { if (!strs.length) return ''; let prefix = strs[0]; for (let i = 1; i < strs.length; i++) { while (strs[i].indexOf(prefix) !== 0) { prefix = prefix.substring(0, prefix.length - 1); } } return prefix; };",No,No,O(n * m),4
"const permute = (nums) => { const result = []; const backtrack = (path) => { if (path.length === nums.length) result.push([...path]); for (let num of nums) { if (path.includes(num)) continue; path.push(num); backtrack(path); path.pop(); } }; backtrack([]); return result; };",No,No,O(n!),4
"const findMedianSortedArrays = (nums1, nums2) => { const merged = [...nums1, ...nums2].sort((a, b) => a - b); const mid = Math.floor(merged.length / 2); return merged.length % 2 === 0 ? (merged[mid - 1] + merged[mid]) / 2 : merged[mid]; };",No,No,O((m + n) log(m + n)),4
"const canPlaceFlowers = (flowerbed, n) => { let count = 0; for (let i = 0; i < flowerbed.length; i++) { if (flowerbed[i] === 0 && (i === 0 || flowerbed[i - 1] === 0) && (i === flowerbed.length - 1 || flowerbed[i + 1] === 0)) { flowerbed[i] = 1; count++; } } return count >= n; };",No,No,O(n),3
"const lengthOfLongestSubstring = (s) => { const set = new Set(); let left = 0, maxLength = 0; for (let right = 0; right < s.length; right++) { while (set.has(s[right])) { set.delete(s[left]); left++; } set.add(s[right]); maxLength = Math.max(maxLength, right - left + 1); } return maxLength; };",No,No,O(n),3
"const climbStairs = (n) => { const dp = Array(n + 1).fill(0); dp[0] = 1; dp[1] = 1; for (let i = 2; i <= n; i++) { dp[i] = dp[i - 1] + dp[i - 2]; } return dp[n]; };",No,No,O(n),3
"const validPalindrome = (s) => { const isPalindrome = (str) => str === str.split('').reverse().join(''); let left = 0, right = s.length - 1; while (left < right) { if (s[left] !== s[right]) { return isPalindrome(s.slice(left + 1, right + 1)) || isPalindrome(s.slice(left, right)); } left++; right--; } return true; };",No,No,O(n),3
"const findSubarray = (nums, target) => { const result = []; for (let i = 0; i < nums.length; i++) { let sum = 0; for (let j = i; j < nums.length; j++) { sum += nums[j]; if (sum === target) result.push(nums.slice(i, j + 1)); } } return result; };",No,No,O(n^2),4
"const maximumGap = (nums) => { if (nums.length < 2) return 0; const max = Math.max(...nums), min = Math.min(...nums); const bucketSize = Math.ceil((max - min) / (nums.length - 1)) || 1; const bucketCount = Math.floor((max - min) / bucketSize) + 1; const buckets = Array.from({ length: bucketCount }, () => [Infinity, -Infinity]); for (const num of nums) { const idx = Math.floor((num - min) / bucketSize); buckets[idx][0] = Math.min(buckets[idx][0], num); buckets[idx][1] = Math.max(buckets[idx][1], num); } let maxGap = 0, previousMax = min; for (const [minVal, maxVal] of buckets) { if (minVal === Infinity) continue; maxGap = Math.max(maxGap, minVal - previousMax); previousMax = maxVal; } return maxGap; };",No,No,O(n),4
"const maxProductSubarray = (nums) => { let maxProd = nums[0], minProd = nums[0], result = nums[0]; for (let i = 1; i < nums.length; i++) { if (nums[i] < 0) [maxProd, minProd] = [minProd, maxProd]; maxProd = Math.max(nums[i], maxProd * nums[i]); minProd = Math.min(nums[i], minProd * nums[i]); result = Math.max(result, maxProd); } return result; };",No,No,O(n),3
"const binaryTreePaths = (root) => { const paths = []; const traverse = (node, path) => { if (!node) return; path += node.val; if (!node.left && !node.right) paths.push(path); else { path += '->'; traverse(node.left, path); traverse(node.right, path); } }; traverse(root, ''); return paths; };",No,No,O(n),4
"const isAnagram = (s, t) => { if (s.length !== t.length) return false; const count = {}; for (const char of s) count[char] = (count[char] || 0) + 1; for (const char of t) { if (!count[char]) return false; count[char]--; } return true; };",No,No,O(n),3
"const longestSubstring = (s, k) => { const charCount = {}; for (const char of s) charCount[char] = (charCount[char] || 0) + 1; for (const char in charCount) { if (charCount[char] < k) return Math.max(longestSubstring(s.slice(0, s.indexOf(char)), k), longestSubstring(s.slice(s.indexOf(char) + 1), k)); } return s.length; };",No,No,O(n^2),4
"const minimumPathSum = (grid) => { for (let i = 0; i < grid.length; i++) { for (let j = 0; j < grid[0].length; j++) { if (i > 0 && j > 0) grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]); else if (i > 0) grid[i][j] += grid[i - 1][j]; else if (j > 0) grid[i][j] += grid[i][j - 1]; } } return grid[grid.length - 1][grid[0].length - 1]; };",No,No,O(m * n),3
"const searchMatrix = (matrix, target) => { if (!matrix.length || !matrix[0].length) return false; let row = 0, col = matrix[0].length - 1; while (row < matrix.length && col >= 0) { if (matrix[row][col] === target) return true; else if (matrix[row][col] < target) row++; else col--; } return false; };",No,No,O(m + n),3
"const convert = (s, numRows) => { if (numRows === 1) return s; const rows = Array(Math.min(numRows, s.length)).fill(''); let curRow = 0, goingDown = false; for (const char of s) { rows[curRow] += char; if (curRow === 0 || curRow === numRows - 1) goingDown = !goingDown; curRow += goingDown ? 1 : -1; } return rows.join(''); };",No,No,O(n),3
"const groupAnagrams = (strs) => { const map = {}; for (const str of strs) { const key = str.split('').sort().join(''); if (!map[key]) map[key] = []; map[key].push(str); } return Object.values(map); };",No,No,O(n * m log m),4
"const numIslands = (grid) => { if (!grid.length) return 0; let count = 0; const dfs = (i, j) => { if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] === '0') return; grid[i][j] = '0'; dfs(i - 1, j); dfs(i + 1, j); dfs(i, j - 1); dfs(i, j + 1); }; for (let i = 0; i < grid.length; i++) { for (let j = 0; j < grid[0].length; j++) { if (grid[i][j] === '1') { count++; dfs(i, j); } } } return count; };",No,No,O(m * n),4
"const threeSum = (nums) => { nums.sort((a, b) => a - b); const result = []; for (let i = 0; i < nums.length - 2; i++) { if (i > 0 && nums[i] === nums[i - 1]) continue; let left = i + 1, right = nums.length - 1; while (left < right) { const sum = nums[i] + nums[left] + nums[right]; if (sum === 0) { result.push([nums[i], nums[left], nums[right]]); while (left < right && nums[left] === nums[left + 1]) left++; while (left < right && nums[right] === nums[right - 1]) right--; left++; right--; } else if (sum < 0) left++; else right--; } } return result; };",No,No,O(n^2),4
"const rotate = (nums, k) => { k %= nums.length; reverse(nums, 0, nums.length - 1); reverse(nums, 0, k - 1); reverse(nums, k, nums.length - 1); }; const reverse = (arr, start, end) => { while (start < end) { [arr[start], arr[end]] = [arr[end], arr[start]]; start++; end--; } };",No,No,O(n),3
"const productExceptSelf = (nums) => { const result = Array(nums.length).fill(1); let left = 1, right = 1; for (let i = 0; i < nums.length; i++) { result[i] *= left; left *= nums[i]; result[nums.length - 1 - i] *= right; right *= nums[nums.length - 1 - i]; } return result; };",No,No,O(n),3
"const hammingDistance = (x, y) => { return (x ^ y).toString(2).split('0').join('').length; };",No,No,O(1),3
"const maxArea = (height) => { let max = 0, left = 0, right = height.length - 1; while (left < right) { const area = Math.min(height[left], height[right]) * (right - left); max = Math.max(max, area); if (height[left] < height[right]) left++; else right--; } return max; };",No,No,O(n),3
"const myAtoi = (s) => { const trimmed = s.trim(); const regex = /^([-+]?\\d+)/; const match = trimmed.match(regex); if (!match) return 0; const num = parseInt(match[0]); if (num < Math.pow(-2, 31)) return Math.pow(-2, 31); if (num > Math.pow(2, 31) - 1) return Math.pow(2, 31) - 1; return num; };",No,No,O(n),4
"const longestValidParentheses = (s) => { const stack = [-1]; let maxLength = 0; for (let i = 0; i < s.length; i++) { if (s[i] === '(') stack.push(i); else { stack.pop(); if (stack.length === 0) stack.push(i); else maxLength = Math.max(maxLength, i - stack[stack.length - 1]); } } return maxLength; };",No,No,O(n),4
"const climbStairs = (n) => { let first = 1, second = 1; for (let i = 2; i <= n; i++) { [first, second] = [second, first + second]; } return second; };",No,No,O(n),3
"const validParentheses = (s) => { const stack = []; const mapping = { '(': ')', '{': '}', '[': ']' }; for (const char of s) { if (mapping[char]) stack.push(mapping[char]); else if (stack.length === 0 || stack.pop() !== char) return false; } return stack.length === 0; };",No,No,O(n),3
"const reverseString = (s) => { return s.split('').reverse().join(''); };",No,No,O(n),3
"const findMin = (nums) => { let left = 0, right = nums.length - 1; while (left < right) { const mid = Math.floor((left + right) / 2); if (nums[mid] > nums[right]) left = mid + 1; else right = mid; } return nums[left]; };",No,No,O(log n),4
"const containsDuplicate = (nums) => { const set = new Set(); for (const num of nums) { if (set.has(num)) return true; set.add(num); } return false; };",No,No,O(n),3
"const generateParenthesis = (n) => { const result = []; const backtrack = (current, open, close) => { if (current.length === 2 * n) { result.push(current); return; } if (open < n) backtrack(current + '(', open + 1, close); if (close < open) backtrack(current + ')', open, close + 1); }; backtrack('', 0, 0); return result; };",No,No,O(4^n / sqrt(n)),4
"const isSymmetric = (root) => { const check = (l, r) => { if (!l && !r) return true; if (!l || !r) return false; return l.val === r.val && check(l.left, r.right) && check(l.right, r.left); }; return check(root, root); };",No,No,O(n),4
"const topKFrequent = (nums, k) => { const count = {}; for (const num of nums) count[num] = (count[num] || 0) + 1; return Object.entries(count).sort((a, b) => b[1] - a[1]).slice(0, k).map(([num]) => Number(num)); };",No,No,O(n log n),4
"const shortestPathBinaryMatrix = (grid) => { if (grid[0][0] === 1 || grid[grid.length - 1][grid[0].length - 1] === 1) return -1; const directions = [[1, 0], [-1, 0], [0, 1], [0, -1], [1, 1], [-1, -1], [-1, 1], [1, -1]]; const queue = [[0, 0, 1]]; while (queue.length) { const [x, y, steps] = queue.shift(); if (x === grid.length - 1 && y === grid[0].length - 1) return steps; for (const [dx, dy] of directions) { const nx = x + dx, ny = y + dy; if (nx >= 0 && ny >= 0 && nx < grid.length && ny < grid[0].length && grid[nx][ny] === 0) { grid[nx][ny] = 1; queue.push([nx, ny, steps + 1]); } } } return -1; };",No,No,O(n^2),4
"const findPeakElement = (nums) => { let left = 0, right = nums.length - 1; while (left < right) { const mid = Math.floor((left + right) / 2); if (nums[mid] < nums[mid + 1]) left = mid + 1; else right = mid; } return left; };",No,No,O(log n),4
"const removeDuplicates = (nums) => { if (nums.length === 0) return 0; let k = 1; for (let i = 1; i < nums.length; i++) { if (nums[i] !== nums[i - 1]) { nums[k] = nums[i]; k++; } } return k; };",No,No,O(n),3
"const twoSum = (nums, target) => { const map = {}; for (let i = 0; i < nums.length; i++) { const complement = target - nums[i]; if (map[complement] !== undefined) return [map[complement], i]; map[nums[i]] = i; } };",No,No,O(n),4
"const binaryTreePaths = (root) => { const paths = []; const dfs = (node, path) => { if (!node) return; path += node.val; if (!node.left && !node.right) paths.push(path); else { path += '->'; dfs(node.left, path); dfs(node.right, path); } }; dfs(root, ''); return paths; };",No,No,O(n),4
"const isAnagram = (s, t) => { if (s.length !== t.length) return false; const count = {}; for (const char of s) count[char] = (count[char] || 0) + 1; for (const char of t) { if (!count[char]) return false; count[char]--; } return true; };",No,No,O(n),3
"const longestSubstring = (s, k) => { const charCount = {}; for (const char of s) charCount[char] = (charCount[char] || 0) + 1; for (const char in charCount) { if (charCount[char] < k) return Math.max(longestSubstring(s.slice(0, s.indexOf(char)), k), longestSubstring(s.slice(s.indexOf(char) + 1), k)); } return s.length; };",No,No,O(n^2),4
"const minimumPathSum = (grid) => { for (let i = 0; i < grid.length; i++) { for (let j = 0; j < grid[0].length; j++) { if (i > 0 && j > 0) grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]); else if (i > 0) grid[i][j] += grid[i - 1][j]; else if (j > 0) grid[i][j] += grid[i][j - 1]; } } return grid[grid.length - 1][grid[0].length - 1]; };",No,No,O(m * n),3
"const searchMatrix = (matrix, target) => { if (!matrix.length || !matrix[0].length) return false; let row = 0, col = matrix[0].length - 1; while (row < matrix.length && col >= 0) { if (matrix[row][col] === target) return true; else if (matrix[row][col] < target) row++; else col--; } return false; };",No,No,O(m + n),3
"const groupAnagrams = (strs) => { const map = {}; for (const str of strs) { const key = str.split('').sort().join(''); if (!map[key]) map[key] = []; map[key].push(str); } return Object.values(map); };",No,No,O(n * k log k),4
"const lengthOfLongestSubstring = (s) => { const charIndexMap = {}; let maxLength = 0, start = 0; for (let i = 0; i < s.length; i++) { if (charIndexMap[s[i]] !== undefined) start = Math.max(start, charIndexMap[s[i]] + 1); charIndexMap[s[i]] = i; maxLength = Math.max(maxLength, i - start + 1); } return maxLength; };",No,No,O(n),3
"const combine = (n, k) => { const result = []; const backtrack = (start, path) => { if (path.length === k) { result.push([...path]); return; } for (let i = start; i <= n; i++) { path.push(i); backtrack(i + 1, path); path.pop(); } }; backtrack(1, []); return result; };",No,No,O(nCk),4
"const largestRectangleArea = (heights) => { const stack = []; let maxArea = 0; heights.push(0); for (let i = 0; i < heights.length; i++) { while (stack.length && heights[i] < heights[stack[stack.length - 1]]) { const h = heights[stack.pop()]; const w = stack.length ? i - stack[stack.length - 1] - 1 : i; maxArea = Math.max(maxArea, h * w); } stack.push(i); } return maxArea; };",No,No,O(n),4
"const climbStairsWithVariableSteps = (n) => { const dp = new Array(n + 1).fill(0); dp[0] = 1; for (let i = 1; i <= n; i++) { for (let j = 1; j <= 2; j++) { if (i - j >= 0) dp[i] += dp[i - j]; } } return dp[n]; };",No,No,O(n),3
"const findDuplicate = (nums) => { let slow = nums[0], fast = nums[0]; do { slow = nums[slow]; fast = nums[nums[fast]]; } while (slow !== fast); let ptr1 = nums[0], ptr2 = slow; while (ptr1 !== ptr2) { ptr1 = nums[ptr1]; ptr2 = nums[ptr2]; } return ptr1; };",No,No,O(n),4
"const missingNumber = (nums) => { const n = nums.length; const totalSum = (n * (n + 1)) / 2; const arraySum = nums.reduce((acc, num) => acc + num, 0); return totalSum - arraySum; };",No,No,O(n),3
"const partitionLabels = (s) => { const lastIndex = {}; for (let i = 0; i < s.length; i++) lastIndex[s[i]] = i; const result = []; let anchor = 0, farthest = 0; for (let i = 0; i < s.length; i++) { farthest = Math.max(farthest, lastIndex[s[i]]); if (i === farthest) { result.push(i - anchor + 1); anchor = i + 1; } } return result; };",No,No,O(n),4
"const validPalindrome = (s) => { const isPalindrome = (str) => str === str.split('').reverse().join(''); for (let i = 0; i < s.length; i++) { const modified = s.slice(0, i) + s.slice(i + 1); if (isPalindrome(modified)) return true; } return false; };",No,No,O(n^2),4
"const findLongestWord = (s, d) => { let longest = ''; for (const word of d) { if (word.length > longest.length && isSubsequence(word, s)) longest = word; } return longest; }; const isSubsequence = (word, s) => { let j = 0; for (const char of s) { if (char === word[j]) j++; if (j === word.length) return true; } return false; };",No,No,O(n * m),4
	"const longestCommonPrefix = (strs) => { if (!strs.length) return ''; let prefix = strs[0]; for (let i = 1; i < strs.length; i++) { while (strs[i].indexOf(prefix) !== 0) prefix = prefix.slice(0, -1); } return prefix; };",No,No,O(n * m),4
"const spiralOrder = (matrix) => { if (!matrix.length) return []; const result = []; let top = 0, bottom = matrix.length - 1, left = 0, right = matrix[0].length - 1; while (top <= bottom && left <= right) { for (let i = left; i <= right; i++) result.push(matrix[top][i]); top++; for (let i = top; i <= bottom; i++) result.push(matrix[i][right]); right--; if (top <= bottom) { for (let i = right; i >= left; i--) result.push(matrix[bottom][i]); bottom--; } if (left <= right) { for (let i = bottom; i >= top; i--) result.push(matrix[i][left]); left++; } } return result; };",No,No,O(n * m),4
"const searchInsert = (nums, target) => { let left = 0, right = nums.length - 1; while (left <= right) { const mid = Math.floor((left + right) / 2); if (nums[mid] === target) return mid; if (nums[mid] < target) left = mid + 1; else right = mid - 1; } return left; };",No,No,O(log n),3
"const binarySearch = (arr, target) => { let left = 0, right = arr.length - 1; while (left <= right) { const mid = Math.floor((left + right) / 2); if (arr[mid] === target) return mid; else if (arr[mid] < target) left = mid + 1; else right = mid - 1; } return -1; };",No,No,O(log n),3
"const searchRange = (nums, target) => { const findLeft = (nums, target) => { let left = 0, right = nums.length - 1; while (left <= right) { const mid = Math.floor((left + right) / 2); if (nums[mid] < target) left = mid + 1; else right = mid - 1; } return left; }; const findRight = (nums, target) => { let left = 0, right = nums.length - 1; while (left <= right) { const mid = Math.floor((left + right) / 2); if (nums[mid] <= target) left = mid + 1; else right = mid - 1; } return right; }; const leftIndex = findLeft(nums, target); const rightIndex = findRight(nums, target); return leftIndex <= rightIndex ? [leftIndex, rightIndex] : [-1, -1]; };",No,No,O(log n),4
"const countPrimes = (n) => { const isPrime = new Array(n).fill(true); isPrime[0] = isPrime[1] = false; for (let i = 2; i * i < n; i++) { if (isPrime[i]) { for (let j = i * i; j < n; j += i) isPrime[j] = false; } } return isPrime.filter(Boolean).length; };",No,No,O(n log log n),4
"const reverseWords = (s) => { return s.split(' ').reverse().join(' '); };",No,No,O(n),3
"const canConstruct = (ransomNote, magazine) => { const count = {}; for (const char of magazine) count[char] = (count[char] || 0) + 1; for (const char of ransomNote) { if (!count[char]) return false; count[char]--; } return true; };",No,No,O(n + m),4
"const evaluate = (expression) => { const stack = []; const postfix = expression.split(' '); for (const token of postfix) { if (!isNaN(token)) stack.push(Number(token)); else { const b = stack.pop(), a = stack.pop(); stack.push(operate(a, b, token)); } } return stack[0]; }; const operate = (a, b, operator) => { switch (operator) { case '+': return a + b; case '-': return a - b; case '*': return a * b; case '/': return Math.trunc(a / b); } };",No,No,O(n),4
"const longestValidParentheses = (s) => { const stack = [-1]; let maxLength = 0; for (let i = 0; i < s.length; i++) { if (s[i] === '(') stack.push(i); else { stack.pop(); if (stack.length === 0) stack.push(i); else maxLength = Math.max(maxLength, i - stack[stack.length - 1]); } } return maxLength; };",No,No,O(n),4
"const hammingWeight = (n) => { let count = 0; while (n) { count += n & 1; n >>>= 1; } return count; };",No,No,O(1),3
"const singleNumber = (nums) => { return nums.reduce((acc, num) => acc ^ num, 0); };",No,No,O(n),3
"const firstUniqChar = (s) => { const count = {}; for (const char of s) count[char] = (count[char] || 0) + 1; for (let i = 0; i < s.length; i++) { if (count[s[i]] === 1) return i; } return -1; };",No,No,O(n),3
"const myAtoi = (s) => { const trimmed = s.trim(); if (!trimmed) return 0; const sign = trimmed[0] === '-' ? -1 : 1; const start = trimmed[0] === '-' || trimmed[0] === '+' ? 1 : 0; let num = 0; for (let i = start; i < trimmed.length; i++) { const digit = trimmed[i].charCodeAt(0) - '0'.charCodeAt(0); if (digit < 0 || digit > 9) break; num = num * 10 + digit; } return Math.max(Math.min(num * sign, 2147483647), -2147483648); };",No,No,O(n),4
"const maxArea = (height) => { let left = 0, right = height.length - 1; let max = 0; while (left < right) { max = Math.max(max, Math.min(height[left], height[right]) * (right - left)); if (height[left] < height[right]) left++; else right--; } return max; };",No,No,O(n),4
"const groupAnagrams = (strs) => { const map = {}; for (const str of strs) { const key = str.split('').sort().join(''); if (!map[key]) map[key] = []; map[key].push(str); } return Object.values(map); };",No,No,O(n * k log k),4
"const lengthOfLongestSubstring = (s) => { const charIndexMap = {}; let maxLength = 0, start = 0; for (let i = 0; i < s.length; i++) { if (charIndexMap[s[i]] !== undefined) start = Math.max(start, charIndexMap[s[i]] + 1); charIndexMap[s[i]] = i; maxLength = Math.max(maxLength, i - start + 1); } return maxLength; };",No,No,O(n),3
"const combine = (n, k) => { const result = []; const backtrack = (start, path) => { if (path.length === k) { result.push([...path]); return; } for (let i = start; i <= n; i++) { path.push(i); backtrack(i + 1, path); path.pop(); } }; backtrack(1, []); return result; };",No,No,O(nCk),4
"const largestRectangleArea = (heights) => { const stack = []; let maxArea = 0; heights.push(0); for (let i = 0; i < heights.length; i++) { while (stack.length && heights[i] < heights[stack[stack.length - 1]]) { const h = heights[stack.pop()]; const w = stack.length ? i - stack[stack.length - 1] - 1 : i; maxArea = Math.max(maxArea, h * w); } stack.push(i); } return maxArea; };",No,No,O(n),4
"const climbStairsWithVariableSteps = (n) => { const dp = new Array(n + 1).fill(0); dp[0] = 1; for (let i = 1; i <= n; i++) { for (let j = 1; j <= 2; j++) { if (i - j >= 0) dp[i] += dp[i - j]; } } return dp[n]; };",No,No,O(n),3
"const findDuplicate = (nums) => { let slow = nums[0], fast = nums[0]; do { slow = nums[slow]; fast = nums[nums[fast]]; } while (slow !== fast); let ptr1 = nums[0], ptr2 = slow; while (ptr1 !== ptr2) { ptr1 = nums[ptr1]; ptr2 = nums[ptr2]; } return ptr1; };",No,No,O(n),4
"const missingNumber = (nums) => { const n = nums.length; const totalSum = (n * (n + 1)) / 2; const arraySum = nums.reduce((acc, num) => acc + num, 0); return totalSum - arraySum; };",No,No,O(n),3
"const partitionLabels = (s) => { const lastIndex = {}; for (let i = 0; i < s.length; i++) lastIndex[s[i]] = i; const result = []; let anchor = 0, farthest = 0; for (let i = 0; i < s.length; i++) { farthest = Math.max(farthest, lastIndex[s[i]]); if (i === farthest) { result.push(i - anchor + 1); anchor = i + 1; } } return result; };",No,No,O(n),4
"const validPalindrome = (s) => { const isPalindrome = (str) => str === str.split('').reverse().join(''); for (let i = 0; i < s.length; i++) { const modified = s.slice(0, i) + s.slice(i + 1); if (isPalindrome(modified)) return true; } return false; };",No,No,O(n^2),4
"const findLongestWord = (s, d) => { let longest = ''; for (const word of d) { if (word.length > longest.length && isSubsequence(word, s)) longest = word; } return longest; }; const isSubsequence = (word, s) => { let j = 0; for (const char of s) { if (char === word[j]) j++; if (j === word.length) return true; } return false; };",No,No,O(n * m),4
"const longestCommonPrefix = (strs) => { if (!strs.length) return ''; let prefix = strs[0]; for (let i = 1; i < strs.length; i++) { while (strs[i].indexOf(prefix) !== 0) prefix = prefix.slice(0, -1); } return prefix; };",No,No,O(n * m),4
"const spiralOrder = (matrix) => { if (!matrix.length) return []; const result = []; let top = 0, bottom = matrix.length - 1, left = 0, right = matrix[0].length - 1; while (top <= bottom && left <= right) { for (let i = left; i <= right; i++) result.push(matrix[top][i]); top++; for (let i = top; i <= bottom; i++) result.push(matrix[i][right]); right--; if (top <= bottom) { for (let i = right; i >= left; i--) result.push(matrix[bottom][i]); bottom--; } if (left <= right) { for (let i = bottom; i >= top; i--) result.push(matrix[i][left]); left++; } } return result; };",No,No,O(n * m),4
"const searchInsert = (nums, target) => { let left = 0, right = nums.length - 1; while (left <= right) { const mid = Math.floor((left + right) / 2); if (nums[mid] === target) return mid; if (nums[mid] < target) left = mid + 1; else right = mid - 1; } return left; };",No,No,O(log n),3
"const binarySearch = (arr, target) => { let left = 0, right = arr.length - 1; while (left <= right) { const mid = Math.floor((left + right) / 2); if (arr[mid] === target) return mid; else if (arr[mid] < target) left = mid + 1; else right = mid - 1; } return -1; };",No,No,O(log n),3
"const searchRange = (nums, target) => { const findLeft = (nums, target) => { let left = 0, right = nums.length - 1; while (left <= right) { const mid = Math.floor((left + right) / 2); if (nums[mid] < target) left = mid + 1; else right = mid - 1; } return left; }; const findRight = (nums, target) => { let left = 0, right = nums.length - 1; while (left <= right) { const mid = Math.floor((left + right) / 2); if (nums[mid] <= target) left = mid + 1; else right = mid - 1; } return right; }; const leftIndex = findLeft(nums, target); const rightIndex = findRight(nums, target); return leftIndex <= rightIndex ? [leftIndex, rightIndex] : [-1, -1]; };",No,No,O(log n),4
"const countPrimes = (n) => { const isPrime = new Array(n).fill(true); isPrime[0] = isPrime[1] = false; for (let i = 2; i * i < n; i++) { if (isPrime[i]) { for (let j = i * i; j < n; j += i) isPrime[j] = false; } } return isPrime.filter(Boolean).length; };",No,No,O(n log log n),4
"const reverseWords = (s) => { return s.split(' ').reverse().join(' '); };",No,No,O(n),3
"const canConstruct = (ransomNote, magazine) => { const count = {}; for (const char of magazine) count[char] = (count[char] || 0) + 1; for (const char of ransomNote) { if (!count[char]) return false; count[char]--; } return true; };",No,No,O(n + m),4
"const evaluate = (expression) => { const stack = []; const postfix = expression.split(' '); for (const token of postfix) { if (!isNaN(token)) stack.push(Number(token)); else { const b = stack.pop(), a = stack.pop(); stack.push(operate(a, b, token)); } } return stack[0]; }; const operate = (a, b, operator) => { switch (operator) { case '+': return a + b; case '-': return a - b; case '*': return a * b; case '/': return Math.trunc(a / b); } };",No,No,O(n),4
"const longestValidParentheses = (s) => { const stack = [-1]; let maxLength = 0; for (let i = 0; i < s.length; i++) { if (s[i] === '(') stack.push(i); else { stack.pop(); if (stack.length === 0) stack.push(i); else maxLength = Math.max(maxLength, i - stack[stack.length - 1]); } } return maxLength; };",No,No,O(n),4
"const removeDuplicates = (nums) => { if (nums.length === 0) return 0; let i = 0; for (let j = 1; j < nums.length; j++) { if (nums[j] !== nums[i]) { i++; nums[i] = nums[j]; } } return i + 1; };",No,No,O(n),3
"const plusOne = (digits) => { for (let i = digits.length - 1; i >= 0; i--) { if (digits[i] < 9) { digits[i]++; return digits; } digits[i] = 0; } return [1, ...digits]; };",No,No,O(n),3
"const rotateArray = (nums, k) => { k %= nums.length; reverse(nums, 0, nums.length - 1); reverse(nums, 0, k - 1); reverse(nums, k, nums.length - 1); }; const reverse = (arr, start, end) => { while (start < end) { [arr[start], arr[end]] = [arr[end], arr[start]]; start++; end--; } };",No,No,O(n),4
"const intersection = (nums1, nums2) => { const set = new Set(nums1); return [...new Set(nums2.filter(num => set.has(num)))]; };",No,No,O(n + m),4
"const findKthLargest = (nums, k) => { return nums.sort((a, b) => b - a)[k - 1]; };",No,No,O(n log n),3
"const containsDuplicate = (nums) => { return new Set(nums).size !== nums.length; };",No,No,O(n),3
"const majorityElement = (nums) => { const count = {}; const half = nums.length / 2; for (const num of nums) { count[num] = (count[num] || 0) + 1; if (count[num] > half) return num; } };",No,No,O(n),4
"const maxSubArray = (nums) => { let maxSum = nums[0], currentSum = nums[0]; for (let i = 1; i < nums.length; i++) { currentSum = Math.max(nums[i], currentSum + nums[i]); maxSum = Math.max(maxSum, currentSum); } return maxSum; };",No,No,O(n),4
"const productExceptSelf = (nums) => { const result = new Array(nums.length).fill(1); let leftProduct = 1; for (let i = 0; i < nums.length; i++) { result[i] *= leftProduct; leftProduct *= nums[i]; } let rightProduct = 1; for (let i = nums.length - 1; i >= 0; i--) { result[i] *= rightProduct; rightProduct *= nums[i]; } return result; };",No,No,O(n),4
"const setZeroes = (matrix) => { const rows = new Set(), cols = new Set(); for (let i = 0; i < matrix.length; i++) { for (let j = 0; j < matrix[0].length; j++) { if (matrix[i][j] === 0) { rows.add(i); cols.add(j); } } } for (let i = 0; i < matrix.length; i++) { for (let j = 0; j < matrix[0].length; j++) { if (rows.has(i) || cols.has(j)) matrix[i][j] = 0; } } };",No,No,O(m * n),4
"const numIslands = (grid) => { if (!grid.length) return 0; const visited = new Set(); let count = 0; const directions = [[1, 0], [0, 1], [-1, 0], [0, -1]]; const dfs = (r, c) => { if (r < 0 || r >= grid.length || c < 0 || c >= grid[0].length || grid[r][c] === '0' || visited.has(`${r},${c}`)) return; visited.add(`${r},${c}`); for (const [dr, dc] of directions) dfs(r + dr, c + dc); }; for (let i = 0; i < grid.length; i++) { for (let j = 0; j < grid[0].length; j++) { if (grid[i][j] === '1' && !visited.has(`${i},${j}`)) { count++; dfs(i, j); } } } return count; };",No,No,O(m * n),4
"const coinChange = (coins, amount) => { const dp = new Array(amount + 1).fill(Infinity); dp[0] = 0; for (const coin of coins) { for (let i = coin; i <= amount; i++) { dp[i] = Math.min(dp[i], dp[i - coin] + 1); } } return dp[amount] === Infinity ? -1 : dp[amount]; };",No,No,O(n * amount),4
"const removeElement = (nums, val) => { let k = 0; for (let i = 0; i < nums.length; i++) { if (nums[i] !== val) nums[k++] = nums[i]; } return k; };",No,No,O(n),3
"const isValid = (s) => { const stack = []; const mapping = { ')': '(', '}': '{', ']': '[' }; for (const char of s) { if (char in mapping) { const topElement = stack.length === 0 ? '#' : stack.pop(); if (mapping[char] !== topElement) return false; } else stack.push(char); } return stack.length === 0; };",No,No,O(n),4
"const maxProfit = (prices) => { let minPrice = Infinity, maxProfit = 0; for (const price of prices) { if (price < minPrice) minPrice = price; else maxProfit = Math.max(maxProfit, price - minPrice); } return maxProfit; };",No,No,O(n),4
"const twoSum = (nums, target) => { const map = new Map(); for (let i = 0; i < nums.length; i++) { const complement = target - nums[i]; if (map.has(complement)) return [map.get(complement), i]; map.set(nums[i], i); } };",No,No,O(n),4
"const validAnagram = (s, t) => { if (s.length !== t.length) return false; const count = {}; for (const char of s) count[char] = (count[char] || 0) + 1; for (const char of t) { if (!count[char]) return false; count[char]--; } return true; };",No,No,O(n),3
"const isPalindrome = (s) => { const cleaned = s.replace(/[^a-z0-9]/gi, '').toLowerCase(); return cleaned === cleaned.split('').reverse().join(''); };",No,No,O(n),3
"const jump = (nums) => { let jumps = 0, currentEnd = 0, farthest = 0; for (let i = 0; i < nums.length - 1; i++) { farthest = Math.max(farthest, i + nums[i]); if (i === currentEnd) { jumps++; currentEnd = farthest; } } return jumps; };",No,No,O(n),4
"const combinationSum = (candidates, target) => { const result = []; const backtrack = (start, path, target) => { if (target === 0) { result.push([...path]); return; } for (let i = start; i < candidates.length; i++) { if (candidates[i] > target) continue; path.push(candidates[i]); backtrack(i, path, target - candidates[i]); path.pop(); } }; backtrack(0, [], target); return result; };",No,No,O(n * target),4
"const findPeakElement = (nums) => { const binarySearch = (left, right) => { if (left === right) return left; const mid = Math.floor((left + right) / 2); if (nums[mid] > nums[mid + 1]) return binarySearch(left, mid); return binarySearch(mid + 1, right); }; return binarySearch(0, nums.length - 1); };",No,No,O(log n),4
"const minMeetingRooms = (intervals) => { if (intervals.length === 0) return 0; const startTimes = intervals.map(interval => interval[0]).sort((a, b) => a - b); const endTimes = intervals.map(interval => interval[1]).sort((a, b) => a - b); let rooms = 0, endIndex = 0; for (let startIndex = 0; startIndex < startTimes.length; startIndex++) { if (startTimes[startIndex] < endTimes[endIndex]) rooms++; else endIndex++; } return rooms; };",No,No,O(n log n),4
"const groupAnagrams = (strs) => { const map = {}; for (const str of strs) { const key = str.split('').sort().join(''); if (!map[key]) map[key] = []; map[key].push(str); } return Object.values(map); };",No,No,O(nk log k),4
"const floodFill = (image, sr, sc, newColor) => { const originalColor = image[sr][sc]; if (originalColor === newColor) return image; const dfs = (r, c) => { if (r < 0 || r >= image.length || c < 0 || c >= image[0].length || image[r][c] !== originalColor) return; image[r][c] = newColor; dfs(r + 1, c); dfs(r - 1, c); dfs(r, c + 1); dfs(r, c - 1); }; dfs(sr, sc); return image; };",No,No,O(m * n),4
"const permute = (nums) => { const result = []; const backtrack = (start) => { if (start === nums.length) result.push([...nums]); for (let i = start; i < nums.length; i++) { [nums[start], nums[i]] = [nums[i], nums[start]]; backtrack(start + 1); [nums[start], nums[i]] = [nums[i], nums[start]]; } }; backtrack(0); return result; };",No,No,O(n!),4
"const uniquePaths = (m, n) => { const dp = Array.from({ length: m }, () => Array(n).fill(1)); for (let i = 1; i < m; i++) { for (let j = 1; j < n; j++) { dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } return dp[m - 1][n - 1]; };",No,No,O(m * n),4
"const climbStairs = (n) => { if (n <= 1) return 1; const dp = [1, 1]; for (let i = 2; i <= n; i++) { dp[i] = dp[i - 1] + dp[i - 2]; } return dp[n]; };",No,No,O(n),3
"const searchMatrix = (matrix, target) => { if (!matrix.length || !matrix[0].length) return false; let left = 0, right = matrix.length * matrix[0].length - 1; while (left <= right) { const mid = Math.floor((left + right) / 2); const midValue = matrix[Math.floor(mid / matrix[0].length)][mid % matrix[0].length]; if (midValue === target) return true; else if (midValue < target) left = mid + 1; else right = mid - 1; } return false; };",No,No,O(log m + n),4
"const canJump = (nums) => { let farthest = 0; for (let i = 0; i < nums.length; i++) { if (i > farthest) return false; farthest = Math.max(farthest, i + nums[i]); } return true; };",No,No,O(n),4
"const longestCommonPrefix = (strs) => { if (!strs.length) return ''; let prefix = strs[0]; for (let i = 1; i < strs.length; i++) { while (strs[i].indexOf(prefix) !== 0) prefix = prefix.substring(0, prefix.length - 1); } return prefix; };",No,No,O(n * m),4
"const longestSubstr = (s) => { const set = new Set(); let left = 0, maxLength = 0; for (let right = 0; right < s.length; right++) { while (set.has(s[right])) set.delete(s[left++]); set.add(s[right]); maxLength = Math.max(maxLength, right - left + 1); } return maxLength; };",No,No,O(n),4
"const isPowerOfTwo = (n) => { return n > 0 && (n & (n - 1)) === 0; };",No,No,O(1),3
"const countPrimes = (n) => { if (n <= 2) return 0; const isPrime = new Array(n).fill(true); isPrime[0] = isPrime[1] = false; for (let i = 2; i * i < n; i++) { if (isPrime[i]) { for (let j = i * i; j < n; j += i) isPrime[j] = false; } } return isPrime.filter(Boolean).length; };",No,No,O(n log log n),4
"const validParentheses = (s) => { const stack = []; const mapping = { '(': ')', '{': '}', '[': ']' }; for (const char of s) { if (mapping[char]) stack.push(char); else if (stack.length === 0 || mapping[stack.pop()] !== char) return false; } return stack.length === 0; };",No,No,O(n),4
"const longestSubstringKDistinct = (s, k) => { const map = new Map(); let left = 0, maxLength = 0; for (let right = 0; right < s.length; right++) { map.set(s[right], (map.get(s[right]) || 0) + 1); while (map.size > k) { map.set(s[left], map.get(s[left]) - 1); if (map.get(s[left]) === 0) map.delete(s[left]); left++; } maxLength = Math.max(maxLength, right - left + 1); } return maxLength; };",No,No,O(n),4
"const minWindow = (s, t) => { const mapT = new Map(); for (const char of t) mapT.set(char, (mapT.get(char) || 0) + 1); let left = 0, right = 0, minLength = Infinity, minLeft = 0, required = mapT.size, formed = 0, windowCounts = new Map(); while (right < s.length) { const char = s[right]; windowCounts.set(char, (windowCounts.get(char) || 0) + 1); if (mapT.has(char) && windowCounts.get(char) === mapT.get(char)) formed++; while (left <= right && formed === required) { if (right - left + 1 < minLength) { minLength = right - left + 1; minLeft = left; } windowCounts.set(s[left], windowCounts.get(s[left]) - 1); if (mapT.has(s[left]) && windowCounts.get(s[left]) < mapT.get(s[left])) formed--; left++; } right++; } return minLength === Infinity ? "" : s.substring(minLeft, minLeft + minLength); };",No,No,O(n),4
"const topKFrequent = (nums, k) => { const freqMap = new Map(); for (const num of nums) freqMap.set(num, (freqMap.get(num) || 0) + 1); return [...freqMap.entries()].sort((a, b) => b[1] - a[1]).slice(0, k).map(([num]) => num); };",No,No,O(n log n),4
"const findMin = (nums) => { let left = 0, right = nums.length - 1; while (left < right) { const mid = Math.floor((left + right) / 2); if (nums[mid] > nums[right]) left = mid + 1; else right = mid; } return nums[left]; };",No,No,O(log n),4
"const mergeKLists = (lists) => { const merge = (l1, l2) => { let dummy = new ListNode(0), current = dummy; while (l1 && l2) { if (l1.val < l2.val) { current.next = l1; l1 = l1.next; } else { current.next = l2; l2 = l2.next; } current = current.next; } current.next = l1 || l2; return dummy.next; }; return lists.reduce((a, b) => merge(a, b)); };",No,No,O(n log k),4
"const deleteNode = (node) => { node.val = node.next.val; node.next = node.next.next; };",No,No,O(1),3
"const insertNode = (head, val) => { const newNode = new ListNode(val); if (!head) return newNode; let current = head; while (current.next) current = current.next; current.next = newNode; return head; };",No,No,O(n),4
"const reverseList = (head) => { let prev = null; while (head) { const next = head.next; head.next = prev; prev = head; head = next; } return prev; };",No,No,O(n),4
"const hasCycle = (head) => { let slow = head, fast = head; while (fast && fast.next) { slow = slow.next; fast = fast.next.next; if (slow === fast) return true; } return false; };",No,No,O(n),4
"const getIntersectionNode = (headA, headB) => { let pA = headA, pB = headB; while (pA !== pB) { pA = pA ? pA.next : headB; pB = pB ? pB.next : headA; } return pA; };",No,No,O(n),4
"const convertBST = (root) => { const traverse = (node, sum) => { if (!node) return sum; node.val += traverse(node.right, sum); return traverse(node.left, node.val); }; traverse(root, 0); return root; };",No,No,O(n),4
"const diameterOfBinaryTree = (root) => { let max = 0; const depth = (node) => { if (!node) return 0; const left = depth(node.left), right = depth(node.right); max = Math.max(max, left + right); return Math.max(left, right) + 1; }; depth(root); return max; };",No,No,O(n),4
"const levelOrder = (root) => { if (!root) return []; const result = []; const queue = [root]; while (queue.length) { const level = []; const length = queue.length; for (let i = 0; i < length; i++) { const node = queue.shift(); level.push(node.val); if (node.left) queue.push(node.left); if (node.right) queue.push(node.right); } result.push(level); } return result; };",No,No,O(n),4
"const invertTree = (root) => { if (!root) return null; [root.left, root.right] = [root.right, root.left]; invertTree(root.left); invertTree(root.right); return root; };",No,No,O(n),4
"const maxDepth = (root) => { if (!root) return 0; return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1; };",No,No,O(n),4
"const isSymmetric = (root) => { const isMirror = (left, right) => { if (!left && !right) return true; if (!left || !right) return false; return left.val === right.val && isMirror(left.left, right.right) && isMirror(left.right, right.left); }; return isMirror(root, root); };",No,No,O(n),4
"const findMode = (root) => { const countMap = new Map(); const inorder = (node) => { if (!node) return; countMap.set(node.val, (countMap.get(node.val) || 0) + 1); inorder(node.left); inorder(node.right); }; inorder(root); const maxCount = Math.max(...countMap.values()); return [...countMap.entries()].filter(([_, count]) => count === maxCount).map(([val]) => val); };",No,No,O(n),4
"const lowestCommonAncestor = (root, p, q) => { if (!root || root === p || root === q) return root; const left = lowestCommonAncestor(root.left, p, q), right = lowestCommonAncestor(root.right, p, q); return left && right ? root : left || right; };",No,No,O(n),4
"const mergeTwoLists = (l1, l2) => { const dummy = new ListNode(0), current = dummy; while (l1 && l2) { if (l1.val < l2.val) { current.next = l1; l1 = l1.next; } else { current.next = l2; l2 = l2.next; } current = current.next; } current.next = l1 || l2; return dummy.next; };",No,No,O(n),4
"const sumNumbers = (root) => { let total = 0; const dfs = (node, currentNumber) => { if (!node) return; currentNumber = currentNumber * 10 + node.val; if (!node.left && !node.right) total += currentNumber; dfs(node.left, currentNumber); dfs(node.right, currentNumber); }; dfs(root, 0); return total; };",No,No,O(n),4
"const maximumBinaryTree = (nums) => { const buildTree = (left, right) => { if (left > right) return null; let maxIndex = left; for (let i = left; i <= right; i++) { if (nums[i] > nums[maxIndex]) maxIndex = i; } const root = new TreeNode(nums[maxIndex]); root.left = buildTree(left, maxIndex - 1); root.right = buildTree(maxIndex + 1, right); return root; }; return buildTree(0, nums.length - 1); };",No,No,O(n),4
"const removeNthFromEnd = (head, n) => { let dummy = new ListNode(0, head), first = dummy, second = dummy; for (let i = 0; i <= n; i++) first = first.next; while (first) { first = first.next; second = second.next; } second.next = second.next.next; return dummy.next; };",No,No,O(n),4
"const isValidBST = (root) => { const helper = (node, lower = -Infinity, upper = Infinity) => { if (!node) return true; if (node.val <= lower || node.val >= upper) return false; return helper(node.left, lower, node.val) && helper(node.right, node.val, upper); }; return helper(root); };",No,No,O(n),4
"const deleteDuplicates = (head) => { let current = head; while (current && current.next) { if (current.val === current.next.val) { current.next = current.next.next; } else { current = current.next; } } return head; };",No,No,O(n),4
"const isSubtree = (root, subRoot) => { const isSameTree = (s, t) => { if (!s && !t) return true; if (!s || !t) return false; return s.val === t.val && isSameTree(s.left, t.left) && isSameTree(s.right, t.right); }; if (!root) return false; return isSameTree(root, subRoot) || isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot); };",No,No,O(n),4
"const serialize = (root) => { const result = []; const dfs = (node) => { if (!node) { result.push('null'); return; } result.push(node.val); dfs(node.left); dfs(node.right); }; dfs(root); return result.join(','); };",No,No,O(n),4
"const deserialize = (data) => { const arr = data.split(','); const buildTree = () => { const val = arr.shift(); if (val === 'null') return null; const node = new TreeNode(Number(val)); node.left = buildTree(); node.right = buildTree(); return node; }; return buildTree(); };",No,No,O(n),4
"const pathSum = (root, sum) => { const dfs = (node, currentSum) => { if (!node) return 0; currentSum += node.val; return (currentSum === sum ? 1 : 0) + dfs(node.left, currentSum) + dfs(node.right, currentSum); }; return dfs(root, 0); };",No,No,O(n),4
"const constructMaximumBinaryTree = (nums) => { const buildTree = (nums) => { if (!nums.length) return null; const maxIndex = nums.indexOf(Math.max(...nums)); const root = new TreeNode(nums[maxIndex]); root.left = buildTree(nums.slice(0, maxIndex)); root.right = buildTree(nums.slice(maxIndex + 1)); return root; }; return buildTree(nums); };",No,No,O(n),4
"const binaryTreePaths = (root) => { const paths = []; const dfs = (node, path) => { if (!node) return; path += node.val + '->'; if (!node.left && !node.right) paths.push(path.slice(0, -2)); dfs(node.left, path); dfs(node.right, path); }; dfs(root, ''); return paths; };",No,No,O(n),4
"const zigzagLevelOrder = (root) => { const result = []; const traverse = (node, level) => { if (!node) return; if (!result[level]) result[level] = []; if (level % 2 === 0) result[level].push(node.val); else result[level].unshift(node.val); traverse(node.left, level + 1); traverse(node.right, level + 1); }; traverse(root, 0); return result; };",No,No,O(n),4
"const findBottomLeftValue = (root) => { let maxDepth = -1, bottomLeftValue; const dfs = (node, depth) => { if (!node) return; if (depth > maxDepth) { maxDepth = depth; bottomLeftValue = node.val; } dfs(node.left, depth + 1); dfs(node.right, depth + 1); }; dfs(root, 0); return bottomLeftValue; };",No,No,O(n),4
"const sumOfLeftLeaves = (root) => { if (!root) return 0; if (root.left && !root.left.left && !root.left.right) return root.left.val + sumOfLeftLeaves(root.right); return sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right); };",No,No,O(n),4
"const findTilt = (root) => { let tilt = 0; const dfs = (node) => { if (!node) return 0; const left = dfs(node.left), right = dfs(node.right); tilt += Math.abs(left - right); return left + right + node.val; }; dfs(root); return tilt; };",No,No,O(n),4
"const maxPathSum = (root) => { let maxSum = -Infinity; const dfs = (node) => { if (!node) return 0; const left = Math.max(dfs(node.left), 0), right = Math.max(dfs(node.right), 0); maxSum = Math.max(maxSum, left + right + node.val); return node.val + Math.max(left, right); }; dfs(root); return maxSum; };",No,No,O(n),4
"const rob = (root) => { const dfs = (node) => { if (!node) return [0, 0]; const left = dfs(node.left), right = dfs(node.right); return [Math.max(left[0], left[1]) + Math.max(right[0], right[1]), left[0] + right[0] + node.val]; }; return Math.max(...dfs(root)); };",No,No,O(n),4
"const getMinimumDifference = (root) => { let prev = null, minDiff = Infinity; const inorder = (node) => { if (!node) return; inorder(node.left); if (prev !== null) minDiff = Math.min(minDiff, node.val - prev); prev = node.val; inorder(node.right); }; inorder(root); return minDiff; };",No,No,O(n),4
"const kthSmallest = (root, k) => { const stack = []; let count = 0; while (true) { while (root) { stack.push(root); root = root.left; } root = stack.pop(); if (++count === k) return root.val; root = root.right; } };",No,No,O(n),4
"const uniquePaths = (m, n) => { const dp = Array.from({ length: m }, () => Array(n).fill(1)); for (let i = 1; i < m; i++) { for (let j = 1; j < n; j++) { dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } return dp[m - 1][n - 1]; };",No,No,O(m*n),4
"const uniquePathsWithObstacles = (obstacleGrid) => { const m = obstacleGrid.length, n = obstacleGrid[0].length; if (obstacleGrid[0][0] === 1 || obstacleGrid[m - 1][n - 1] === 1) return 0; const dp = Array.from({ length: m }, () => Array(n).fill(0)); dp[0][0] = 1; for (let i = 0; i < m; i++) { for (let j = 0; j < n; j++) { if (obstacleGrid[i][j] === 1) continue; if (i > 0) dp[i][j] += dp[i - 1][j]; if (j > 0) dp[i][j] += dp[i][j - 1]; } } return dp[m - 1][n - 1]; };",No,No,O(m*n),4
"const canJump = (nums) => { let maxReach = 0; for (let i = 0; i < nums.length; i++) { if (i > maxReach) return false; maxReach = Math.max(maxReach, i + nums[i]); } return true; };",No,No,O(n),4
"const jump = (nums) => { let jumps = 0, currentEnd = 0, farthest = 0; for (let i = 0; i < nums.length - 1; i++) { farthest = Math.max(farthest, i + nums[i]); if (i === currentEnd) { jumps++; currentEnd = farthest; } } return jumps; };",No,No,O(n),4
"const lengthOfLIS = (nums) => { const dp = []; for (let num of nums) { let left = 0, right = dp.length; while (left < right) { const mid = Math.floor((left + right) / 2); if (dp[mid] < num) left = mid + 1; else right = mid; } dp[left] = num; } return dp.length; };",No,No,O(n log n),4
"const maxProfit = (prices) => { let minPrice = Infinity, maxProfit = 0; for (let price of prices) { if (price < minPrice) minPrice = price; else maxProfit = Math.max(maxProfit, price - minPrice); } return maxProfit; };",No,No,O(n),4
"const rotate = (nums, k) => { k %= nums.length; reverse(nums, 0, nums.length - 1); reverse(nums, 0, k - 1); reverse(nums, k, nums.length - 1); }; const reverse = (arr, start, end) => { while (start < end) { [arr[start], arr[end]] = [arr[end], arr[start]]; start++; end--; } };",No,No,O(n),4
"const threeSum = (nums) => { nums.sort((a, b) => a - b); const result = []; for (let i = 0; i < nums.length - 2; i++) { if (i > 0 && nums[i] === nums[i - 1]) continue; let left = i + 1, right = nums.length - 1; while (left < right) { const sum = nums[i] + nums[left] + nums[right]; if (sum === 0) { result.push([nums[i], nums[left], nums[right]]); while (left < right && nums[left] === nums[left + 1]) left++; while (left < right && nums[right] === nums[right - 1]) right--; left++; right--; } else if (sum < 0) left++; else right--; } } return result; };",No,No,O(n^2),4
"const fourSum = (nums, target) => { nums.sort((a, b) => a - b); const result = []; for (let i = 0; i < nums.length - 3; i++) { if (i > 0 && nums[i] === nums[i - 1]) continue; for (let j = i + 1; j < nums.length - 2; j++) { if (j > i + 1 && nums[j] === nums[j - 1]) continue; let left = j + 1, right = nums.length - 1; while (left < right) { const sum = nums[i] + nums[j] + nums[left] + nums[right]; if (sum === target) { result.push([nums[i], nums[j], nums[left], nums[right]]); while (left < right && nums[left] === nums[left + 1]) left++; while (left < right && nums[right] === nums[right - 1]) right--; left++; right--; } else if (sum < target) left++; else right--; } } } return result; };",No,No,O(n^3),4
"const validParentheses = (s) => { const stack = []; const map = { '(': ')', '{': '}', '[': ']' }; for (let char of s) { if (map[char]) stack.push(map[char]); else if (stack.pop() !== char) return false; } return stack.length === 0; };",No,No,O(n),4
"const groupAnagrams = (strs) => { const map = {}; for (let str of strs) { const sortedStr = str.split('').sort().join(''); if (!map[sortedStr]) map[sortedStr] = []; map[sortedStr].push(str); } return Object.values(map); };",No,No,O(nk log k),4
"const merge = (intervals) => { intervals.sort((a, b) => a[0] - b[0]); const merged = []; for (let interval of intervals) { if (!merged.length || merged[merged.length - 1][1] < interval[0]) merged.push(interval); else merged[merged.length - 1][1] = Math.max(merged[merged.length - 1][1], interval[1]); } return merged; };",No,No,O(n log n),4
"const canConstruct = (ransomNote, magazine) => { const map = new Array(26).fill(0); for (let char of magazine) map[char.charCodeAt(0) - 97]++; for (let char of ransomNote) { if (--map[char.charCodeAt(0) - 97] < 0) return false; } return true; };",No,No,O(n + m),4
"const lengthOfLongestSubstring = (s) => { const map = new Map(); let left = 0, maxLength = 0; for (let right = 0; right < s.length; right++) { if (map.has(s[right])) left = Math.max(left, map.get(s[right]) + 1); map.set(s[right], right); maxLength = Math.max(maxLength, right - left + 1); } return maxLength; };",No,No,O(n),4
"const longestCommonPrefix = (strs) => { if (!strs.length) return ''; let prefix = strs[0]; for (let i = 1; i < strs.length; i++) { while (strs[i].indexOf(prefix) !== 0) prefix = prefix.slice(0, -1); } return prefix; };",No,No,O(n * m),4
"const climbStairs = (n) => { const dp = [1, 1]; for (let i = 2; i <= n; i++) dp[i] = dp[i - 1] + dp[i - 2]; return dp[n]; };",No,No,O(n),4
"const combinationSum = (candidates, target) => { const result = []; const backtrack = (start, target, path) => { if (target < 0) return; if (target === 0) result.push([...path]); for (let i = start; i < candidates.length; i++) { path.push(candidates[i]); backtrack(i, target - candidates[i], path); path.pop(); } }; backtrack(0, target, []); return result; };",No,No,O(n^target),4
"const findDuplicates = (nums) => { const result = []; for (let i = 0; i < nums.length; i++) { const index = Math.abs(nums[i]) - 1; if (nums[index] < 0) result.push(index + 1); nums[index] = -nums[index]; } return result; };",No,No,O(n),4
"const findKthLargest = (nums, k) => { const quickSelect = (left, right) => { const pivot = nums[right]; let pIndex = left; for (let i = left; i < right; i++) { if (nums[i] > pivot) { [nums[i], nums[pIndex]] = [nums[pIndex], nums[i]]; pIndex++; } } [nums[pIndex], nums[right]] = [nums[right], nums[pIndex]]; return pIndex; }; let left = 0, right = nums.length - 1; while (true) { const pIndex = quickSelect(left, right); if (pIndex === k - 1) return nums[pIndex]; else if (pIndex < k - 1) left = pIndex + 1; else right = pIndex - 1; } };",No,No,O(n),4
"const letterCombinations = (digits) => { if (!digits) return []; const map = { 2: 'abc', 3: 'def', 4: 'ghi', 5: 'jkl', 6: 'mno', 7: 'pqrs', 8: 'tuv', 9: 'wxyz' }; const result = []; const backtrack = (index, path) => { if (index === digits.length) result.push(path.join('')); else { for (let char of map[digits[index]]) { path.push(char); backtrack(index + 1, path); path.pop(); } } }; backtrack(0, []); return result; };",No,No,O(3^n),4
"const permute = (nums) => { const result = []; const backtrack = (path) => { if (path.length === nums.length) result.push([...path]); for (let num of nums) { if (path.includes(num)) continue; path.push(num); backtrack(path); path.pop(); } }; backtrack([]); return result; };",No,No,O(n!),4
"const generateParenthesis = (n) => { const result = []; const backtrack = (left, right, path) => { if (left === 0 && right === 0) result.push(path.join('')); if (left > 0) { path.push('('); backtrack(left - 1, right, path); path.pop(); } if (right > left) { path.push(')'); backtrack(left, right - 1, path); path.pop(); } }; backtrack(n, n, []); return result; };",No,No,O(4^n/sqrt(n)),4
"const isValidSudoku = (board) => { const rows = Array(9).fill(0).map(() => new Set()), cols = Array(9).fill(0).map(() => new Set()), boxes = Array(9).fill(0).map(() => new Set()); for (let r = 0; r < 9; r++) { for (let c = 0; c < 9; c++) { if (board[r][c] !== '.') { const num = board[r][c]; const boxIndex = Math.floor(r / 3) * 3 + Math.floor(c / 3); if (rows[r].has(num) || cols[c].has(num) || boxes[boxIndex].has(num)) return false; rows[r].add(num); cols[c].add(num); boxes[boxIndex].add(num); } } } return true; };",No,No,O(1),4
"const wordSearch = (board, word) => { const dfs = (r, c, index) => { if (index === word.length) return true; if (r < 0 || c < 0 || r >= board.length || c >= board[0].length || board[r][c] !== word[index]) return false; const temp = board[r][c]; board[r][c] = '#'; const found = dfs(r + 1, c, index + 1) || dfs(r - 1, c, index + 1) || dfs(r, c + 1, index + 1) || dfs(r, c - 1, index + 1); board[r][c] = temp; return found; }; for (let r = 0; r < board.length; r++) { for (let c = 0; c < board[0].length; c++) { if (dfs(r, c, 0)) return true; } } return false; };",No,No,O(m*n*4^l),4
"const maxAreaOfIsland = (grid) => { const dfs = (r, c) => { if (r < 0 || c < 0 || r >= grid.length || c >= grid[0].length || grid[r][c] === 0) return 0; grid[r][c] = 0; return 1 + dfs(r + 1, c) + dfs(r - 1, c) + dfs(r, c + 1) + dfs(r, c - 1); }; let maxArea = 0; for (let r = 0; r < grid.length; r++) { for (let c = 0; c < grid[0].length; c++) { maxArea = Math.max(maxArea, dfs(r, c)); } } return maxArea; };",No,No,O(m*n),4
"const wordBreak = (s, wordDict) => { const dp = Array(s.length + 1).fill(false); dp[0] = true; for (let i = 1; i <= s.length; i++) { for (let word of wordDict) { if (dp[i - word.length] && s.slice(i - word.length, i) === word) { dp[i] = true; break; } } } return dp[s.length]; };",No,No,O(n^2*m),4
"const setZeroes = (matrix) => { const rows = new Set(), cols = new Set(); for (let r = 0; r < matrix.length; r++) { for (let c = 0; c < matrix[0].length; c++) { if (matrix[r][c] === 0) { rows.add(r); cols.add(c); } } } for (let r of rows) for (let c of cols) matrix[r].fill(0, 0, matrix[0].length); };",No,No,O(m*n),4
"const findMin = (nums) => { let left = 0, right = nums.length - 1; while (left < right) { const mid = Math.floor((left + right) / 2); if (nums[mid] > nums[right]) left = mid + 1; else right = mid; } return nums[left]; };",No,No,O(log n),4
"const findPeakElement = (nums) => { let left = 0, right = nums.length - 1; while (left < right) { const mid = Math.floor((left + right) / 2); if (nums[mid] < nums[mid + 1]) left = mid + 1; else right = mid; } return left; };",No,No,O(log n),4
"const maxSubArray = (nums) => { let maxSum = nums[0], currentSum = nums[0]; for (let i = 1; i < nums.length; i++) { currentSum = Math.max(nums[i], currentSum + nums[i]); maxSum = Math.max(maxSum, currentSum); } return maxSum; };",No,No,O(n),4
"const longestPalindrome = (s) => { if (s.length < 1) return ''; let start = 0, end = 0; const expandFromCenter = (left, right) => { while (left >= 0 && right < s.length && s[left] === s[right]) { left--; right++; } return right - left - 1; }; for (let i = 0; i < s.length; i++) { const len1 = expandFromCenter(i, i); const len2 = expandFromCenter(i, i + 1); const maxLen = Math.max(len1, len2); if (maxLen > end - start) { start = i - Math.floor((maxLen - 1) / 2); end = i + Math.floor(maxLen / 2); } } return s.slice(start, end + 1); };",No,No,O(n^2),4
"const trap = (height) => { const n = height.length; if (n === 0) return 0; const leftMax = new Array(n).fill(0), rightMax = new Array(n).fill(0); leftMax[0] = height[0]; for (let i = 1; i < n; i++) leftMax[i] = Math.max(leftMax[i - 1], height[i]); rightMax[n - 1] = height[n - 1]; for (let i = n - 2; i >= 0; i--) rightMax[i] = Math.max(rightMax[i + 1], height[i]); let water = 0; for (let i = 0; i < n; i++) water += Math.min(leftMax[i], rightMax[i]) - height[i]; return water; };",No,No,O(n),4
"const canFinish = (numCourses, prerequisites) => { const graph = Array.from({ length: numCourses }, () => []); const indegree = new Array(numCourses).fill(0); for (let [course, prereq] of prerequisites) { graph[prereq].push(course); indegree[course]++; } const queue = []; for (let i = 0; i < numCourses; i++) if (indegree[i] === 0) queue.push(i); let count = 0; while (queue.length) { const course = queue.shift(); count++; for (let nextCourse of graph[course]) { if (--indegree[nextCourse] === 0) queue.push(nextCourse); } } return count === numCourses; };",No,No,O(V + E),4
"const leastInterval = (tasks, n) => { const count = new Array(26).fill(0); for (let task of tasks) count[task.charCodeAt(0) - 65]++; count.sort((a, b) => b - a); const maxCount = count[0]; let idleSlots = (maxCount - 1) * n; for (let i = 1; i < count.length; i++) idleSlots -= Math.min(maxCount - 1, count[i]); return Math.max(tasks.length, tasks.length + idleSlots); };",No,No,O(n),4
"const rotateImage = (matrix) => { const n = matrix.length; for (let layer = 0; layer < Math.floor(n / 2); layer++) { const first = layer; const last = n - 1 - layer; for (let i = first; i < last; i++) { const offset = i - first; const top = matrix[first][i]; matrix[first][i] = matrix[last - offset][first]; matrix[last - offset][first] = matrix[last][last - offset]; matrix[last][last - offset] = matrix[i][last]; matrix[i][last] = top; } } };",No,No,O(n^2),4
"const maxProfit = (prices) => { let minPrice = Infinity, maxProfit = 0; for (let price of prices) { if (price < minPrice) minPrice = price; else maxProfit = Math.max(maxProfit, price - minPrice); } return maxProfit; };",No,No,O(n),4
"const longestCommonSubsequence = (text1, text2) => { const dp = Array(text1.length + 1).fill(0).map(() => Array(text2.length + 1).fill(0)); for (let i = 1; i <= text1.length; i++) { for (let j = 1; j <= text2.length; j++) { if (text1[i - 1] === text2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1; else dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]); } } return dp[text1.length][text2.length]; };",No,No,O(m*n),4
"const searchInsert = (nums, target) => { let left = 0, right = nums.length - 1; while (left <= right) { const mid = Math.floor((left + right) / 2); if (nums[mid] === target) return mid; if (nums[mid] < target) left = mid + 1; else right = mid - 1; } return left; };",No,No,O(log n),4
"const uniquePaths = (m, n) => { const dp = Array(m).fill(0).map(() => Array(n).fill(1)); for (let i = 1; i < m; i++) { for (let j = 1; j < n; j++) { dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } return dp[m - 1][n - 1]; };",No,No,O(m*n),4
"const minimumTotal = (triangle) => { for (let row = triangle.length - 2; row >= 0; row--) { for (let col = 0; col <= row; col++) { triangle[row][col] += Math.min(triangle[row + 1][col], triangle[row + 1][col + 1]); } } return triangle[0][0]; };",No,No,O(n^2),4
"const jump = (nums) => { let jumps = 0, currentEnd = 0, farthest = 0; for (let i = 0; i < nums.length - 1; i++) { farthest = Math.max(farthest, i + nums[i]); if (i === currentEnd) { jumps++; currentEnd = farthest; } } return jumps; };",No,No,O(n),4
"const longestSubstring = (s, k) => { const map = {}; let left = 0, maxLength = 0; for (let right = 0; right < s.length; right++) { map[s[right]] = (map[s[right]] || 0) + 1; while (Object.keys(map).length > k) { map[s[left]]--; if (map[s[left]] === 0) delete map[s[left]]; left++; } maxLength = Math.max(maxLength, right - left + 1); } return maxLength; };",No,No,O(n),4
"const groupAnagrams = (strs) => { const map = {}; for (let str of strs) { const sortedStr = str.split('').sort().join(''); if (!map[sortedStr]) map[sortedStr] = []; map[sortedStr].push(str); } return Object.values(map); };",No,No,O(n*k log k),4
"const mergeKLists = (lists) => { const mergeTwoLists = (l1, l2) => { let dummy = new ListNode(0), current = dummy; while (l1 && l2) { if (l1.val < l2.val) { current.next = l1; l1 = l1.next; } else { current.next = l2; l2 = l2.next; } current = current.next; } current.next = l1 || l2; return dummy.next; }; return lists.reduce((acc, list) => mergeTwoLists(acc, list)); };",No,No,O(n log k),4
"const kClosest = (points, k) => { return points.sort((a, b) => (a[0] ** 2 + a[1] ** 2) - (b[0] ** 2 + b[1] ** 2)).slice(0, k); };",No,No,O(n log n),4
"const topKFrequent = (nums, k) => { const freqMap = new Map(); for (let num of nums) { freqMap.set(num, (freqMap.get(num) || 0) + 1); } return Array.from(freqMap).sort((a, b) => b[1] - a[1]).slice(0, k).map((item) => item[0]); };",No,No,O(n log n),4
"const leastInterval = (tasks, n) => { const count = new Array(26).fill(0); for (let task of tasks) count[task.charCodeAt(0) - 65]++; count.sort((a, b) => b - a); const maxCount = count[0]; let idleSlots = (maxCount - 1) * n; for (let i = 1; i < count.length; i++) idleSlots -= Math.min(maxCount - 1, count[i]); return Math.max(tasks.length, tasks.length + idleSlots); };",No,No,O(n),4
"const topKFrequentWords = (words, k) => { const freqMap = new Map(); for (let word of words) { freqMap.set(word, (freqMap.get(word) || 0) + 1); } return Array.from(freqMap).sort((a, b) => b[1] - a[1] || a[0].localeCompare(b[0])).slice(0, k).map((item) => item[0]); };",No,No,O(n log n),4
"const findDuplicate = (nums) => { let slow = nums[0], fast = nums[0]; while (true) { slow = nums[slow]; fast = nums[nums[fast]]; if (slow === fast) break; } let finder = nums[0]; while (finder !== slow) { finder = nums[finder]; slow = nums[slow]; } return finder; };",No,No,O(n),4
"const canConstruct = (ransomNote, magazine) => { const count = {}; for (let char of magazine) { count[char] = (count[char] || 0) + 1; } for (let char of ransomNote) { if (!count[char]) return false; count[char]--; } return true; };",No,No,O(n),4
"const productExceptSelf = (nums) => { const result = Array(nums.length).fill(1); let left = 1, right = 1; for (let i = 0; i < nums.length; i++) { result[i] *= left; left *= nums[i]; } for (let i = nums.length - 1; i >= 0; i--) { result[i] *= right; right *= nums[i]; } return result; };",No,No,O(n),4
"const maxArea = (height) => { let left = 0, right = height.length - 1; let maxArea = 0; while (left < right) { const area = Math.min(height[left], height[right]) * (right - left); maxArea = Math.max(maxArea, area); if (height[left] < height[right]) left++; else right--; } return maxArea; };",No,No,O(n),4
"const candy = (ratings) => { const n = ratings.length; const candies = Array(n).fill(1); for (let i = 1; i < n; i++) { if (ratings[i] > ratings[i - 1]) candies[i] = candies[i - 1] + 1; } for (let i = n - 2; i >= 0; i--) { if (ratings[i] > ratings[i + 1]) candies[i] = Math.max(candies[i], candies[i + 1] + 1); } return candies.reduce((a, b) => a + b, 0); };",No,No,O(n),4
"const longestIncreasingSubsequence = (nums) => { const dp = []; for (let num of nums) { const index = dp.findIndex((x) => x >= num); if (index === -1) dp.push(num); else dp[index] = num; } return dp.length; };",No,No,O(n log n),4
"const twoSum = (nums, target) => { const map = new Map(); for (let i = 0; i < nums.length; i++) { const complement = target - nums[i]; if (map.has(complement)) return [map.get(complement), i]; map.set(nums[i], i); } return []; };",No,No,O(n),4
"const isValidSudoku = (board) => { const rows = Array(9).fill(null).map(() => new Set()), cols = Array(9).fill(null).map(() => new Set()), boxes = Array(9).fill(null).map(() => new Set()); for (let r = 0; r < 9; r++) { for (let c = 0; c < 9; c++) { const num = board[r][c]; if (num !== '.') { const boxIndex = Math.floor(r / 3) * 3 + Math.floor(c / 3); if (rows[r].has(num) || cols[c].has(num) || boxes[boxIndex].has(num)) return false; rows[r].add(num); cols[c].add(num); boxes[boxIndex].add(num); } } } return true; };",No,No,O(n^2),4
"const minWindow = (s, t) => { const need = {}, window = {}; for (let char of t) { need[char] = (need[char] || 0) + 1; } let left = 0, right = 0, valid = 0, minLen = Infinity, start = 0; while (right < s.length) { const c = s[right]; right++; if (need[c]) { window[c] = (window[c] || 0) + 1; if (window[c] === need[c]) valid++; } while (valid === Object.keys(need).length) { if (right - left < minLen) { start = left; minLen = right - left; } const d = s[left]; left++; if (need[d]) { if (window[d] === need[d]) valid--; window[d]--; } } } return minLen === Infinity ? "" : s.slice(start, start + minLen); };",No,No,O(n),4
"const searchRange = (nums, target) => { const binarySearch = (left) => { let low = 0, high = nums.length - 1; while (low <= high) { const mid = Math.floor((low + high) / 2); if (nums[mid] === target) { if (left) { if (mid === 0 || nums[mid - 1] < target) return mid; high = mid - 1; } else { if (mid === nums.length - 1 || nums[mid + 1] > target) return mid; low = mid + 1; } } else if (nums[mid] < target) low = mid + 1; else high = mid - 1; } return -1; }; const start = binarySearch(true); const end = binarySearch(false); return [start, end]; };",No,No,O(log n),4
"const rotate = (nums, k) => { k %= nums.length; reverse(nums, 0, nums.length - 1); reverse(nums, 0, k - 1); reverse(nums, k, nums.length - 1); }; const reverse = (arr, start, end) => { while (start < end) { [arr[start], arr[end]] = [arr[end], arr[start]]; start++; end--; } };",No,No,O(n),4
"const wordBreak = (s, wordDict) => { const set = new Set(wordDict), dp = Array(s.length + 1).fill(false); dp[0] = true; for (let i = 1; i <= s.length; i++) { for (let j = 0; j < i; j++) { if (dp[j] && set.has(s.slice(j, i))) { dp[i] = true; break; } } } return dp[s.length]; };",No,No,O(n^2),4
"const canJump = (nums) => { let maxReach = 0; for (let i = 0; i < nums.length; i++) { if (i > maxReach) return false; maxReach = Math.max(maxReach, i + nums[i]); } return true; };",No,No,O(n),4
"const combinationSum = (candidates, target) => { const res = []; const backtrack = (remaining, combo, start) => { if (remaining === 0) { res.push([...combo]); return; } if (remaining < 0) return; for (let i = start; i < candidates.length; i++) { combo.push(candidates[i]); backtrack(remaining - candidates[i], combo, i); combo.pop(); } }; backtrack(target, [], 0); return res; };",No,No,O(2^n),4
"const letterCombinations = (digits) => { if (!digits) return []; const map = ["", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"]; const result = []; const backtrack = (index, path) => { if (index === digits.length) { result.push(path.join('')); return; } const letters = map[digits[index]]; for (const letter of letters) { path.push(letter); backtrack(index + 1, path); path.pop(); } }; backtrack(0, []); return result; };",No,No,O(3^n),4
"const maxProfit = (prices) => { let minPrice = Infinity, maxProfit = 0; for (let price of prices) { if (price < minPrice) minPrice = price; else if (price - minPrice > maxProfit) maxProfit = price - minPrice; } return maxProfit; };",No,No,O(n),4
"const groupAnagrams = (strs) => { const map = {}; for (let str of strs) { const sorted = str.split('').sort().join(''); if (!map[sorted]) map[sorted] = []; map[sorted].push(str); } return Object.values(map); };",No,No,O(nk log k),4
"const validPalindrome = (s) => { const isPalindrome = (s) => s === s.split('').reverse().join(''); for (let i = 0; i < s.length; i++) { const newStr = s.slice(0, i) + s.slice(i + 1); if (isPalindrome(newStr)) return true; } return false; };",No,No,O(n^2),4
"const climbStairs = (n) => { const dp = Array(n + 1).fill(0); dp[0] = 1; dp[1] = 1; for (let i = 2; i <= n; i++) { dp[i] = dp[i - 1] + dp[i - 2]; } return dp[n]; };",No,No,O(n),4
"const longestCommonPrefix = (strs) => { if (!strs.length) return ''; let prefix = strs[0]; for (let i = 1; i < strs.length; i++) { while (strs[i].indexOf(prefix) !== 0) { prefix = prefix.slice(0, -1); } } return prefix; };",No,No,O(n * m),4
"const findMedianSortedArrays = (nums1, nums2) => { const merged = [...nums1, ...nums2].sort((a, b) => a - b); const mid = Math.floor(merged.length / 2); return merged.length % 2 === 0 ? (merged[mid - 1] + merged[mid]) / 2 : merged[mid]; };",No,No,O((n + m) log(n + m)),4
"const rotateArray = (nums, k) => { k = k % nums.length; const reverse = (arr, start, end) => { while (start < end) { [arr[start], arr[end]] = [arr[end], arr[start]]; start++; end--; } }; reverse(nums, 0, nums.length - 1); reverse(nums, 0, k - 1); reverse(nums, k, nums.length - 1); };",No,No,O(n),4
"const generateParenthesis = (n) => { const result = []; const backtrack = (left, right, current) => { if (current.length === n * 2) { result.push(current); return; } if (left < n) backtrack(left + 1, right, current + '('); if (right < left) backtrack(left, right + 1, current + ')'); }; backtrack(0, 0, ''); return result; };",No,No,O(4^n/n^(1/2)),4
"const mergeIntervals = (intervals) => { if (!intervals.length) return []; intervals.sort((a, b) => a[0] - b[0]); const merged = [intervals[0]]; for (let i = 1; i < intervals.length; i++) { const current = intervals[i]; const lastMerged = merged[merged.length - 1]; if (current[0] <= lastMerged[1]) { lastMerged[1] = Math.max(lastMerged[1], current[1]); } else { merged.push(current); } } return merged; };",No,No,O(n log n),4
"const searchInsert = (nums, target) => { let left = 0, right = nums.length - 1; while (left <= right) { const mid = Math.floor((left + right) / 2); if (nums[mid] === target) return mid; if (nums[mid] < target) left = mid + 1; else right = mid - 1; } return left; };",No,No,O(log n),4
"const removeDuplicates = (nums) => { let k = 0; for (let i = 1; i < nums.length; i++) { if (nums[k] !== nums[i]) { k++; nums[k] = nums[i]; } } return k + 1; };",No,No,O(n),4
"const isSubsequence = (s, t) => { let sIndex = 0, tIndex = 0; while (sIndex < s.length && tIndex < t.length) { if (s[sIndex] === t[tIndex]) sIndex++; tIndex++; } return sIndex === s.length; };",No,No,O(n + m),4
"const largestRectangleArea = (heights) => { const stack = [], area = []; for (let i = 0; i <= heights.length; i++) { const h = i === heights.length ? 0 : heights[i]; while (stack.length && heights[stack[stack.length - 1]] > h) { const height = heights[stack.pop()]; const width = stack.length ? i - stack[stack.length - 1] - 1 : i; area.push(height * width); } stack.push(i); } return Math.max(...area); };",No,No,O(n),4
"const canConstruct = (ransomNote, magazine) => { const magazineCount = {}; for (let char of magazine) { magazineCount[char] = (magazineCount[char] || 0) + 1; } for (let char of ransomNote) { if (!magazineCount[char]) return false; magazineCount[char]--; } return true; };",No,No,O(n + m),4
"const mergeKLists = (lists) => { if (!lists.length) return null; const minHeap = new MinHeap(); for (const list of lists) { if (list) minHeap.insert(list); } const dummy = new ListNode(0); let current = dummy; while (minHeap.size) { const node = minHeap.extractMin(); current.next = node; current = current.next; if (node.next) minHeap.insert(node.next); } return dummy.next; };",No,No,O(n log k),4
"const lengthOfLongestSubstring = (s) => { const map = new Map(); let left = 0, maxLength = 0; for (let right = 0; right < s.length; right++) { if (map.has(s[right])) left = Math.max(map.get(s[right]) + 1, left); map.set(s[right], right); maxLength = Math.max(maxLength, right - left + 1); } return maxLength; };",No,No,O(n),4
"const swapPairs = (head) => { if (!head || !head.next) return head; let firstNode = head, secondNode = head.next; firstNode.next = swapPairs(secondNode.next); secondNode.next = firstNode; return secondNode; };",No,No,O(n),4
"const reverseKGroup = (head, k) => { let count = 0, curr = head; while (curr && count < k) { curr = curr.next; count++; } if (count < k) return head; let prev = null, next = null; curr = head; count = 0; while (count < k) { next = curr.next; curr.next = prev; prev = curr; curr = next; count++; } head.next = reverseKGroup(curr, k); return prev; };",No,No,O(n),4
"const singleNumber = (nums) => { return nums.reduce((acc, num) => acc ^ num, 0); };",No,No,O(n),4
"const binaryTreePaths = (root) => { const paths = []; const constructPaths = (node, path) => { if (!node) return; path += node.val; if (!node.left && !node.right) paths.push(path); else { path += '->'; constructPaths(node.left, path); constructPaths(node.right, path); } }; constructPaths(root, ''); return paths; };",No,No,O(n),4
"const maxDepth = (root) => { if (!root) return 0; return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1; };",No,No,O(n),4
"const findDuplicates = (nums) => { const duplicates = []; const seen = new Set(); for (const num of nums) { if (seen.has(num)) duplicates.push(num); else seen.add(num); } return duplicates; };",No,No,O(n),4
"const minPathSum = (grid) => { const m = grid.length, n = grid[0].length; for (let i = 0; i < m; i++) { for (let j = 0; j < n; j++) { if (i === 0 && j === 0) continue; grid[i][j] += Math.min(i > 0 ? grid[i - 1][j] : Infinity, j > 0 ? grid[i][j - 1] : Infinity); } } return grid[m - 1][n - 1]; };",No,No,O(m * n),4
"const combinationSum = (candidates, target) => { const result = []; const backtrack = (comb, start, total) => { if (total === target) { result.push([...comb]); return; } if (total > target) return; for (let i = start; i < candidates.length; i++) { comb.push(candidates[i]); backtrack(comb, i, total + candidates[i]); comb.pop(); } }; backtrack([], 0, 0); return result; };",No,No,O(2^n),4
"const uniquePaths = (m, n) => { const dp = Array(m).fill(null).map(() => Array(n).fill(0)); for (let i = 0; i < m; i++) dp[i][0] = 1; for (let j = 0; j < n; j++) dp[0][j] = 1; for (let i = 1; i < m; i++) { for (let j = 1; j < n; j++) { dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } return dp[m - 1][n - 1]; };",No,No,O(m * n),4
"const minimumTotal = (triangle) => { const n = triangle.length; for (let row = n - 2; row >= 0; row--) { for (let col = 0; col <= row; col++) { triangle[row][col] += Math.min(triangle[row + 1][col], triangle[row + 1][col + 1]); } } return triangle[0][0]; };",No,No,O(n^2),4
"const longestIncreasingSubsequence = (nums) => { const dp = Array(nums.length).fill(1); for (let i = 1; i < nums.length; i++) { for (let j = 0; j < i; j++) { if (nums[i] > nums[j]) dp[i] = Math.max(dp[i], dp[j] + 1); } } return Math.max(...dp); };",No,No,O(n^2),4
"const spiralOrder = (matrix) => { const result = []; while (matrix.length) { result.push(...matrix.shift()); if (matrix.length) { for (let row of matrix) result.push(row.pop()); } if (matrix.length) result.push(...(matrix.pop().reverse())); for (let row of matrix.reverse()) result.push(row.shift()); } return result; };",No,No,O(m * n),4
"const wordBreak = (s, wordDict) => { const dp = Array(s.length + 1).fill(false); dp[0] = true; for (let i = 1; i <= s.length; i++) { for (const word of wordDict) { if (s.substring(i - word.length, i) === word) dp[i] = dp[i] || dp[i - word.length]; } } return dp[s.length]; };",No,No,O(n^2 * m),4
"const findLongestWord = (s, d) => { let longest = ''; for (const word of d) { if ((word.length > longest.length || (word.length === longest.length && word < longest)) && isSubsequence(word, s)) { longest = word; } } return longest; };",No,No,O(n * m),4
"const numDistinct = (s, t) => { const dp = Array(t.length + 1).fill(0); dp[0] = 1; for (let i = 1; i <= s.length; i++) { for (let j = t.length; j > 0; j--) { if (s[i - 1] === t[j - 1]) dp[j] += dp[j - 1]; } } return dp[t.length]; };",No,No,O(n * m),4
"const checkInclusion = (s1, s2) => { const countS1 = Array(26).fill(0); const countS2 = Array(26).fill(0); for (const char of s1) countS1[char.charCodeAt() - 97]++; for (let i = 0; i < s2.length; i++) { countS2[s2[i].charCodeAt() - 97]++; if (i >= s1.length) countS2[s2[i - s1.length].charCodeAt() - 97]--; if (countS1.toString() === countS2.toString()) return true; } return false; };",No,No,O(n),4
"const minimumWindowSubstring = (s, t) => { const charCountT = {}; for (const char of t) charCountT[char] = (charCountT[char] || 0) + 1; let left = 0, right = 0, minLen = Infinity, minWindow = ''; while (right < s.length) { if (charCountT[s[right]] > 0) charCountT[s[right]]--; if (Object.values(charCountT).every(count => count <= 0)) { while (Object.values(charCountT).every(count => count <= 0)) { if (right - left + 1 < minLen) { minLen = right - left + 1; minWindow = s.substring(left, right + 1); } charCountT[s[left]]++; left++; } } right++; } return minWindow; };",No,No,O(n),4
"const longestValidParentheses = (s) => { const stack = [-1]; let maxLength = 0; for (let i = 0; i < s.length; i++) { if (s[i] === '(') stack.push(i); else { stack.pop(); if (stack.length) maxLength = Math.max(maxLength, i - stack[stack.length - 1]); else stack.push(i); } } return maxLength; };",No,No,O(n),4
"const setZeroes = (matrix) => { const rows = new Set(), cols = new Set(); for (let i = 0; i < matrix.length; i++) { for (let j = 0; j < matrix[0].length; j++) { if (matrix[i][j] === 0) { rows.add(i); cols.add(j); } } } for (let i = 0; i < matrix.length; i++) { for (let j = 0; j < matrix[0].length; j++) { if (rows.has(i) || cols.has(j)) matrix[i][j] = 0; } } };",No,No,O(m * n),4
"const sortColors = (nums) => { let zeroIndex = 0, twoIndex = nums.length - 1; for (let i = 0; i <= twoIndex; i++) { while (nums[i] === 2 && i < twoIndex) { [nums[i], nums[twoIndex]] = [nums[twoIndex], nums[i]]; twoIndex--; } while (nums[i] === 0 && i > zeroIndex) { [nums[i], nums[zeroIndex]] = [nums[zeroIndex], nums[i]]; zeroIndex++; } } };",No,No,O(n),4
"const subsets = (nums) => { const result = []; const backtrack = (start, subset) => { result.push([...subset]); for (let i = start; i < nums.length; i++) { subset.push(nums[i]); backtrack(i + 1, subset); subset.pop(); } }; backtrack(0, []); return result; };",No,No,O(2^n),4
"const subsetsWithDup = (nums) => { const result = []; nums.sort(); const backtrack = (start, subset) => { result.push([...subset]); for (let i = start; i < nums.length; i++) { if (i > start && nums[i] === nums[i - 1]) continue; subset.push(nums[i]); backtrack(i + 1, subset); subset.pop(); } }; backtrack(0, []); return result; };",No,No,O(2^n),4
"const permute = (nums) => { const result = []; const backtrack = (start) => { if (start === nums.length) result.push([...nums]); for (let i = start; i < nums.length; i++) { [nums[start], nums[i]] = [nums[i], nums[start]]; backtrack(start + 1); [nums[start], nums[i]] = [nums[i], nums[start]]; } }; backtrack(0); return result; };",No,No,O(n!),4
"const permuteUnique = (nums) => { const result = []; nums.sort(); const backtrack = (start) => { if (start === nums.length) result.push([...nums]); for (let i = start; i < nums.length; i++) { if (i > start && nums[i] === nums[i - 1]) continue; [nums[start], nums[i]] = [nums[i], nums[start]]; backtrack(start + 1); [nums[start], nums[i]] = [nums[i], nums[start]]; } }; backtrack(0); return result; };",No,No,O(n!),4
"const myPow = (x, n) => { if (n < 0) return 1 / myPow(x, -n); if (n === 0) return 1; const half = myPow(x, Math.floor(n / 2)); return n % 2 === 0 ? half * half : half * half * x; };",No,No,O(log n),4
"const maxArea = (height) => { let left = 0, right = height.length - 1; let maxArea = 0; while (left < right) { const area = Math.min(height[left], height[right]) * (right - left); maxArea = Math.max(maxArea, area); if (height[left] < height[right]) left++; else right--; } return maxArea; };",No,No,O(n),4
"const reverseWords = (s) => { return s.trim().split(/\s+/).reverse().join(' '); };",No,No,O(n),4
"const longestCommonPrefix = (strs) => { if (!strs.length) return ''; let prefix = strs[0]; for (let i = 1; i < strs.length; i++) { while (strs[i].indexOf(prefix) !== 0) prefix = prefix.slice(0, -1); if (!prefix) return ''; } return prefix; };",No,No,O(n * m),4
"const isValid = (s) => { const stack = []; const map = { '(': ')', '{': '}', '[': ']' }; for (const char of s) { if (char in map) stack.push(char); else { if (stack.length === 0 || char !== map[stack.pop()]) return false; } } return stack.length === 0; };",No,No,O(n),4
"const isAnagram = (s, t) => { if (s.length !== t.length) return false; const count = {}; for (const char of s) { count[char] = (count[char] || 0) + 1; } for (const char of t) { if (!count[char]) return false; count[char]--; } return true; };",No,No,O(n),4
"const majorityElement = (nums) => { const count = {}; for (const num of nums) { count[num] = (count[num] || 0) + 1; if (count[num] > nums.length / 2) return num; } };",No,No,O(n),4
"const findMedianSortedArrays = (nums1, nums2) => { const merged = [...nums1, ...nums2].sort((a, b) => a - b); const mid = Math.floor(merged.length / 2); return merged.length % 2 === 0 ? (merged[mid - 1] + merged[mid]) / 2 : merged[mid]; };",No,No,O(n log n),4
"const searchInsert = (nums, target) => { let left = 0, right = nums.length - 1; while (left <= right) { const mid = Math.floor((left + right) / 2); if (nums[mid] === target) return mid; else if (nums[mid] < target) left = mid + 1; else right = mid - 1; } return left; };",No,No,O(log n),4
"const search = (nums, target) => { let left = 0, right = nums.length - 1; while (left <= right) { const mid = Math.floor((left + right) / 2); if (nums[mid] === target) return mid; else if (nums[mid] < target) left = mid + 1; else right = mid - 1; } return -1; };",No,No,O(log n),4
"const rotate = (nums, k) => { k %= nums.length; const reverse = (start, end) => { while (start < end) { [nums[start], nums[end]] = [nums[end], nums[start]]; start++; end--; } }; reverse(0, nums.length - 1); reverse(0, k - 1); reverse(k, nums.length - 1); };",No,No,O(n),4
"const threeSum = (nums) => { nums.sort((a, b) => a - b); const result = []; for (let i = 0; i < nums.length - 2; i++) { if (i > 0 && nums[i] === nums[i - 1]) continue; let left = i + 1, right = nums.length - 1; while (left < right) { const sum = nums[i] + nums[left] + nums[right]; if (sum < 0) left++; else if (sum > 0) right--; else { result.push([nums[i], nums[left], nums[right]]); while (nums[left] === nums[left + 1]) left++; while (nums[right] === nums[right - 1]) right--; left++; right--; } } } return result; };",No,No,O(n^2),4
"const letterCombinations = (digits) => { if (!digits.length) return []; const map = { '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz' }; const result = []; const backtrack = (comb, index) => { if (index === digits.length) { result.push(comb.join('')); return; } for (const char of map[digits[index]]) { comb.push(char); backtrack(comb, index + 1); comb.pop(); } }; backtrack([], 0); return result; };",No,No,O(3^n),4
"const coinChange = (coins, amount) => { const dp = Array(amount + 1).fill(Infinity); dp[0] = 0; for (const coin of coins) { for (let i = coin; i <= amount; i++) { dp[i] = Math.min(dp[i], dp[i - coin] + 1); } } return dp[amount] === Infinity ? -1 : dp[amount]; };",No,No,O(n * amount),4
"const isPalindrome = (s) => { const cleaned = s.replace(/[^A-Za-z0-9]/g, '').toLowerCase(); return cleaned === cleaned.split('').reverse().join(''); };",No,No,O(n),4
"const lengthOfLongestSubstring = (s) => { const charSet = new Set(); let left = 0, maxLength = 0; for (let right = 0; right < s.length; right++) { while (charSet.has(s[right])) charSet.delete(s[left++]); charSet.add(s[right]); maxLength = Math.max(maxLength, right - left + 1); } return maxLength; };",No,No,O(n),4
"const simplifyPath = (path) => { const stack = []; const parts = path.split('/'); for (const part of parts) { if (part === '' || part === '.') continue; if (part === '..') stack.pop(); else stack.push(part); } return '/' + stack.join('/'); };",No,No,O(n),4
"const numIslands = (grid) => { if (!grid.length) return 0; const visited = new Set(); const dfs = (i, j) => { if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] === '0' || visited.has(`${i},${j}`)) return; visited.add(`${i},${j}`); dfs(i + 1, j); dfs(i - 1, j); dfs(i, j + 1); dfs(i, j - 1); }; let count = 0; for (let i = 0; i < grid.length; i++) { for (let j = 0; j < grid[0].length; j++) { if (grid[i][j] === '1' && !visited.has(`${i},${j}`)) { dfs(i, j); count++; } } } return count; };",No,No,O(m * n),4
"const fourSum = (nums, target) => { nums.sort((a, b) => a - b); const result = []; for (let i = 0; i < nums.length - 3; i++) { if (i > 0 && nums[i] === nums[i - 1]) continue; for (let j = i + 1; j < nums.length - 2; j++) { if (j > i + 1 && nums[j] === nums[j - 1]) continue; let left = j + 1, right = nums.length - 1; while (left < right) { const sum = nums[i] + nums[j] + nums[left] + nums[right]; if (sum < target) left++; else if (sum > target) right--; else { result.push([nums[i], nums[j], nums[left], nums[right]]); while (nums[left] === nums[left + 1]) left++; while (nums[right] === nums[right - 1]) right--; left++; right--; } } } } return result; };",No,No,O(n^3),4
"const groupAnagrams = (strs) => { const map = {}; for (const str of strs) { const sortedStr = str.split('').sort().join(''); if (!map[sortedStr]) map[sortedStr] = []; map[sortedStr].push(str); } return Object.values(map); };",No,No,O(n * m log m),4
"const climbStairs = (n) => { const dp = Array(n + 1).fill(0); dp[0] = 1; for (let i = 1; i <= n; i++) { dp[i] += dp[i - 1]; if (i - 2 >= 0) dp[i] += dp[i - 2]; } return dp[n]; };",No,No,O(n),4
"const uniquePaths = (m, n) => { const dp = Array(m).fill().map(() => Array(n).fill(1)); for (let i = 1; i < m; i++) { for (let j = 1; j < n; j++) { dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } return dp[m - 1][n - 1]; };",No,No,O(m * n),4
"const longestIncreasingSubsequence = (nums) => { const dp = Array(nums.length).fill(1); for (let i = 1; i < nums.length; i++) { for (let j = 0; j < i; j++) { if (nums[i] > nums[j]) dp[i] = Math.max(dp[i], dp[j] + 1); } } return Math.max(...dp); };",No,No,O(n^2),4
"const canJump = (nums) => { let maxReach = 0; for (let i = 0; i < nums.length; i++) { if (i > maxReach) return false; maxReach = Math.max(maxReach, i + nums[i]); } return true; };",No,No,O(n),4
"const jump = (nums) => { let jumps = 0, currentEnd = 0, farthest = 0; for (let i = 0; i < nums.length - 1; i++) { farthest = Math.max(farthest, i + nums[i]); if (i === currentEnd) { jumps++; currentEnd = farthest; } } return jumps; };",No,No,O(n),4
"const maxProduct = (nums) => { let maxProduct = nums[0], minProduct = nums[0], result = nums[0]; for (let i = 1; i < nums.length; i++) { if (nums[i] < 0) [maxProduct, minProduct] = [minProduct, maxProduct]; maxProduct = Math.max(nums[i], maxProduct * nums[i]); minProduct = Math.min(nums[i], minProduct * nums[i]); result = Math.max(result, maxProduct); } return result; };",No,No,O(n),4
"const minPathSum = (grid) => { const m = grid.length, n = grid[0].length; const dp = Array(m).fill().map(() => Array(n).fill(0)); dp[0][0] = grid[0][0]; for (let i = 1; i < m; i++) dp[i][0] = dp[i - 1][0] + grid[i][0]; for (let j = 1; j < n; j++) dp[0][j] = dp[0][j - 1] + grid[0][j]; for (let i = 1; i < m; i++) { for (let j = 1; j < n; j++) { dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]; } } return dp[m - 1][n - 1]; };",No,No,O(m * n),4
"const maxSubArray = (nums) => { let maxSum = nums[0], currentSum = nums[0]; for (let i = 1; i < nums.length; i++) { currentSum = Math.max(nums[i], currentSum + nums[i]); maxSum = Math.max(maxSum, currentSum); } return maxSum; };",No,No,O(n),4
"const twoSum = (nums, target) => { const map = new Map(); for (let i = 0; i < nums.length; i++) { const complement = target - nums[i]; if (map.has(complement)) return [map.get(complement), i]; map.set(nums[i], i); } };",No,No,O(n),4
"const merge = (intervals) => { if (intervals.length === 0) return []; intervals.sort((a, b) => a[0] - b[0]); const merged = [intervals[0]]; for (let i = 1; i < intervals.length; i++) { const last = merged[merged.length - 1]; if (last[1] >= intervals[i][0]) last[1] = Math.max(last[1], intervals[i][1]); else merged.push(intervals[i]); } return merged; };",No,No,O(n log n),4
"const findSubstring = (s, words) => { const wordLen = words[0].length, wordCount = words.length; const totalLen = wordLen * wordCount; const result = []; const wordMap = {}; for (const word of words) { wordMap[word] = (wordMap[word] || 0) + 1; } for (let i = 0; i <= s.length - totalLen; i++) { const seen = {}; let j = 0; while (j < wordCount) { const word = s.slice(i + j * wordLen, i + (j + 1) * wordLen); if (!wordMap[word]) break; seen[word] = (seen[word] || 0) + 1; if (seen[word] > wordMap[word]) break; j++; } if (j === wordCount) result.push(i); } return result; };",No,No,O(n),4
"const canConstruct = (ransomNote, magazine) => { const count = {}; for (const char of magazine) { count[char] = (count[char] || 0) + 1; } for (const char of ransomNote) { if (!count[char]) return false; count[char]--; } return true; };",No,No,O(n),4
"const searchRange = (nums, target) => { const binarySearch = (left) => { let low = 0, high = nums.length - 1; while (low <= high) { const mid = Math.floor((low + high) / 2); if (nums[mid] === target) { if (left) { if (mid === 0 || nums[mid - 1] < target) return mid; high = mid - 1; } else { if (mid === nums.length - 1 || nums[mid + 1] > target) return mid; low = mid + 1; } } else if (nums[mid] < target) low = mid + 1; else high = mid - 1; } return -1; }; const leftIdx = binarySearch(true); if (leftIdx === -1) return [-1, -1]; const rightIdx = binarySearch(false); return [leftIdx, rightIdx]; };",No,No,O(log n),4
"const trap = (height) => { const leftMax = Array(height.length).fill(0), rightMax = Array(height.length).fill(0); for (let i = 1; i < height.length; i++) leftMax[i] = Math.max(leftMax[i - 1], height[i - 1]); for (let i = height.length - 2; i >= 0; i--) rightMax[i] = Math.max(rightMax[i + 1], height[i + 1]); let waterTrapped = 0; for (let i = 0; i < height.length; i++) { waterTrapped += Math.min(leftMax[i], rightMax[i]) - height[i]; } return waterTrapped; };",No,No,O(n),4
"const validateBinarySearchTree = (root) => { const dfs = (node, min, max) => { if (!node) return true; if (node.val <= min || node.val >= max) return false; return dfs(node.left, min, node.val) && dfs(node.right, node.val, max); }; return dfs(root, -Infinity, Infinity); };",No,No,O(n),4
"const maxDepth = (root) => { if (!root) return 0; return 1 + Math.max(maxDepth(root.left), maxDepth(root.right)); };",No,No,O(n),4
"const invertTree = (root) => { if (!root) return null; [root.left, root.right] = [root.right, root.left]; invertTree(root.left); invertTree(root.right); return root; };",No,No,O(n),4
"const lowestCommonAncestor = (root, p, q) => { if (!root || root === p || root === q) return root; const left = lowestCommonAncestor(root.left, p, q); const right = lowestCommonAncestor(root.right, p, q); return left && right ? root : left || right; };",No,No,O(n),4
"const isSymmetric = (root) => { const isMirror = (t1, t2) => { if (!t1 && !t2) return true; if (!t1 || !t2) return false; return t1.val === t2.val && isMirror(t1.left, t2.right) && isMirror(t1.right, t2.left); }; return isMirror(root, root); };",No,No,O(n),4
"const kthSmallest = (root, k) => { const inorder = (node) => { return node ? [...inorder(node.left), node.val, ...inorder(node.right)] : []; }; return inorder(root)[k - 1]; };",No,No,O(n),4
"const connect = (root) => { if (!root) return root; const queue = [root]; while (queue.length) { const size = queue.length; for (let i = 0; i < size; i++) { const node = queue.shift(); if (i < size - 1) node.next = queue[0]; if (node.left) queue.push(node.left); if (node.right) queue.push(node.right); } } return root; };",No,No,O(n),4
"const levelOrder = (root) => { if (!root) return []; const result = []; const queue = [root]; while (queue.length) { const size = queue.length; const level = []; for (let i = 0; i < size; i++) { const node = queue.shift(); level.push(node.val); if (node.left) queue.push(node.left); if (node.right) queue.push(node.right); } result.push(level); } return result; };",No,No,O(n),4
"const mergeKLists = (lists) => { const mergeTwoLists = (l1, l2) => { let dummy = new ListNode(0), tail = dummy; while (l1 && l2) { if (l1.val < l2.val) { tail.next = l1; l1 = l1.next; } else { tail.next = l2; l2 = l2.next; } tail = tail.next; } tail.next = l1 || l2; return dummy.next; }; let mergedList = lists[0]; for (let i = 1; i < lists.length; i++) mergedList = mergeTwoLists(mergedList, lists[i]); return mergedList; };",No,No,O(n log k),4
"const minimumTotal = (triangle) => { for (let row = triangle.length - 2; row >= 0; row--) { for (let col = 0; col <= row; col++) { triangle[row][col] += Math.min(triangle[row + 1][col], triangle[row + 1][col + 1]); } } return triangle[0][0]; };",No,No,O(n^2),4
"const combinationSum = (candidates, target) => { const result = []; const backtrack = (start, path, target) => { if (target === 0) { result.push([...path]); return; } if (target < 0) return; for (let i = start; i < candidates.length; i++) { path.push(candidates[i]); backtrack(i, path, target - candidates[i]); path.pop(); } }; backtrack(0, [], target); return result; };",No,No,O(2^n),4
"const coinChange = (coins, amount) => { const dp = Array(amount + 1).fill(Infinity); dp[0] = 0; for (let i = 1; i <= amount; i++) { for (const coin of coins) { if (i - coin >= 0) dp[i] = Math.min(dp[i], dp[i - coin] + 1); } } return dp[amount] === Infinity ? -1 : dp[amount]; };",No,No,O(n * amount),4
"const longestCommonSubsequence = (text1, text2) => { const dp = Array(text1.length + 1).fill().map(() => Array(text2.length + 1).fill(0)); for (let i = 1; i <= text1.length; i++) { for (let j = 1; j <= text2.length; j++) { if (text1[i - 1] === text2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1; else dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]); } } return dp[text1.length][text2.length]; };",No,No,O(m * n),4
"const isValid = (s) => { const stack = []; const map = { '(': ')', '{': '}', '[': ']' }; for (const char of s) { if (map[char]) stack.push(char); else if (stack.length === 0 || map[stack.pop()] !== char) return false; } return stack.length === 0; };",No,No,O(n),4
"const lengthOfLongestSubstring = (s) => { const map = {}; let left = 0, maxLength = 0; for (let right = 0; right < s.length; right++) { if (map[s[right]] >= left) left = map[s[right]] + 1; map[s[right]] = right; maxLength = Math.max(maxLength, right - left + 1); } return maxLength; };",No,No,O(n),4
"const threeSum = (nums) => { nums.sort((a, b) => a - b); const result = []; for (let i = 0; i < nums.length - 2; i++) { if (i > 0 && nums[i] === nums[i - 1]) continue; let left = i + 1, right = nums.length - 1; while (left < right) { const sum = nums[i] + nums[left] + nums[right]; if (sum < 0) left++; else if (sum > 0) right--; else { result.push([nums[i], nums[left], nums[right]]); while (left < right && nums[left] === nums[left + 1]) left++; while (left < right && nums[right] === nums[right - 1]) right--; left++; right--; } } } return result; };",No,No,O(n^2),4
"const validParentheses = (s) => { const stack = []; for (const char of s) { if (char === '(') stack.push(')'); else if (char === '[') stack.push(']'); else if (char === '{') stack.push('}'); else if (stack.pop() !== char) return false; } return stack.length === 0; };",No,No,O(n),4
"const backspaceCompare = (S, T) => { const buildString = (s) => { const stack = []; for (const char of s) { if (char === '#') stack.pop(); else stack.push(char); } return stack.join(''); }; return buildString(S) === buildString(T); };",No,No,O(n),4
"const subarraySum = (nums, k) => { const map = new Map(); let count = 0, sum = 0; for (const num of nums) { sum += num; if (sum === k) count++; if (map.has(sum - k)) count += map.get(sum - k); map.set(sum, (map.get(sum) || 0) + 1); } return count; };",No,No,O(n),4
"const longestPalindrome = (s) => { let start = 0, end = 0; const expandAroundCenter = (left, right) => { while (left >= 0 && right < s.length && s[left] === s[right]) { left--; right++; } return right - left - 1; }; for (let i = 0; i < s.length; i++) { const len1 = expandAroundCenter(i, i); const len2 = expandAroundCenter(i, i + 1); const len = Math.max(len1, len2); if (len > end - start) { start = i - Math.floor((len - 1) / 2); end = i + Math.floor(len / 2); } } return s.slice(start, end + 1); };",No,No,O(n^2),4
"const topKFrequent = (nums, k) => { const freqMap = {}; for (const num of nums) freqMap[num] = (freqMap[num] || 0) + 1; return Object.entries(freqMap).sort((a, b) => b[1] - a[1]).slice(0, k).map(([num]) => num); };",No,No,O(n log n),4
"const findMedianSortedArrays = (nums1, nums2) => { const merge = (arr1, arr2) => { const merged = []; let i = 0, j = 0; while (i < arr1.length || j < arr2.length) { if (i === arr1.length) merged.push(arr2[j++]); else if (j === arr2.length) merged.push(arr1[i++]); else if (arr1[i] < arr2[j]) merged.push(arr1[i++]); else merged.push(arr2[j++]); } return merged; }; const mergedArray = merge(nums1, nums2); const mid = Math.floor(mergedArray.length / 2); return mergedArray.length % 2 === 0 ? (mergedArray[mid - 1] + mergedArray[mid]) / 2 : mergedArray[mid]; };",No,No,O(m + n),4
"const removeDuplicates = (nums) => { if (nums.length === 0) return 0; let uniqueIndex = 1; for (let i = 1; i < nums.length; i++) { if (nums[i] !== nums[i - 1]) { nums[uniqueIndex] = nums[i]; uniqueIndex++; } } return uniqueIndex; };",No,No,O(n),4
"const rotate = (nums, k) => { k %= nums.length; const reverse = (arr, start, end) => { while (start < end) { [arr[start], arr[end]] = [arr[end], arr[start]]; start++; end--; } }; reverse(nums, 0, nums.length - 1); reverse(nums, 0, k - 1); reverse(nums, k, nums.length - 1); };",No,No,O(n),4
"const longestConsecutive = (nums) => { const numSet = new Set(nums); let longestStreak = 0; for (const num of numSet) { if (!numSet.has(num - 1)) { let currentNum = num; let currentStreak = 1; while (numSet.has(currentNum + 1)) { currentNum++; currentStreak++; } longestStreak = Math.max(longestStreak, currentStreak); } } return longestStreak; };",No,No,O(n),4
"const removeElement = (nums, val) => { let k = 0; for (let i = 0; i < nums.length; i++) { if (nums[i] !== val) nums[k++] = nums[i]; } return k; };",No,No,O(n),4
"const jump = (nums) => { let jumps = 0, currentEnd = 0, farthest = 0; for (let i = 0; i < nums.length - 1; i++) { farthest = Math.max(farthest, i + nums[i]); if (i === currentEnd) { jumps++; currentEnd = farthest; } } return jumps; };",No,No,O(n),4
"const isPalindrome = (x) => { if (x < 0) return false; const str = x.toString(); for (let i = 0, j = str.length - 1; i < j; i++, j--) { if (str[i] !== str[j]) return false; } return true; };",No,No,O(n),4
"const mySqrt = (x) => { if (x < 2) return x; let left = 2, right = Math.floor(x / 2); while (left <= right) { const mid = Math.floor((left + right) / 2); const squared = mid * mid; if (squared === x) return mid; else if (squared < x) left = mid + 1; else right = mid - 1; } return right; };",No,No,O(log n),4
"const isAnagram = (s, t) => { if (s.length !== t.length) return false; const count = {}; for (const char of s) count[char] = (count[char] || 0) + 1; for (const char of t) { if (!count[char]) return false; count[char]--; if (count[char] < 0) return false; } return true; };",No,No,O(n),4
"const twoSum = (nums, target) => { const map = {}; for (let i = 0; i < nums.length; i++) { const complement = target - nums[i]; if (complement in map) return [map[complement], i]; map[nums[i]] = i; } };",No,No,O(n),4
"const reverse = (x) => { const sign = Math.sign(x); const reversed = parseInt(Math.abs(x).toString().split('').reverse().join('')) * sign; return reversed < Math.pow(-2, 31) || reversed > Math.pow(2, 31) - 1 ? 0 : reversed; };",No,No,O(log n),4
"const validAnagram = (s, t) => { if (s.length !== t.length) return false; const count = Array(26).fill(0); for (let char of s) count[char.charCodeAt() - 'a'.charCodeAt()]++; for (let char of t) count[char.charCodeAt() - 'a'.charCodeAt()]--; return count.every(val => val === 0); };",No,No,O(n),4
"const searchInsert = (nums, target) => { let left = 0, right = nums.length - 1; while (left <= right) { const mid = Math.floor((left + right) / 2); if (nums[mid] === target) return mid; else if (nums[mid] < target) left = mid + 1; else right = mid - 1; } return left; };",No,No,O(log n),4
"const lengthOfLastWord = (s) => { const words = s.trim().split(' '); return words.length === 0 ? 0 : words[words.length - 1].length; };",No,No,O(n),4
"const firstUniqChar = (s) => { const count = {}; for (const char of s) count[char] = (count[char] || 0) + 1; for (let i = 0; i < s.length; i++) { if (count[s[i]] === 1) return i; } return -1; };",No,No,O(n),4
"const getSum = (a, b) => { while (b !== 0) { const carry = a & b; a ^= b; b = carry << 1; } return a; };",No,No,O(1),4
"const countPrimes = (n) => { if (n < 3) return 0; const isPrime = Array(n).fill(true); isPrime[0] = isPrime[1] = false; for (let i = 2; i * i < n; i++) { if (isPrime[i]) for (let j = i * i; j < n; j += i) isPrime[j] = false; } return isPrime.filter(Boolean).length; };",No,No,O(n log log n),4
"const merge = (intervals) => { if (intervals.length === 0) return []; intervals.sort((a, b) => a[0] - b[0]); const merged = [intervals[0]]; for (let i = 1; i < intervals.length; i++) { const current = intervals[i]; const lastMerged = merged[merged.length - 1]; if (current[0] <= lastMerged[1]) lastMerged[1] = Math.max(lastMerged[1], current[1]); else merged.push(current); } return merged; };",No,No,O(n log n),4
"const spiralOrder = (matrix) => { if (matrix.length === 0) return []; const result = []; let top = 0, bottom = matrix.length - 1, left = 0, right = matrix[0].length - 1; while (top <= bottom && left <= right) { for (let i = left; i <= right; i++) result.push(matrix[top][i]); top++; for (let i = top; i <= bottom; i++) result.push(matrix[i][right]); right--; if (top <= bottom) { for (let i = right; i >= left; i--) result.push(matrix[bottom][i]); bottom--; } if (left <= right) { for (let i = bottom; i >= top; i--) result.push(matrix[i][left]); left++; } } return result; };",No,No,O(n),4
"const uniquePaths = (m, n) => { const dp = Array(m).fill().map(() => Array(n).fill(1)); for (let i = 1; i < m; i++) { for (let j = 1; j < n; j++) { dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } return dp[m - 1][n - 1]; };",No,No,O(m * n),4
"const climbStairs = (n) => { if (n <= 1) return 1; let dp = [1, 1]; for (let i = 2; i <= n; i++) dp[i] = dp[i - 1] + dp[i - 2]; return dp[n]; };",No,No,O(n),4
"const permute = (nums) => { const result = []; const backtrack = (path) => { if (path.length === nums.length) result.push([...path]); for (let num of nums) { if (path.includes(num)) continue; path.push(num); backtrack(path); path.pop(); } }; backtrack([]); return result; };",No,No,O(n!),4
"const generateParenthesis = (n) => { const result = []; const backtrack = (current, open, close) => { if (current.length === n * 2) result.push(current); if (open < n) backtrack(current + '(', open + 1, close); if (close < open) backtrack(current + ')', open, close + 1); }; backtrack('', 0, 0); return result; };",No,No,O(2^n),4
"const findKthLargest = (nums, k) => { const quickSelect = (left, right, indexToFind) => { if (left === right) return nums[left]; const pivotIndex = Math.floor((left + right) / 2); const pivot = nums[pivotIndex]; let currentIndex = left; [nums[pivotIndex], nums[right]] = [nums[right], nums[pivotIndex]]; for (let i = left; i < right; i++) { if (nums[i] > pivot) { [nums[currentIndex], nums[i]] = [nums[i], nums[currentIndex]]; currentIndex++; } } [nums[currentIndex], nums[right]] = [nums[right], nums[currentIndex]]; if (indexToFind === currentIndex) return nums[currentIndex]; else if (indexToFind < currentIndex) return quickSelect(left, currentIndex - 1, indexToFind); else return quickSelect(currentIndex + 1, right, indexToFind; }; return quickSelect(0, nums.length - 1, k - 1); };",No,No,O(n),4
"const combinationSum = (candidates, target) => { const result = []; const backtrack = (start, target, path) => { if (target === 0) result.push([...path]); for (let i = start; i < candidates.length; i++) { if (candidates[i] > target) continue; path.push(candidates[i]); backtrack(i, target - candidates[i], path); path.pop(); } }; backtrack(0, target, []); return result; };",No,No,O(2^n),4
"const maxSubArray = (nums) => { let maxSoFar = nums[0], maxEndingHere = nums[0]; for (let i = 1; i < nums.length; i++) { maxEndingHere = Math.max(nums[i], maxEndingHere + nums[i]); maxSoFar = Math.max(maxSoFar, maxEndingHere); } return maxSoFar; };",No,No,O(n),4
"const productExceptSelf = (nums) => { const output = Array(nums.length).fill(1); let leftProduct = 1; for (let i = 0; i < nums.length; i++) { output[i] *= leftProduct; leftProduct *= nums[i]; } let rightProduct = 1; for (let i = nums.length - 1; i >= 0; i--) { output[i] *= rightProduct; rightProduct *= nums[i]; } return output; };",No,No,O(n),4
"const groupAnagrams = (strs) => { const map = {}; for (const str of strs) { const sortedStr = str.split('').sort().join(''); if (!map[sortedStr]) map[sortedStr] = []; map[sortedStr].push(str); } return Object.values(map); };",No,No,O(nk log k),4
"const sortColors = (nums) => { let zeroIndex = 0, twoIndex = nums.length - 1; for (let i = 0; i <= twoIndex; i++) { while (nums[i] === 2 && i < twoIndex) [nums[i], nums[twoIndex]] = [nums[twoIndex], nums[i]], twoIndex--; while (nums[i] === 0 && i > zeroIndex) [nums[i], nums[zeroIndex]] = [nums[zeroIndex], nums[i]], zeroIndex++; } };",No,No,O(n),4
"const validPalindrome = (s) => { const isPalindrome = (s, left, right) => { while (left < right) { if (s[left] !== s[right]) return false; left++; right--; } return true; }; for (let i = 0; i < s.length; i++) { if (isPalindrome(s, i, s.length - 1 - i)) return true; } return false; };",No,No,O(n),4
"const maxProduct = (nums) => { let maxProduct = 0; for (let i = 0; i < nums.length; i++) { for (let j = i + 1; j < nums.length; j++) { maxProduct = Math.max(maxProduct, (nums[i] - 1) * (nums[j] - 1)); } } return maxProduct; };",No,No,O(n^2),4
"const longestCommonPrefix = (strs) => { if (strs.length === 0) return ''; let prefix = strs[0]; for (let i = 1; i < strs.length; i++) { while (strs[i].indexOf(prefix) !== 0) { prefix = prefix.slice(0, -1); } } return prefix; };",No,No,O(nm),4
"const minPathSum = (grid) => { const m = grid.length, n = grid[0].length; const dp = Array(m).fill().map(() => Array(n).fill(0)); dp[0][0] = grid[0][0]; for (let i = 1; i < m; i++) dp[i][0] = dp[i - 1][0] + grid[i][0]; for (let j = 1; j < n; j++) dp[0][j] = dp[0][j - 1] + grid[0][j]; for (let i = 1; i < m; i++) { for (let j = 1; j < n; j++) { dp[i][j] = grid[i][j] + Math.min(dp[i - 1][j], dp[i][j - 1]); } } return dp[m - 1][n - 1]; };",No,No,O(mn),4
"const setZeroes = (matrix) => { const rows = new Set(), cols = new Set(); for (let i = 0; i < matrix.length; i++) { for (let j = 0; j < matrix[0].length; j++) { if (matrix[i][j] === 0) { rows.add(i); cols.add(j); } } } for (let i = 0; i < matrix.length; i++) { for (let j = 0; j < matrix[0].length; j++) { if (rows.has(i) || cols.has(j)) matrix[i][j] = 0; } } };",No,No,O(mn),4
"const findDuplicate = (nums) => { let slow = nums[0], fast = nums[0]; do { slow = nums[slow]; fast = nums[nums[fast]]; } while (slow !== fast); slow = nums[0]; while (slow !== fast) { slow = nums[slow]; fast = nums[fast]; } return slow; };",No,No,O(n),4
"const isValidSudoku = (board) => { const rows = Array(9).fill(0).map(() => new Set()), cols = Array(9).fill(0).map(() => new Set()), boxes = Array(9).fill(0).map(() => new Set()); for (let i = 0; i < 9; i++) { for (let j = 0; j < 9; j++) { const num = board[i][j]; if (num === '.') continue; const boxIndex = Math.floor(i / 3) * 3 + Math.floor(j / 3); if (rows[i].has(num) || cols[j].has(num) || boxes[boxIndex].has(num)) return false; rows[i].add(num); cols[j].add(num); boxes[boxIndex].add(num); } } return true; };",No,No,O(n^2),4
"const combinationSum2 = (candidates, target) => { const result = []; const backtrack = (start, target, path) => { if (target === 0) result.push([...path]); for (let i = start; i < candidates.length; i++) { if (i > start && candidates[i] === candidates[i - 1]) continue; if (candidates[i] > target) continue; path.push(candidates[i]); backtrack(i + 1, target - candidates[i], path); path.pop(); } }; backtrack(0, target, []); return result; };",No,No,O(2^n),4
"const search = (nums, target) => { let left = 0, right = nums.length - 1; while (left <= right) { const mid = Math.floor((left + right) / 2); if (nums[mid] === target) return mid; else if (nums[mid] < target) left = mid + 1; else right = mid - 1; } return -1; };",No,No,O(log n),4
"const merge = (intervals) => { if (!intervals.length) return []; intervals.sort((a, b) => a[0] - b[0]); const merged = [intervals[0]]; for (let i = 1; i < intervals.length; i++) { const [start, end] = intervals[i]; const [lastStart, lastEnd] = merged[merged.length - 1]; if (start <= lastEnd) merged[merged.length - 1][1] = Math.max(lastEnd, end); else merged.push([start, end]); } return merged; };",No,No,O(n log n),4
"const reverseList = (head) => { let prev = null; while (head) { let next = head.next; head.next = prev; prev = head; head = next; } return prev; };",No,No,O(n),4
"const climbStairs = (n) => { const dp = Array(n + 1).fill(0); dp[0] = 1; for (let i = 1; i <= n; i++) { dp[i] = dp[i - 1]; if (i > 1) dp[i] += dp[i - 2]; } return dp[n]; };",No,No,O(n),4
"const wordBreak = (s, wordDict) => { const dp = Array(s.length + 1).fill(false); dp[0] = true; for (let i = 1; i <= s.length; i++) { for (let j = 0; j < i; j++) { if (dp[j] && wordDict.includes(s.slice(j, i))) { dp[i] = true; break; } } } return dp[s.length]; };",No,No,O(n^2),4
"const nthUglyNumber = (n) => { const dp = [1]; let i2 = 0, i3 = 0, i5 = 0; while (dp.length < n) { const nextUgly = Math.min(dp[i2] * 2, dp[i3] * 3, dp[i5] * 5); dp.push(nextUgly); if (nextUgly === dp[i2] * 2) i2++; if (nextUgly === dp[i3] * 3) i3++; if (nextUgly === dp[i5] * 5) i5++; } return dp[n - 1]; };",No,No,O(n),4
"const spiralOrder = (matrix) => { const result = []; while (matrix.length) { result.push(...matrix.shift()); matrix = matrix[0].map((_, i) => matrix.map(row => row[i])).reverse(); } return result; };",No,No,O(n),4
"const pacificAtlantic = (heights) => { const m = heights.length, n = heights[0].length; const pacific = Array.from({ length: m }, () => Array(n).fill(false)); const atlantic = Array.from({ length: m }, () => Array(n).fill(false)); const dfs = (x, y, visited) => { visited[x][y] = true; for (const [dx, dy] of [[1, 0], [-1, 0], [0, 1], [0, -1]]) { const nx = x + dx, ny = y + dy; if (nx >= 0 && ny >= 0 && nx < m && ny < n && !visited[nx][ny] && heights[nx][ny] >= heights[x][y]) dfs(nx, ny, visited); } }; for (let i = 0; i < m; i++) { dfs(i, 0, pacific); dfs(i, n - 1, atlantic); } for (let j = 0; j < n; j++) { dfs(0, j, pacific); dfs(m - 1, j, atlantic); } const result = []; for (let i = 0; i < m; i++) { for (let j = 0; j < n; j++) { if (pacific[i][j] && atlantic[i][j]) result.push([i, j]); } } return result; };",No,No,O(mn),4
"const canJump = (nums) => { let reachable = 0; for (let i = 0; i < nums.length; i++) { if (i > reachable) return false; reachable = Math.max(reachable, i + nums[i]); } return true; };",No,No,O(n),4
"const lengthOfLIS = (nums) => { const dp = []; for (let num of nums) { const index = dp.findIndex((x) => x >= num); if (index === -1) dp.push(num); else dp[index] = num; } return dp.length; };",No,No,O(n log n),4
"const uniquePaths = (m, n) => { const dp = Array(m).fill().map(() => Array(n).fill(1)); for (let i = 1; i < m; i++) { for (let j = 1; j < n; j++) { dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } return dp[m - 1][n - 1]; };",No,No,O(mn),4
"const binaryTreePaths = (root) => { const result = []; const dfs = (node, path) => { if (!node) return; path += node.val + '->'; if (!node.left && !node.right) result.push(path.slice(0, -2)); dfs(node.left, path); dfs(node.right, path); }; dfs(root, ''); return result; };",No,No,O(n),4
"const removeDuplicates = (nums) => { let n = nums.length; if (n === 0) return 0; let j = 0; for (let i = 1; i < n; i++) { if (nums[i] !== nums[j]) { j++; nums[j] = nums[i]; } } return j + 1; };",No,No,O(n),4
"const countBits = (n) => { const res = []; for (let i = 0; i <= n; i++) res[i] = res[i >> 1] + (i & 1); return res; };",No,No,O(n),4
"const longestSubstring = (s, k) => { const map = {}; for (const char of s) map[char] = (map[char] || 0) + 1; const maxUnique = Object.keys(map).length; let maxLength = 0; for (let i = 1; i <= maxUnique; i++) { let left = 0, right = 0; const windowMap = {}; while (right < s.length) { windowMap[s[right]] = (windowMap[s[right]] || 0) + 1; while (Object.keys(windowMap).length > i) windowMap[s[left++]]--; if (Object.keys(windowMap).length === i) maxLength = Math.max(maxLength, right - left + 1); right++; } } return maxLength; };",No,No,O(n^2),4
"const minimumTotal = (triangle) => { const n = triangle.length; const dp = Array(n).fill(0); for (let row = n - 1; row >= 0; row--) { for (let col = 0; col <= row; col++) { dp[col] = triangle[row][col] + Math.min(dp[col], dp[col + 1]); } } return dp[0]; };",No,No,O(n),4
"const findMin = (nums) => { let left = 0, right = nums.length - 1; while (left < right) { const mid = Math.floor((left + right) / 2); if (nums[mid] > nums[right]) left = mid + 1; else right = mid; } return nums[left]; };",No,No,O(log n),4
"const isSymmetric = (root) => { const check = (left, right) => { if (!left && !right) return true; if (!left || !right) return false; return left.val === right.val && check(left.left, right.right) && check(left.right, right.left); }; return check(root.left, root.right); };",No,No,O(n),4
"const shortestPath = (grid) => { const m = grid.length, n = grid[0].length; const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]]; const queue = [[0, 0, 1]]; const visited = new Set(); while (queue.length) { const [x, y, steps] = queue.shift(); if (x === m - 1 && y === n - 1) return steps; for (const [dx, dy] of directions) { const nx = x + dx, ny = y + dy; if (nx >= 0 && ny >= 0 && nx < m && ny < n && grid[nx][ny] === 0) { queue.push([nx, ny, steps + 1]); grid[nx][ny] = -1; } } } return -1; };",No,No,O(mn),4
"const largestRectangleArea = (heights) => { const stack = []; heights.push(0); let maxArea = 0; for (let i = 0; i < heights.length; i++) { while (stack.length && heights[stack[stack.length - 1]] > heights[i]) { const h = heights[stack.pop()]; const width = stack.length ? i - stack[stack.length - 1] - 1 : i; maxArea = Math.max(maxArea, h * width); } stack.push(i); } return maxArea; };",No,No,O(n),4
"const maxAreaOfIsland = (grid) => { const m = grid.length, n = grid[0].length; const visited = new Set(); const dfs = (x, y) => { if (x < 0 || x >= m || y < 0 || y >= n || grid[x][y] === 0 || visited.has(`${x},${y}`)) return 0; visited.add(`${x},${y}`); return 1 + dfs(x + 1, y) + dfs(x - 1, y) + dfs(x, y + 1) + dfs(x, y - 1); }; let maxArea = 0; for (let i = 0; i < m; i++) { for (let j = 0; j < n; j++) { if (grid[i][j] === 1 && !visited.has(`${i},${j}`)) maxArea = Math.max(maxArea, dfs(i, j)); } } return maxArea; };",No,No,O(mn),4
"const minPathSum = (grid) => { const m = grid.length, n = grid[0].length; for (let i = 0; i < m; i++) for (let j = 0; j < n; j++) if (i > 0 && j > 0) grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]); return grid[m - 1][n - 1]; };",No,No,O(mn),4
"const myAtoi = (s) => { let i = 0, sign = 1; while (s[i] === ' ') i++; if (s[i] === '-' || s[i] === '+') sign = s[i++] === '-' ? -1 : 1; let num = 0; while (i < s.length && /\d/.test(s[i])) { num = num * 10 + (s[i++] - '0'); } return Math.min(Math.max(sign * num, -2147483648), 2147483647); };",No,No,O(n),4
"const isValid = (s) => { const stack = []; const map = { '(': ')', '{': '}', '[': ']' }; for (const char of s) { if (char in map) stack.push(map[char]); else if (stack.pop() !== char) return false; } return stack.length === 0; };",No,No,O(n),4
"const search = (nums, target) => { let left = 0, right = nums.length - 1; while (left <= right) { const mid = Math.floor((left + right) / 2); if (nums[mid] === target) return mid; if (nums[mid] < target) left = mid + 1; else right = mid - 1; } return -1; };",No,No,O(log n),4
"const letterCombinations = (digits) => { if (!digits.length) return []; const mapping = { '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz' }; const result = []; const backtrack = (index, path) => { if (index === digits.length) { result.push(path); return; } for (const char of mapping[digits[index]]) { backtrack(index + 1, path + char); } }; backtrack(0, ''); return result; };",No,No,O(3^n),4
"const removeElement = (nums, val) => { let k = 0; for (let i = 0; i < nums.length; i++) { if (nums[i] !== val) nums[k++] = nums[i]; } return k; };",No,No,O(n),4
"const maxProduct = (nums) => { let max = nums[0], min = nums[0], result = nums[0]; for (let i = 1; i < nums.length; i++) { if (nums[i] < 0) [max, min] = [min, max]; max = Math.max(nums[i], max * nums[i]); min = Math.min(nums[i], min * nums[i]); result = Math.max(result, max); } return result; };",No,No,O(n),4
"const largestSumAfterKNegations = (nums, k) => { nums.sort((a, b) => a - b); for (let i = 0; i < k; i++) nums[0] = -nums[0]; nums.sort((a, b) => a - b); return nums.reduce((sum, num) => sum + num, 0); };",No,No,O(n log n),4
"const countSubstrings = (s) => { let count = 0; const isPalindrome = (left, right) => { while (left >= 0 && right < s.length && s[left] === s[right]) { count++; left--; right++; } }; for (let i = 0; i < s.length; i++) { isPalindrome(i, i); isPalindrome(i, i + 1); } return count; };",No,No,O(n^2),4
"const canConstruct = (ransomNote, magazine) => { const count = {}; for (const char of magazine) count[char] = (count[char] || 0) + 1; for (const char of ransomNote) { if (!count[char]) return false; count[char]--; } return true; };",No,No,O(m + n),4
"const coinChange = (coins, amount) => { const dp = Array(amount + 1).fill(Infinity); dp[0] = 0; for (const coin of coins) { for (let i = coin; i <= amount; i++) { dp[i] = Math.min(dp[i], dp[i - coin] + 1); } } return dp[amount] === Infinity ? -1 : dp[amount]; };",No,No,O(n * amount),4
"const findDuplicate = (nums) => { let slow = nums[0], fast = nums[0]; while (true) { slow = nums[slow]; fast = nums[nums[fast]]; if (slow === fast) break; } let ptr1 = nums[0], ptr2 = slow; while (ptr1 !== ptr2) { ptr1 = nums[ptr1]; ptr2 = nums[ptr2]; } return ptr1; };",No,No,O(n),4
"const longestValidParentheses = (s) => { const stack = [-1]; let maxLen = 0; for (let i = 0; i < s.length; i++) { if (s[i] === '(') stack.push(i); else { stack.pop(); if (stack.length) maxLen = Math.max(maxLen, i - stack[stack.length - 1]); else stack.push(i); } } return maxLen; };",No,No,O(n),4
"const maxArea = (height) => { let maxArea = 0, left = 0, right = height.length - 1; while (left < right) { maxArea = Math.max(maxArea, Math.min(height[left], height[right]) * (right - left)); if (height[left] < height[right]) left++; else right--; } return maxArea; };",No,No,O(n),4
"const minWindow = (s, t) => { const countT = {}; for (const char of t) countT[char] = (countT[char] || 0) + 1; let required = Object.keys(countT).length; let l = 0, r = 0, formed = 0; const windowCounts = {}; let ans = [Infinity, null, null]; while (r < s.length) { const char = s[r]; windowCounts[char] = (windowCounts[char] || 0) + 1; if (countT[char] && windowCounts[char] === countT[char]) formed++; while (l <= r && formed === required) { const char = s[l]; if (r - l + 1 < ans[0]) ans = [r - l + 1, l, r]; windowCounts[char]--; if (countT[char] && windowCounts[char] < countT[char]) formed--; l++; } r++; } return ans[0] === Infinity ? "" : s.slice(ans[1], ans[2] + 1); };",No,No,O(n),4
"const isPalindrome = (s) => { s = s.replace(/[^a-zA-Z0-9]/g, '').toLowerCase(); return s === s.split('').reverse().join(''); };",No,No,O(n),3
"function generate(numRows) { const triangle = []; for (let i = 0; i < numRows; i++) { triangle[i] = [1]; for (let j = 1; j < i; j++) { triangle[i][j] = triangle[i - 1][j - 1] + triangle[i - 1][j]; } if (i > 0) triangle[i].push(1); } return triangle; }",No,No,O(n^2),3
"const reverseString = (s) => s.split('').reverse().join('');",No,No,O(n),3
"function countPrimes(n) { let count = 0; const isPrime = Array(n).fill(true); for (let i = 2; i * i < n; i++) { if (isPrime[i]) { for (let j = i * i; j < n; j += i) { isPrime[j] = false; } } } for (let i = 2; i < n; i++) { if (isPrime[i]) count++; } return count; }",No,No,O(n log log n),3
"const longestCommonPrefix = (strs) => { if (!strs.length) return ''; let prefix = strs[0]; for (let i = 1; i < strs.length; i++) { while (strs[i].indexOf(prefix) !== 0) { prefix = prefix.substring(0, prefix.length - 1); } } return prefix; };",No,No,O(n * m),3
"const maxSubArray = (nums) => { let maxSum = nums[0], currentSum = nums[0]; for (let i = 1; i < nums.length; i++) { currentSum = Math.max(nums[i], currentSum + nums[i]); maxSum = Math.max(maxSum, currentSum); } return maxSum; };",No,No,O(n),3
"function twoSum(nums, target) { const map = new Map(); for (let i = 0; i < nums.length; i++) { const complement = target - nums[i]; if (map.has(complement)) return [map.get(complement), i]; map.set(nums[i], i); } }",No,No,O(n),3
"const climbStairs = (n) => { if (n <= 1) return 1; let first = 1, second = 1; for (let i = 2; i <= n; i++) { const temp = first; first = first + second; second = temp; } return first; };",No,No,O(n),3
"const removeDuplicates = (nums) => { if (nums.length === 0) return 0; let k = 1; for (let i = 1; i < nums.length; i++) { if (nums[i] !== nums[i - 1]) { nums[k] = nums[i]; k++; } } return k; };",No,No,O(n),3
"function mergeTwoLists(l1, l2) { const dummy = new ListNode(0); let tail = dummy; while (l1 && l2) { if (l1.val < l2.val) { tail.next = l1; l1 = l1.next; } else { tail.next = l2; l2 = l2.next; } tail = tail.next; } tail.next = l1 || l2; return dummy.next; }",No,No,O(n + m),3
"const singleNumber = (nums) => { return nums.reduce((a, b) => a ^ b); };",No,No,O(n),3
"function diameterOfBinaryTree(root) { let maxDiameter = 0; const dfs = (node) => { if (!node) return 0; const left = dfs(node.left); const right = dfs(node.right); maxDiameter = Math.max(maxDiameter, left + right); return Math.max(left, right) + 1; }; dfs(root); return maxDiameter; }",No,No,O(n),3
"const validParentheses = (s) => { const stack = []; const map = { '(': ')', '{': '}', '[': ']' }; for (const char of s) { if (map[char]) stack.push(char); else if (stack.length === 0 || char !== map[stack.pop()]) return false; } return stack.length === 0; };",No,No,O(n),3
"const groupAnagrams = (strs) => { const map = {}; for (const str of strs) { const key = str.split('').sort().join(''); if (!map[key]) map[key] = []; map[key].push(str); } return Object.values(map); };",No,No,O(n * m log m),3
"const searchInsert = (nums, target) => { let left = 0, right = nums.length - 1; while (left <= right) { const mid = Math.floor((left + right) / 2); if (nums[mid] === target) return mid; if (nums[mid] < target) left = mid + 1; else right = mid - 1; } return left; };",No,No,O(log n),3
"function lengthOfLongestSubstring(s) { const set = new Set(); let left = 0, maxLength = 0; for (let right = 0; right < s.length; right++) { while (set.has(s[right])) { set.delete(s[left]); left++; } set.add(s[right]); maxLength = Math.max(maxLength, right - left + 1); } return maxLength; }",No,No,O(n),3
"const rotateArray = (nums, k) => { k %= nums.length; const reverse = (arr, start, end) => { while (start < end) { [arr[start], arr[end]] = [arr[end], arr[start]]; start++; end--; } }; reverse(nums, 0, nums.length - 1); reverse(nums, 0, k - 1); reverse(nums, k, nums.length - 1); };",No,No,O(n),3
"function isValidBST(root) { const validate = (node, min, max) => { if (!node) return true; if (node.val <= min || node.val >= max) return false; return validate(node.left, min, node.val) && validate(node.right, node.val, max); }; return validate(root, -Infinity, Infinity); }",No,No,O(n),3
"const permute = (nums) => { const result = []; const backtrack = (path) => { if (path.length === nums.length) result.push([...path]); for (const num of nums) { if (!path.includes(num)) { path.push(num); backtrack(path); path.pop(); } } }; backtrack([]); return result; };",No,No,O(n * n!),3
"const maxDepth = (root) => { if (!root) return 0; return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1; };",No,No,O(n),3
"function findKthLargest(nums, k) { const quickSelect = (left, right) => { if (left === right) return nums[left]; const pivotIndex = Math.floor((left + right) / 2); const pivot = nums[pivotIndex]; const index = partition(left, right, pivot); if (k === index) return nums[index]; else if (k < index) return quickSelect(left, index - 1); else return quickSelect(index + 1, right); }; const partition = (left, right, pivot) => { let pivotIndex = left; for (let i = left; i <= right; i++) { if (nums[i] > pivot) { [nums[pivotIndex], nums[i]] = [nums[i], nums[pivotIndex]]; pivotIndex++; } } return pivotIndex; }; return quickSelect(0, nums.length - 1); }",No,No,O(n),3
"const twoSumSorted = (numbers, target) => { let left = 0, right = numbers.length - 1; while (left < right) { const sum = numbers[left] + numbers[right]; if (sum === target) return [left + 1, right + 1]; else if (sum < target) left++; else right--; } return []; };",No,No,O(n),3
"function searchMatrix(matrix, target) { if (!matrix.length || !matrix[0].length) return false; let left = 0, right = matrix.length * matrix[0].length - 1; while (left <= right) { const mid = Math.floor((left + right) / 2); const midValue = matrix[Math.floor(mid / matrix[0].length)][mid % matrix[0].length]; if (midValue === target) return true; if (midValue < target) left = mid + 1; else right = mid - 1; } return false; }",No,No,O(log(m * n)),3
"const isSubsequence = (s, t) => { let i = 0; for (const char of t) { if (char === s[i]) i++; if (i === s.length) return true; } return i === s.length; };",No,No,O(n),3
"function combinationSum(candidates, target) { const result = []; const backtrack = (start, currentSum, currentCombination) => { if (currentSum === target) { result.push([...currentCombination]); return; } if (currentSum > target) return; for (let i = start; i < candidates.length; i++) { currentCombination.push(candidates[i]); backtrack(i, currentSum + candidates[i], currentCombination); currentCombination.pop(); } }; backtrack(0, 0, []); return result; }",No,No,O(n * 2^n),3
"const removeNthFromEnd = (head, n) => { const dummy = new ListNode(0, head); let first = dummy, second = dummy; for (let i = 0; i <= n; i++) first = first.next; while (first) { first = first.next; second = second.next; } second.next = second.next.next; return dummy.next; };",No,No,O(n),3
"const intersect = (nums1, nums2) => { const count = {}; for (const num of nums1) count[num] = (count[num] || 0) + 1; const result = []; for (const num of nums2) { if (count[num] > 0) { result.push(num); count[num]--; } } return result; };",No,No,O(n + m),3
"const validAnagram = (s, t) => { if (s.length !== t.length) return false; const count = {}; for (const char of s) { count[char] = (count[char] || 0) + 1; } for (const char of t) { if (!count[char]) return false; count[char]--; } return true; };",No,No,O(n),3
"const flipAndInvertImage = (A) => { for (const row of A) { row.reverse(); for (let i = 0; i < row.length; i++) row[i] = row[i] ^ 1; } return A; };",No,No,O(n),3
"function minPathSum(grid) { const m = grid.length, n = grid[0].length; for (let i = 0; i < m; i++) { for (let j = 0; j < n; j++) { if (i === 0 && j === 0) continue; grid[i][j] += Math.min(i > 0 ? grid[i - 1][j] : Infinity, j > 0 ? grid[i][j - 1] : Infinity); } } return grid[m - 1][n - 1]; }",No,No,O(m * n),3
"const lengthOfLastWord = (s) => { const words = s.trim().split(' '); return words[words.length - 1].length; };",No,No,O(n),3
"const isHappy = (n) => { const seen = new Set(); while (n !== 1 && !seen.has(n)) { seen.add(n); n = n.toString().split('').reduce((sum, num) => sum + num ** 2, 0); } return n === 1; };",No,No,O(log n),3
"function combinationSum2(candidates, target) { const result = []; candidates.sort((a, b) => a - b); const backtrack = (start, currentSum, currentCombination) => { if (currentSum === target) { result.push([...currentCombination]); return; } if (currentSum > target) return; for (let i = start; i < candidates.length; i++) { if (i > start && candidates[i] === candidates[i - 1]) continue; currentCombination.push(candidates[i]); backtrack(i + 1, currentSum + candidates[i], currentCombination); currentCombination.pop(); } }; backtrack(0, 0, []); return result; }",No,No,O(n * 2^n),3
"const myAtoi = (s) => { let i = 0, sign = 1, total = 0; while (s[i] === ' ') i++; if (s[i] === '-' || s[i] === '+') sign = s[i++] === '-' ? -1 : 1; while (s[i] >= '0' && s[i] <= '9') { total = total * 10 + (s[i++] - '0'); } return Math.max(Math.min(sign * total, 2 ** 31 - 1), -(2 ** 31)); };",No,No,O(n),3
"const countBits = (num) => { const count = new Array(num + 1).fill(0); for (let i = 1; i <= num; i++) { count[i] = count[i >> 1] + (i & 1); } return count; };",No,No,O(n),3
"function mergeKLists(lists) { const mergeTwoLists = (l1, l2) => { const dummy = new ListNode(0); let tail = dummy; while (l1 && l2) { if (l1.val < l2.val) { tail.next = l1; l1 = l1.next; } else { tail.next = l2; l2 = l2.next; } tail = tail.next; } tail.next = l1 || l2; return dummy.next; }; if (!lists.length) return null; let mergedList = lists[0]; for (let i = 1; i < lists.length; i++) { mergedList = mergeTwoLists(mergedList, lists[i]); } return mergedList; }",No,No,O(n log k),3
"const validTicTacToe = (board) => { const countX = board.flat().filter(c => c === 'X').length; const countO = board.flat().filter(c => c === 'O').length; const xWins = (b) => (b[0][0] === b[0][1] && b[0][1] === b[0][2] && b[0][0] !== '') || ...; return (countX === countO || countX === countO + 1) && !xWins(board) && !xWins(board.map(row => row.map(c => c === 'X' ? 'O' : c === 'O' ? 'X' : c))); };",No,No,O(1),3
"const plusOne = (digits) => { for (let i = digits.length - 1; i >= 0; i--) { if (digits[i] < 9) { digits[i]++; return digits; } digits[i] = 0; } return [1, ...digits]; };",No,No,O(n),3
"function maxArea(height) { let left = 0, right = height.length - 1; let maxArea = 0; while (left < right) { maxArea = Math.max(maxArea, Math.min(height[left], height[right]) * (right - left)); height[left] < height[right] ? left++ : right--; } return maxArea; }",No,No,O(n),3
"const rotate = (nums, k) => { const n = nums.length; k %= n; const reverse = (arr, start, end) => { while (start < end) { [arr[start], arr[end]] = [arr[end], arr[start]]; start++; end--; } }; reverse(nums, 0, n - 1); reverse(nums, 0, k - 1); reverse(nums, k, n - 1); };",No,No,O(n),3
"function canJump(nums) { let farthest = 0; for (let i = 0; i < nums.length; i++) { if (i > farthest) return false; farthest = Math.max(farthest, i + nums[i]); } return true; }",No,No,O(n),3
"const findDuplicate = (nums) => { let slow = nums[0], fast = nums[0]; do { slow = nums[slow]; fast = nums[nums[fast]]; } while (slow !== fast); let ptr1 = nums[0], ptr2 = slow; while (ptr1 !== ptr2) { ptr1 = nums[ptr1]; ptr2 = nums[ptr2]; } return ptr1; };",No,No,O(n),3
"const trap = (height) => { const n = height.length; if (n === 0) return 0; const leftMax = new Array(n).fill(0); const rightMax = new Array(n).fill(0); leftMax[0] = height[0]; for (let i = 1; i < n; i++) { leftMax[i] = Math.max(leftMax[i - 1], height[i]); } rightMax[n - 1] = height[n - 1]; for (let i = n - 2; i >= 0; i--) { rightMax[i] = Math.max(rightMax[i + 1], height[i]); } let waterTrapped = 0; for (let i = 0; i < n; i++) { waterTrapped += Math.min(leftMax[i], rightMax[i]) - height[i]; } return waterTrapped; };",No,No,O(n),3
"const searchInsert = (nums, target) => { let left = 0, right = nums.length - 1; while (left <= right) { const mid = Math.floor((left + right) / 2); if (nums[mid] === target) return mid; if (nums[mid] < target) left = mid + 1; else right = mid - 1; } return left; };",No,No,O(log n),3
"const sortedArrayToBST = (nums) => { if (!nums.length) return null; const mid = Math.floor(nums.length / 2); const node = new TreeNode(nums[mid]); node.left = sortedArrayToBST(nums.slice(0, mid)); node.right = sortedArrayToBST(nums.slice(mid + 1)); return node; };",No,No,O(n),3
"function longestCommonPrefix(strs) { if (!strs.length) return ''; let prefix = strs[0]; for (let i = 1; i < strs.length; i++) { while (strs[i].indexOf(prefix) !== 0) { prefix = prefix.substring(0, prefix.length - 1); } } return prefix; }",No,No,O(n * m),3
"const canConstruct = (ransomNote, magazine) => { const count = {}; for (const char of magazine) { count[char] = (count[char] || 0) + 1; } for (const char of ransomNote) { if (!count[char]) return false; count[char]--; } return true; };",No,No,O(n + m),3
"const generateParenthesis = (n) => { const result = []; const backtrack = (current, open, close) => { if (current.length === n * 2) { result.push(current); return; } if (open < n) backtrack(current + '(', open + 1, close); if (close < open) backtrack(current + ')', open, close + 1); }; backtrack('', 0, 0); return result; };",No,No,O(4^n / n),3
"const getRow = (rowIndex) => { const result = []; for (let i = 0; i <= rowIndex; i++) { const row = new Array(i + 1).fill(1); for (let j = 1; j < i; j++) { row[j] = result[i - 1][j - 1] + result[i - 1][j]; } result.push(row); } return result[rowIndex]; };",No,No,O(n^2),3
"const letterCombinations = (digits) => { if (!digits) return []; const mapping = { '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz' }; const result = []; const backtrack = (index, current) => { if (current.length === digits.length) { result.push(current); return; } for (const char of mapping[digits[index]]) { backtrack(index + 1, current + char); } }; backtrack(0, ''); return result; };",No,No,O(3^n),3
"const numIslands = (grid) => { if (!grid.length) return 0; let count = 0; const dfs = (r, c) => { if (r < 0 || c < 0 || r >= grid.length || c >= grid[0].length || grid[r][c] === '0') return; grid[r][c] = '0'; dfs(r + 1, c); dfs(r - 1, c); dfs(r, c + 1); dfs(r, c - 1); }; for (let r = 0; r < grid.length; r++) { for (let c = 0; c < grid[0].length; c++) { if (grid[r][c] === '1') { count++; dfs(r, c); } } } return count; };",No,No,O(m * n),3
"const lengthOfLIS = (nums) => { const dp = Array(nums.length).fill(1); for (let i = 1; i < nums.length; i++) { for (let j = 0; j < i; j++) { if (nums[i] > nums[j]) dp[i] = Math.max(dp[i], dp[j] + 1); } } return Math.max(...dp); };",No,No,O(n^2),3
"const uniquePaths = (m, n) => { const dp = Array.from({ length: m }, () => Array(n).fill(1)); for (let i = 1; i < m; i++) { for (let j = 1; j < n; j++) { dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } return dp[m - 1][n - 1]; };",No,No,O(m * n),3
"const searchRange = (nums, target) => { const binarySearch = (left) => { let low = 0, high = nums.length - 1; while (low <= high) { const mid = Math.floor((low + high) / 2); if (nums[mid] < target) low = mid + 1; else high = mid - 1; } return low; }; const leftIndex = binarySearch(true); const rightIndex = binarySearch(false) - 1; return leftIndex <= rightIndex ? [leftIndex, rightIndex] : [-1, -1]; };",No,No,O(log n),3
"const numSquares = (n) => { const dp = Array(n + 1).fill(Infinity); dp[0] = 0; for (let i = 1; i <= n; i++) { for (let j = 1; j * j <= i; j++) { dp[i] = Math.min(dp[i], dp[i - j * j] + 1); } } return dp[n]; };",No,No,O(n * n),3
"const maximalSquare = (matrix) => { if (!matrix.length) return 0; const dp = Array.from({ length: matrix.length }, () => Array(matrix[0].length).fill(0)); let maxSide = 0; for (let i = 0; i < matrix.length; i++) { for (let j = 0; j < matrix[0].length; j++) { if (matrix[i][j] === '1') { dp[i][j] = Math.min(dp[i - 1]?.[j - 1] || 0, dp[i - 1]?.[j] || 0, dp[i][j - 1] || 0) + 1; maxSide = Math.max(maxSide, dp[i][j]); } } } return maxSide * maxSide; };",No,No,O(m * n),3
"const minimumTotal = (triangle) => { for (let i = triangle.length - 2; i >= 0; i--) { for (let j = 0; j <= i; j++) { triangle[i][j] += Math.min(triangle[i + 1][j], triangle[i + 1][j + 1]); } } return triangle[0][0]; };",No,No,O(n^2),3
"const binaryTreePaths = (root) => { const result = []; const traverse = (node, path) => { if (!node) return; path += node.val; if (!node.left && !node.right) result.push(path); else { path += '->'; traverse(node.left, path); traverse(node.right, path); } }; traverse(root, ''); return result; };",No,No,O(n),3
"const longestPalindrome = (s) => { if (s.length < 2) return s; let start = 0, end = 0; const expandAroundCenter = (left, right) => { while (left >= 0 && right < s.length && s[left] === s[right]) { left--; right++; } return right - left - 1; }; for (let i = 0; i < s.length; i++) { const len1 = expandAroundCenter(i, i); const len2 = expandAroundCenter(i, i + 1); const len = Math.max(len1, len2); if (len > end - start) { start = i - Math.floor((len - 1) / 2); end = i + Math.floor(len / 2); } } return s.substring(start, end + 1); };",No,No,O(n^2),3
"const twoSum = (nums, target) => { const map = new Map(); for (let i = 0; i < nums.length; i++) { const complement = target - nums[i]; if (map.has(complement)) return [map.get(complement), i]; map.set(nums[i], i); } };",No,No,O(n),3
"const reverseKGroup = (head, k) => { let count = 0, current = head; while (current && count !== k) { current = current.next; count++; } if (count === k) { current = reverseKGroup(current, k); while (count-- > 0) { const temp = head.next; head.next = current; current = head; head = temp; } head = current; } return head; };",No,No,O(n),3
"const climbStairs = (n) => { const dp = Array(n + 1).fill(0); dp[0] = 1; for (let i = 1; i <= n; i++) { dp[i] += dp[i - 1]; if (i > 1) dp[i] += dp[i - 2]; } return dp[n]; };",No,No,O(n),3
"const threeSum = (nums) => { const result = []; nums.sort((a, b) => a - b); for (let i = 0; i < nums.length - 2; i++) { if (i > 0 && nums[i] === nums[i - 1]) continue; let left = i + 1, right = nums.length - 1; while (left < right) { const sum = nums[i] + nums[left] + nums[right]; if (sum < 0) left++; else if (sum > 0) right--; else { result.push([nums[i], nums[left], nums[right]]); while (nums[left] === nums[left + 1]) left++; while (nums[right] === nums[right - 1]) right--; left++; right--; } } } return result; };",No,No,O(n^2),3
"const isValid = (s) => { const stack = []; const map = { '(': ')', '{': '}', '[': ']' }; for (let char of s) { if (map[char]) stack.push(map[char]); else if (char !== stack.pop()) return false; } return stack.length === 0; };",No,No,O(n),3
"const permute = (nums) => { const result = []; const backtrack = (current, remaining) => { if (!remaining.length) { result.push(current); return; } for (let i = 0; i < remaining.length; i++) { backtrack(current.concat(remaining[i]), remaining.slice(0, i).concat(remaining.slice(i + 1))); } }; backtrack([], nums); return result; };",No,No,O(n!),3
"const findMedianSortedArrays = (nums1, nums2) => { const merged = []; let i = 0, j = 0; while (i < nums1.length || j < nums2.length) { if (j === nums2.length || (i < nums1.length && nums1[i] < nums2[j])) merged.push(nums1[i++]); else merged.push(nums2[j++]); } const mid = merged.length / 2; return mid % 1 ? merged[Math.floor(mid)] : (merged[mid / 2 - 1] + merged[mid / 2]) / 2; };",No,No,O(n),3
"const mergeKLists = (lists) => { const mergeTwoLists = (l1, l2) => { let dummy = new ListNode(0); let current = dummy; while (l1 && l2) { if (l1.val < l2.val) { current.next = l1; l1 = l1.next; } else { current.next = l2; l2 = l2.next; } current = current.next; } current.next = l1 || l2; return dummy.next; }; return lists.reduce((acc, list) => mergeTwoLists(acc, list), null); };",No,No,O(n log k),3
"const rotate = (nums, k) => { k %= nums.length; reverse(nums, 0, nums.length - 1); reverse(nums, 0, k - 1); reverse(nums, k, nums.length - 1); }; const reverse = (nums, start, end) => { while (start < end) { [nums[start], nums[end]] = [nums[end], nums[start]]; start++; end--; } };",No,No,O(n),3
"const isPalindrome = (s) => { const cleaned = s.replace(/[^a-zA-Z0-9]/g, '').toLowerCase(); return cleaned === cleaned.split('').reverse().join(''); };",No,No,O(n),3
"const removeDuplicates = (nums) => { let i = 0; for (let j = 1; j < nums.length; j++) { if (nums[i] !== nums[j]) nums[++i] = nums[j]; } return i + 1; };",No,No,O(n),3
"const maximumProduct = (nums) => { nums.sort((a, b) => a - b); return Math.max(nums[0] * nums[1] * nums[2], nums[0] * nums[nums.length - 1] * nums[nums.length - 2]); };",No,No,O(n log n),3
"const firstMissingPositive = (nums) => { const n = nums.length; for (let i = 0; i < n; i++) { while (nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] !== nums[i]) { const temp = nums[i]; nums[i] = nums[temp - 1]; nums[temp - 1] = temp; } } for (let i = 0; i < n; i++) { if (nums[i] !== i + 1) return i + 1; } return n + 1; };",No,No,O(n),3
"const lengthOfLastWord = (s) => { return s.trim().split(' ').pop().length; };",No,No,O(n),3
"const search = (nums, target) => { let left = 0, right = nums.length - 1; while (left <= right) { const mid = Math.floor((left + right) / 2); if (nums[mid] === target) return mid; if (nums[mid] < target) left = mid + 1; else right = mid - 1; } return -1; };",No,No,O(log n),3
"const addTwoNumbers = (l1, l2) => { let dummy = new ListNode(0), current = dummy, carry = 0; while (l1 || l2 || carry) { const sum = (l1 ? l1.val : 0) + (l2 ? l2.val : 0) + carry; carry = Math.floor(sum / 10); current.next = new ListNode(sum % 10); current = current.next; if (l1) l1 = l1.next; if (l2) l2 = l2.next; } return dummy.next; };",No,No,O(max(m, n)),3
"const removeElement = (nums, val) => { let k = 0; for (let i = 0; i < nums.length; i++) { if (nums[i] !== val) nums[k++] = nums[i]; } return k; };",No,No,O(n),3
"const findPeakElement = (nums) => { let left = 0, right = nums.length - 1; while (left < right) { const mid = Math.floor((left + right) / 2); if (nums[mid] < nums[mid + 1]) left = mid + 1; else right = mid; } return left; };",No,No,O(log n),3
"const longestSubarray = (nums, limit) => { const deque = []; let left = 0, result = 0; for (let right = 0; right < nums.length; right++) { while (deque.length && deque[deque.length - 1] < nums[right]) deque.pop(); deque.push(nums[right]); while (deque[0] - deque[deque.length - 1] > limit) left++; result = Math.max(result, right - left + 1); } return result; };",No,No,O(n),3
"const backspaceCompare = (S, T) => { const process = (s) => { const stack = []; for (const char of s) { if (char !== '#') stack.push(char); else stack.pop(); } return stack.join(''); }; return process(S) === process(T); };",No,No,O(n),3
"const isHappy = (n) => { const seen = new Set(); while (n !== 1 && !seen.has(n)) { seen.add(n); n = n.toString().split('').reduce((sum, digit) => sum + Math.pow(digit, 2), 0); } return n === 1; };",No,No,O(log n),3
"const uniquePathsWithObstacles = (obstacleGrid) => { const m = obstacleGrid.length, n = obstacleGrid[0].length; if (obstacleGrid[0][0] === 1 || obstacleGrid[m - 1][n - 1] === 1) return 0; const dp = Array(m).fill(null).map(() => Array(n).fill(0)); dp[0][0] = 1; for (let i = 0; i < m; i++) { for (let j = 0; j < n; j++) { if (obstacleGrid[i][j] === 1) dp[i][j] = 0; else { if (i > 0) dp[i][j] += dp[i - 1][j]; if (j > 0) dp[i][j] += dp[i][j - 1]; } } } return dp[m - 1][n - 1]; };",No,No,O(m * n),3
"const maxArea = (height) => { let left = 0, right = height.length - 1, maxArea = 0; while (left < right) { const area = Math.min(height[left], height[right]) * (right - left); maxArea = Math.max(maxArea, area); if (height[left] < height[right]) left++; else right--; } return maxArea; };",No,No,O(n),3
"const validParentheses = (s) => { const stack = []; const map = { '(': ')', '{': '}', '[': ']' }; for (let char of s) { if (map[char]) stack.push(map[char]); else if (char !== stack.pop()) return false; } return stack.length === 0; };",No,No,O(n),3
"const binaryTreeInorderTraversal = (root) => { const result = []; const inorder = (node) => { if (!node) return; inorder(node.left); result.push(node.val); inorder(node.right); }; inorder(root); return result; };",No,No,O(n),3
"const countAndSay = (n) => { let result = '1'; for (let i = 1; i < n; i++) { let newResult = '', count = 1; for (let j = 0; j < result.length; j++) { if (result[j] === result[j + 1]) count++; else { newResult += count + result[j]; count = 1; } } result = newResult; } return result; };",No,No,O(2^n),3
"const subset = (nums) => { const result = []; const backtrack = (start, path) => { result.push(path); for (let i = start; i < nums.length; i++) { backtrack(i + 1, path.concat(nums[i])); } }; backtrack(0, []); return result; };",No,No,O(2^n),3
"const maxProductSubarray = (nums) => { let maxProduct = nums[0], minProduct = nums[0], result = nums[0]; for (let i = 1; i < nums.length; i++) { if (nums[i] < 0) [maxProduct, minProduct] = [minProduct, maxProduct]; maxProduct = Math.max(nums[i], maxProduct * nums[i]); minProduct = Math.min(nums[i], minProduct * nums[i]); result = Math.max(result, maxProduct); } return result; };",No,No,O(n),3
"const longestValidParentheses = (s) => { const stack = [-1]; let maxLength = 0; for (let i = 0; i < s.length; i++) { if (s[i] === '(') stack.push(i); else { stack.pop(); if (stack.length === 0) stack.push(i); else maxLength = Math.max(maxLength, i - stack[stack.length - 1]); } } return maxLength; };",No,No,O(n),3
"const convert = (s, numRows) => { if (numRows === 1) return s; const rows = Array(Math.min(numRows, s.length)).fill(''); let curRow = 0, goingDown = false; for (const char of s) { rows[curRow] += char; if (curRow === 0 || curRow === numRows - 1) goingDown = !goingDown; curRow += goingDown ? 1 : -1; } return rows.join(''); };",No,No,O(n),3
"const groupAnagrams = (strs) => { const map = {}; for (const str of strs) { const sorted = str.split('').sort().join(''); if (!map[sorted]) map[sorted] = []; map[sorted].push(str); } return Object.values(map); };",No,No,O(n * k log k),3
"const sortedArrayToBST = (nums) => { if (!nums.length) return null; const mid = Math.floor(nums.length / 2); const root = new TreeNode(nums[mid]); root.left = sortedArrayToBST(nums.slice(0, mid)); root.right = sortedArrayToBST(nums.slice(mid + 1)); return root; };",No,No,O(n),3
"const binaryTreeLevelOrderTraversal = (root) => { if (!root) return []; const result = [], queue = [root]; while (queue.length) { const level = []; const levelSize = queue.length; for (let i = 0; i < levelSize; i++) { const node = queue.shift(); level.push(node.val); if (node.left) queue.push(node.left); if (node.right) queue.push(node.right); } result.push(level); } return result; };",No,No,O(n),3
"const searchInsert = (nums, target) => { let left = 0, right = nums.length - 1; while (left <= right) { const mid = Math.floor((left + right) / 2); if (nums[mid] === target) return mid; if (nums[mid] < target) left = mid + 1; else right = mid - 1; } return left; };",No,No,O(log n),3
"const minPathSum = (grid) => { const m = grid.length, n = grid[0].length; for (let i = 0; i < m; i++) { for (let j = 0; j < n; j++) { if (i === 0 && j === 0) continue; grid[i][j] += Math.min(i > 0 ? grid[i - 1][j] : Infinity, j > 0 ? grid[i][j - 1] : Infinity); } } return grid[m - 1][n - 1]; };",No,No,O(m * n),3
"const dp = Array(m).fill(0).map(() => Array(n).fill(0)); dp[0][0] = 1; for (let i = 0; i < m; i++) { for (let j = 0; j < n; j++) { if (obstacleGrid[i][j] === 1) continue; if (i > 0) dp[i][j] += dp[i - 1][j]; if (j > 0) dp[i][j] += dp[i][j - 1]; } } return dp[m - 1][n - 1];",No,No,O(m * n),3
"const merge = (intervals) => { if (!intervals.length) return []; intervals.sort((a, b) => a[0] - b[0]); const merged = [intervals[0]]; for (let i = 1; i < intervals.length; i++) { const last = merged[merged.length - 1]; if (last[1] >= intervals[i][0]) last[1] = Math.max(last[1], intervals[i][1]); else merged.push(intervals[i]); } return merged; };",No,No,O(n log n),3
"const lengthOfLIS = (nums) => { const dp = []; for (let num of nums) { let left = 0, right = dp.length; while (left < right) { const mid = Math.floor((left + right) / 2); if (dp[mid] < num) left = mid + 1; else right = mid; } dp[left] = num; } return dp.length; };",No,No,O(n log n),3
"const searchInsert = (nums, target) => { let left = 0, right = nums.length - 1; while (left <= right) { const mid = Math.floor((left + right) / 2); if (nums[mid] === target) return mid; if (nums[mid] < target) left = mid + 1; else right = mid - 1; } return left; };",No,No,O(log n),3
"const canJump = (nums) => { let reachable = 0; for (let i = 0; i < nums.length; i++) { if (i > reachable) return false; reachable = Math.max(reachable, i + nums[i]); } return true; };",No,No,O(n),3
"const numIslands = (grid) => { if (!grid.length) return 0; let count = 0; const dfs = (i, j) => { if (i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || grid[i][j] === '0') return; grid[i][j] = '0'; dfs(i + 1, j); dfs(i - 1, j); dfs(i, j + 1); dfs(i, j - 1); }; for (let i = 0; i < grid.length; i++) { for (let j = 0; j < grid[0].length; j++) { if (grid[i][j] === '1') { count++; dfs(i, j); } } } return count; };",No,No,O(m * n),3
"const courseSchedule = (numCourses, prerequisites) => { const graph = Array.from({ length: numCourses }, () => []); const indegree = Array(numCourses).fill(0); for (const [course, pre] of prerequisites) { graph[pre].push(course); indegree[course]++; } const queue = []; for (let i = 0; i < numCourses; i++) { if (indegree[i] === 0) queue.push(i); } let count = 0; while (queue.length) { const course = queue.shift(); count++; for (const neighbor of graph[course]) { indegree[neighbor]--; if (indegree[neighbor] === 0) queue.push(neighbor); } } return count === numCourses; };",No,No,O(V + E),3
"const maxArea = (height) => { let left = 0, right = height.length - 1, maxArea = 0; while (left < right) { const area = Math.min(height[left], height[right]) * (right - left); maxArea = Math.max(maxArea, area); if (height[left] < height[right]) left++; else right--; } return maxArea; };",No,No,O(n),3
"const threeSum = (nums) => { nums.sort((a, b) => a - b); const result = []; for (let i = 0; i < nums.length - 2; i++) { if (i > 0 && nums[i] === nums[i - 1]) continue; let left = i + 1, right = nums.length - 1; while (left < right) { const sum = nums[i] + nums[left] + nums[right]; if (sum < 0) left++; else if (sum > 0) right--; else { result.push([nums[i], nums[left], nums[right]]); while (left < right && nums[left] === nums[left + 1]) left++; while (left < right && nums[right] === nums[right - 1]) right--; left++; right--; } } } return result; };",No,No,O(n^2),3
"const maxArea = (height) => { let left = 0, right = height.length - 1; let maxArea = 0; while (left < right) { const area = Math.min(height[left], height[right]) * (right - left); maxArea = Math.max(maxArea, area); if (height[left] < height[right]) left++; else right--; } return maxArea; };",No,No,O(n),3
"const generateParenthesis = (n) => { const result = []; const backtrack = (left, right, current) => { if (current.length === n * 2) { result.push(current); return; } if (left < n) backtrack(left + 1, right, current + '('); if (right < left) backtrack(left, right + 1, current + ')'); }; backtrack(0, 0, ''); return result; };",No,No,O(4^n/n^(1/2)),3
"const isValid = (s) => { const stack = []; const mapping = { '(': ')', '{': '}', '[': ']' }; for (let char of s) { if (mapping[char]) stack.push(mapping[char]); else if (stack.length === 0 || char !== stack.pop()) return false; } return stack.length === 0; };",No,No,O(n),3
"const climbStairs = (n) => { if (n <= 2) return n; let first = 1, second = 2; for (let i = 3; i <= n; i++) { const temp = first; first = second; second = temp + second; } return second; };",No,No,O(n),3
"const reverse = (x) => { const sign = Math.sign(x); const reversed = parseInt(Math.abs(x).toString().split('').reverse().join('')) * sign; return reversed >= Math.pow(-2, 31) && reversed <= Math.pow(2, 31) - 1 ? reversed : 0; };",No,No,O(log x),3
"const longestSubstring = (s, k) => { const map = new Map(); let left = 0; for (let right = 0; right < s.length; right++) { map.set(s[right], (map.get(s[right]) || 0) + 1); while (map.size > k) { map.set(s[left], map.get(s[left]) - 1); if (map.get(s[left]) === 0) map.delete(s[left]); left++; } } return right - left + 1; };",No,No,O(n),3
"const numIslands = (grid) => { if (!grid.length) return 0; let islands = 0; const dfs = (i, j) => { if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] === '0') return; grid[i][j] = '0'; dfs(i - 1, j); dfs(i + 1, j); dfs(i, j - 1); dfs(i, j + 1); }; for (let i = 0; i < grid.length; i++) { for (let j = 0; j < grid[0].length; j++) { if (grid[i][j] === '1') { islands++; dfs(i, j); } } } return islands; };",No,No,O(m*n),3
"const findMedianSortedArrays = (nums1, nums2) => { const merged = [...nums1, ...nums2].sort((a, b) => a - b); const mid = Math.floor(merged.length / 2); return merged.length % 2 === 0 ? (merged[mid - 1] + merged[mid]) / 2 : merged[mid]; };",No,No,O(log (m+n)),3
"const permute = (nums) => { const result = []; const backtrack = (path) => { if (path.length === nums.length) result.push(path); for (let i = 0; i < nums.length; i++) { if (path.includes(nums[i])) continue; backtrack([...path, nums[i]]); } }; backtrack([]); return result; };",No,No,O(n*n!),3
"const topKFrequent = (nums, k) => { const count = {}; nums.forEach(num => { count[num] = (count[num] || 0) + 1; }); return Object.entries(count).sort((a, b) => b[1] - a[1]).slice(0, k).map(([num]) => parseInt(num)); };",No,No,O(n log n),3
"const mergeKLists = (lists) => { if (!lists.length) return null; const mergeTwoLists = (l1, l2) => { const dummy = new ListNode(0); let current = dummy; while (l1 && l2) { if (l1.val < l2.val) { current.next = l1; l1 = l1.next; } else { current.next = l2; l2 = l2.next; } current = current.next; } current.next = l1 || l2; return dummy.next; }; return lists.reduce((acc, curr) => mergeTwoLists(acc, curr)); };",No,No,O(n log k),3
"const majorityElement = (nums) => { let count = 0, candidate; for (let num of nums) { if (count === 0) candidate = num; count += (num === candidate) ? 1 : -1; } return candidate; };",No,No,O(n),3
"const validAnagram = (s, t) => { if (s.length !== t.length) return false; const count = {}; for (let char of s) { count[char] = (count[char] || 0) + 1; } for (let char of t) { if (!count[char]) return false; count[char]--; } return true; };",No,No,O(n),3
"const removeNthFromEnd = (head, n) => { const dummy = new ListNode(0, head); let first = dummy, second = dummy; for (let i = 0; i <= n; i++) { first = first.next; } while (first) { first = first.next; second = second.next; } second.next = second.next.next; return dummy.next; };",No,No,O(L),3
"const letterCombinations = (digits) => { if (!digits) return []; const phone = { '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz' }; const result = []; const backtrack = (combination, nextDigits) => { if (!nextDigits) { result.push(combination); } else { const digit = nextDigits[0]; for (let letter of phone[digit]) { backtrack(combination + letter, nextDigits.slice(1)); } } }; backtrack('', digits); return result; };",No,No,O(3^n*4^m),3
"const isValid = (s) => { const stack = []; const map = { '(': ')', '{': '}', '[': ']' }; for (let char of s) { if (map[char]) stack.push(map[char]); else if (stack.pop() !== char) return false; } return stack.length === 0; };",No,No,O(n),3
"const generateParenthesis = (n) => { const result = []; const backtrack = (open, close, combination) => { if (open === n && close === n) { result.push(combination); return; } if (open < n) backtrack(open + 1, close, combination + '('); if (close < open) backtrack(open, close + 1, combination + ')'); }; backtrack(0, 0, ''); return result; };",No,No,O(4^n/sqrt(n)),3
"const uniquePaths = (m, n) => { const dp = Array.from({ length: m }, () => Array(n).fill(1)); for (let i = 1; i < m; i++) { for (let j = 1; j < n; j++) { dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } return dp[m - 1][n - 1]; };",No,No,O(m*n),3
"const longestCommonPrefix = (strs) => { if (!strs.length) return ''; let prefix = strs[0]; for (let i = 1; i < strs.length; i++) { while (strs[i].indexOf(prefix) !== 0) { prefix = prefix.slice(0, -1); } } return prefix; };",No,No,O(n*m),3
"const countSubstrings = (s) => { let count = 0; for (let i = 0; i < s.length; i++) { for (let j = i; j < s.length; j++) { if (isPalindrome(s.slice(i, j + 1))) count++; } } return count; };",No,No,O(n^3),3
"const convertToTitle = (n) => { let result = ''; while (n > 0) { n--; result = String.fromCharCode(n % 26 + 65) + result; n = Math.floor(n / 26); } return result; };",No,No,O(log n),3
"const addBinary = (a, b) => { let result = '', carry = 0; let i = a.length - 1, j = b.length - 1; while (i >= 0 || j >= 0 || carry) { const sum = (i >= 0 ? a[i--] - '0' : 0) + (j >= 0 ? b[j--] - '0' : 0) + carry; result = (sum % 2) + result; carry = Math.floor(sum / 2); } return result; };",No,No,O(max(n,m)),3
"const isPalindrome = (s) => { const cleaned = s.replace(/[^A-Za-z0-9]/g, '').toLowerCase(); return cleaned === cleaned.split('').reverse().join(''); };",No,No,O(n),3
"const binarySearch = (nums, target) => { let left = 0, right = nums.length - 1; while (left <= right) { const mid = Math.floor((left + right) / 2); if (nums[mid] === target) return mid; if (nums[mid] < target) left = mid + 1; else right = mid - 1; } return -1; };",No,No,O(log n),3
"const rotate = (nums, k) => { k %= nums.length; const reverse = (arr, start, end) => { while (start < end) { [arr[start], arr[end]] = [arr[end], arr[start]]; start++; end--; } }; reverse(nums, 0, nums.length - 1); reverse(nums, 0, k - 1); reverse(nums, k, nums.length - 1); };",No,No,O(n),3
"const threeSum = (nums) => { const result = []; nums.sort((a, b) => a - b); for (let i = 0; i < nums.length - 2; i++) { if (i > 0 && nums[i] === nums[i - 1]) continue; let left = i + 1, right = nums.length - 1; while (left < right) { const sum = nums[i] + nums[left] + nums[right]; if (sum === 0) { result.push([nums[i], nums[left], nums[right]]); while (left < right && nums[left] === nums[left + 1]) left++; while (left < right && nums[right] === nums[right - 1]) right--; left++; right--; } else if (sum < 0) left++; else right--; } } return result; };",No,No,O(n^2),3
"const maximumSubarray = (nums) => { let maxSum = nums[0], currentSum = nums[0]; for (let i = 1; i < nums.length; i++) { currentSum = Math.max(nums[i], currentSum + nums[i]); maxSum = Math.max(maxSum, currentSum); } return maxSum; };",No,No,O(n),3
"const longestSubstring = (s) => { let charSet = new Set(); let left = 0, maxLength = 0; for (let right = 0; right < s.length; right++) { while (charSet.has(s[right])) { charSet.delete(s[left]); left++; } charSet.add(s[right]); maxLength = Math.max(maxLength, right - left + 1); } return maxLength; };",No,No,O(n),3
"const maxArea = (height) => { let left = 0, right = height.length - 1, maxArea = 0; while (left < right) { const area = Math.min(height[left], height[right]) * (right - left); maxArea = Math.max(maxArea, area); if (height[left] < height[right]) left++; else right--; } return maxArea; };",No,No,O(n),3
"const permute = (nums) => { const result = []; const backtrack = (path) => { if (path.length === nums.length) result.push([...path]); for (let i = 0; i < nums.length; i++) { if (path.includes(nums[i])) continue; path.push(nums[i]); backtrack(path); path.pop(); } }; backtrack([]); return result; };",No,No,O(n!),3
"const climbStairs = (n) => { if (n <= 1) return 1; let first = 1, second = 1; for (let i = 2; i <= n; i++) { const temp = first; first = first + second; second = temp; } return first; };",No,No,O(n),3
"const twoSum = (nums, target) => { const map = new Map(); for (let i = 0; i < nums.length; i++) { const complement = target - nums[i]; if (map.has(complement)) return [map.get(complement), i]; map.set(nums[i], i); } };",No,No,O(n),3
"const firstUniqChar = (s) => { const charCount = {}; for (let char of s) { charCount[char] = (charCount[char] || 0) + 1; } for (let i = 0; i < s.length; i++) { if (charCount[s[i]] === 1) return i; } return -1; };",No,No,O(n),3
"const mergeSortedArrays = (arr1, arr2) => { let merged = [], i = 0, j = 0; while (i < arr1.length && j < arr2.length) { if (arr1[i] < arr2[j]) merged.push(arr1[i++]); else merged.push(arr2[j++]); } return merged.concat(arr1.slice(i)).concat(arr2.slice(j)); };",No,No,O(n),3
"const isValid = (s) => { const stack = []; const map = { '(': ')', '{': '}', '[': ']' }; for (let char of s) { if (map[char]) stack.push(map[char]); else if (stack.pop() !== char) return false; } return stack.length === 0; };",No,No,O(n),3
"const generateParenthesis = (n) => { const result = []; const backtrack = (current, open, close) => { if (current.length === 2 * n) { result.push(current); return; } if (open < n) backtrack(current + '(', open + 1, close); if (close < open) backtrack(current + ')', open, close + 1); }; backtrack('', 0, 0); return result; };",No,No,O(4^n/n^(n)),3
"const wordBreak = (s, wordDict) => { const dp = Array(s.length + 1).fill(false); dp[0] = true; for (let i = 1; i <= s.length; i++) { for (let j = 0; j < i; j++) { if (dp[j] && wordDict.includes(s.slice(j, i))) { dp[i] = true; break; } } } return dp[s.length]; };",No,No,O(n^2),3
"const coinChange = (coins, amount) => { const dp = Array(amount + 1).fill(Infinity); dp[0] = 0; for (let coin of coins) { for (let i = coin; i <= amount; i++) { dp[i] = Math.min(dp[i], dp[i - coin] + 1); } } return dp[amount] === Infinity ? -1 : dp[amount]; };",No,No,O(n * amount),3
"const maxProfit = (prices) => { let maxProfit = 0; for (let i = 1; i < prices.length; i++) { if (prices[i] > prices[i - 1]) maxProfit += prices[i] - prices[i - 1]; } return maxProfit; };",No,No,O(n),3
"const longestPalindrome = (s) => { let start = 0, end = 0; for (let i = 0; i < s.length; i++) { const len1 = expandAroundCenter(s, i, i); const len2 = expandAroundCenter(s, i, i + 1); const len = Math.max(len1, len2); if (len > end - start) { start = i - Math.floor((len - 1) / 2); end = i + Math.floor(len / 2); } } return s.slice(start, end + 1); }; const expandAroundCenter = (s, left, right) => { while (left >= 0 && right < s.length && s[left] === s[right]) { left--; right++; } return right - left - 1; };",No,No,O(n^2),3
"const longestCommonPrefix = (strs) => { if (!strs.length) return ''; let prefix = strs[0]; for (let i = 1; i < strs.length; i++) { while (strs[i].indexOf(prefix) !== 0) { prefix = prefix.slice(0, -1); } } return prefix; };",No,No,O(n * m),3
"const invertTree = (root) => { if (!root) return null; const left = invertTree(root.left); const right = invertTree(root.right); root.left = right; root.right = left; return root; };",No,No,O(n),3
"const levelOrder = (root) => { if (!root) return []; const result = []; const queue = [root]; while (queue.length) { const level = []; const size = queue.length; for (let i = 0; i < size; i++) { const node = queue.shift(); level.push(node.val); if (node.left) queue.push(node.left); if (node.right) queue.push(node.right); } result.push(level); } return result; };",No,No,O(n),3
"const diameterOfBinaryTree = (root) => { let diameter = 0; const depth = (node) => { if (!node) return 0; const left = depth(node.left); const right = depth(node.right); diameter = Math.max(diameter, left + right); return Math.max(left, right) + 1; }; depth(root); return diameter; };",No,No,O(n),3
"const isSymmetric = (root) => { const isMirror = (t1, t2) => { if (!t1 && !t2) return true; if (!t1 || !t2) return false; return (t1.val === t2.val) && isMirror(t1.left, t2.right) && isMirror(t1.right, t2.left); }; return isMirror(root, root); };",No,No,O(n),3
"const uniquePaths = (m, n) => { const dp = Array.from({ length: m }, () => Array(n).fill(1)); for (let i = 1; i < m; i++) { for (let j = 1; j < n; j++) { dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } return dp[m - 1][n - 1]; };",No,No,O(m * n),3
"const minPathSum = (grid) => { const m = grid.length, n = grid[0].length; for (let i = 1; i < m; i++) grid[i][0] += grid[i - 1][0]; for (let j = 1; j < n; j++) grid[0][j] += grid[0][j - 1]; for (let i = 1; i < m; i++) { for (let j = 1; j < n; j++) { grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]); } } return grid[m - 1][n - 1]; };",No,No,O(m * n),3
"const trap = (height) => { let left = 0, right = height.length - 1, maxLeft = 0, maxRight = 0, water = 0; while (left < right) { if (height[left] < height[right]) { if (height[left] >= maxLeft) maxLeft = height[left]; else water += maxLeft - height[left]; left++; } else { if (height[right] >= maxRight) maxRight = height[right]; else water += maxRight - height[right]; right--; } } return water; };",No,No,O(n),3
"const countIslands = (grid) => { const dfs = (i, j) => { if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] === '0') return; grid[i][j] = '0'; dfs(i - 1, j); dfs(i + 1, j); dfs(i, j - 1); dfs(i, j + 1); }; let count = 0; for (let i = 0; i < grid.length; i++) { for (let j = 0; j < grid[0].length; j++) { if (grid[i][j] === '1') { count++; dfs(i, j); } } } return count; };",No,No,O(m * n),3
"const searchMatrix = (matrix, target) => { if (!matrix.length) return false; let left = 0, right = matrix.length - 1; while (left <= right) { const mid = Math.floor((left + right) / 2); if (matrix[mid][0] <= target && target <= matrix[mid][matrix[mid].length - 1]) { return binarySearch(matrix[mid], target); } if (matrix[mid][0] < target) left = mid + 1; else right = mid - 1; } return false; }; const binarySearch = (arr, target) => { let left = 0, right = arr.length - 1; while (left <= right) { const mid = Math.floor((left + right) / 2); if (arr[mid] === target) return true; if (arr[mid] < target) left = mid + 1; else right = mid - 1; } return false; };",No,No,O(log(m) * n),3
"const findMedianSortedArrays = (nums1, nums2) => { const merge = [...nums1, ...nums2].sort((a, b) => a - b); const mid = Math.floor(merge.length / 2); return merge.length % 2 === 0 ? (merge[mid - 1] + merge[mid]) / 2 : merge[mid]; };",No,No,O((n + m) log(n + m)),3
"const rotateImage = (matrix) => { const n = matrix.length; for (let i = 0; i < n; i++) { for (let j = i; j < n; j++) { [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]]; } } for (let i = 0; i < n; i++) { matrix[i].reverse(); } };",No,No,O(n^2),3
"const floodFill = (image, sr, sc, newColor) => { const originalColor = image[sr][sc]; if (originalColor === newColor) return image; const fill = (r, c) => { if (image[r][c] === originalColor) { image[r][c] = newColor; if (r > 0) fill(r - 1, c); if (r < image.length - 1) fill(r + 1, c); if (c > 0) fill(r, c - 1); if (c < image[0].length - 1) fill(r, c + 1); } }; fill(sr, sc); return image; };",No,No,O(n * m),3
"const canConstruct = (ransomNote, magazine) => { const count = {}; for (let char of magazine) count[char] = (count[char] || 0) + 1; for (let char of ransomNote) { if (!count[char]) return false; count[char]--; } return true; };",No,No,O(n + m),3
"const groupAnagrams = (strs) => { const map = {}; for (let str of strs) { const key = str.split('').sort().join(''); if (!map[key]) map[key] = []; map[key].push(str); } return Object.values(map); };",No,No,O(n * m log(m)),3
"const majorityElement = (nums) => { const count = {}; for (let num of nums) { count[num] = (count[num] || 0) + 1; if (count[num] > nums.length / 2) return num; } };",No,No,O(n),3
"const isHappy = (n) => { const seen = new Set(); while (n !== 1 && !seen.has(n)) { seen.add(n); n = n.toString().split('').reduce((sum, num) => sum + num ** 2, 0); } return n === 1; };",No,No,O(log(n)),3
"const longestIncreasingSubsequence = (nums) => { const dp = []; for (let num of nums) { let index = dp.length; for (let i = 0; i < dp.length; i++) { if (dp[i] >= num) { index = i; break; } } if (index === dp.length) dp.push(num); else dp[index] = num; } return dp.length; };",No,No,O(n log(n)),3
"const minDistance = (word1, word2) => { const dp = Array(word1.length + 1).fill(null).map(() => Array(word2.length + 1).fill(0)); for (let i = 0; i <= word1.length; i++) dp[i][0] = i; for (let j = 0; j <= word2.length; j++) dp[0][j] = j; for (let i = 1; i <= word1.length; i++) { for (let j = 1; j <= word2.length; j++) { if (word1[i - 1] === word2[j - 1]) dp[i][j] = dp[i - 1][j - 1]; else dp[i][j] = Math.min(dp[i - 1][j - 1], dp[i][j - 1], dp[i - 1][j]) + 1; } } return dp[word1.length][word2.length]; };",No,No,O(n * m),3
"const longestSubstringK = (s, k) => { const charCount = {}; let left = 0; let maxLength = 0; for (let right = 0; right < s.length; right++) { charCount[s[right]] = (charCount[s[right]] || 0) + 1; while (Object.keys(charCount).length > k) { charCount[s[left]]--; if (charCount[s[left]] === 0) delete charCount[s[left]]; left++; } maxLength = Math.max(maxLength, right - left + 1); } return maxLength; };",No,No,O(n),3
"const findDuplicate = (nums) => { let slow = nums[0], fast = nums[0]; while (true) { slow = nums[slow]; fast = nums[nums[fast]]; if (slow === fast) break; } let ptr1 = nums[0], ptr2 = slow; while (ptr1 !== ptr2) { ptr1 = nums[ptr1]; ptr2 = nums[ptr2]; } return ptr1; };",No,No,O(n),3
"const findAllDuplicates = (nums) => { const result = []; for (let num of nums) { const index = Math.abs(num) - 1; if (nums[index] < 0) result.push(index + 1); nums[index] = -nums[index]; } return result; };",No,No,O(n),3
"const twoSumSorted = (numbers, target) => { let left = 0, right = numbers.length - 1; while (left < right) { const sum = numbers[left] + numbers[right]; if (sum === target) return [left + 1, right + 1]; if (sum < target) left++; else right--; } return []; };",No,No,O(n),3
"const validSudoku = (board) => { const rows = Array(9).fill(0).map(() => new Set()); const cols = Array(9).fill(0).map(() => new Set()); const boxes = Array(9).fill(0).map(() => new Set()); for (let i = 0; i < 9; i++) { for (let j = 0; j < 9; j++) { if (board[i][j] !== '.') { const num = board[i][j]; const boxIndex = Math.floor(i / 3) * 3 + Math.floor(j / 3); if (rows[i].has(num) || cols[j].has(num) || boxes[boxIndex].has(num)) return false; rows[i].add(num); cols[j].add(num); boxes[boxIndex].add(num); } } } return true; };",No,No,O(1),3
"const searchInsert = (nums, target) => { let left = 0, right = nums.length - 1; while (left <= right) { const mid = Math.floor((left + right) / 2); if (nums[mid] === target) return mid; if (nums[mid] < target) left = mid + 1; else right = mid - 1; } return left; };",No,No,O(log(n)),3
"const deleteNode = (node) => { node.val = node.next.val; node.next = node.next.next; };",No,No,O(1),3
"const sortedArrayToBST = (nums) => { if (!nums.length) return null; const mid = Math.floor(nums.length / 2); const node = new TreeNode(nums[mid]); node.left = sortedArrayToBST(nums.slice(0, mid)); node.right = sortedArrayToBST(nums.slice(mid + 1)); return node; };",No,No,O(n),3
"const isSubsequence = (s, t) => { let sIndex = 0, tIndex = 0; while (sIndex < s.length && tIndex < t.length) { if (s[sIndex] === t[tIndex]) sIndex++; tIndex++; } return sIndex === s.length; };",No,No,O(n + m),3
"const minimumTotal = (triangle) => { for (let i = triangle.length - 2; i >= 0; i--) { for (let j = 0; j <= i; j++) { triangle[i][j] += Math.min(triangle[i + 1][j], triangle[i + 1][j + 1]); } } return triangle[0][0]; };",No,No,O(n^2),3
"const uniquePathsWithObstacles = (grid) => { const m = grid.length, n = grid[0].length; if (grid[0][0] === 1 || grid[m - 1][n - 1] === 1) return 0; const dp = Array.from({ length: m }, () => Array(n).fill(0)); dp[0][0] = 1; for (let i = 0; i < m; i++) { for (let j = 0; j < n; j++) { if (grid[i][j] === 1) dp[i][j] = 0; else { if (i > 0) dp[i][j] += dp[i - 1][j]; if (j > 0) dp[i][j] += dp[i][j - 1]; } } } return dp[m - 1][n - 1]; };",No,No,O(m * n),3
"const pathSum = (root, sum) => { const map = new Map(); const dfs = (node, currSum) => { if (!node) return 0; currSum += node.val; const count = map.get(currSum - sum) || 0; map.set(currSum, (map.get(currSum) || 0) + 1); const totalPaths = count + dfs(node.left, currSum) + dfs(node.right, currSum); map.set(currSum, map.get(currSum) - 1); return totalPaths; }; return dfs(root, 0); };",No,No,O(n),3
"const findKthLargest = (nums, k) => { const quickSelect = (left, right) => { const pivot = nums[right]; let pIndex = left; for (let i = left; i < right; i++) { if (nums[i] > pivot) { [nums[i], nums[pIndex]] = [nums[pIndex], nums[i]]; pIndex++; } } [nums[pIndex], nums[right]] = [nums[right], nums[pIndex]]; return pIndex; }; let left = 0, right = nums.length - 1; while (true) { const pIndex = quickSelect(left, right); if (pIndex === k - 1) return nums[pIndex]; else if (pIndex < k - 1) left = pIndex + 1; else right = pIndex - 1; } };",No,No,O(n),3
"const searchRange = (nums, target) => { const findLeft = (nums, target) => { let left = 0, right = nums.length - 1; while (left <= right) { const mid = Math.floor((left + right) / 2); if (nums[mid] < target) left = mid + 1; else right = mid - 1; } return left; }; const findRight = (nums, target) => { let left = 0, right = nums.length - 1; while (left <= right) { const mid = Math.floor((left + right) / 2); if (nums[mid] <= target) left = mid + 1; else right = mid - 1; } return right; }; const left = findLeft(nums, target); const right = findRight(nums, target); return left <= right ? [left, right] : [-1, -1]; };",No,No,O(log(n)),3
"const wordBreak = (s, wordDict) => { const wordSet = new Set(wordDict); const dp = Array(s.length + 1).fill(false); dp[0] = true; for (let i = 1; i <= s.length; i++) { for (let j = 0; j < i; j++) { if (dp[j] && wordSet.has(s.slice(j, i))) { dp[i] = true; break; } } } return dp[s.length]; };",No,No,O(n^2),3
"const lengthOfLongestSubstring = (s) => { const charMap = {}; let left = 0, maxLength = 0; for (let right = 0; right < s.length; right++) { if (charMap[s[right]] !== undefined) { left = Math.max(left, charMap[s[right]] + 1); } charMap[s[right]] = right; maxLength = Math.max(maxLength, right - left + 1); } return maxLength; };",No,No,O(n),3
"const combinationSum = (candidates, target) => { const result = []; const backtrack = (start, remaining, path) => { if (remaining === 0) result.push([...path]); for (let i = start; i < candidates.length; i++) { if (candidates[i] > remaining) continue; path.push(candidates[i]); backtrack(i, remaining - candidates[i], path); path.pop(); } }; backtrack(0, target, []); return result; };",No,No,O(2^n),3
"const maxArea = (height) => { let left = 0, right = height.length - 1; let maxArea = 0; while (left < right) { const area = Math.min(height[left], height[right]) * (right - left); maxArea = Math.max(maxArea, area); if (height[left] < height[right]) left++; else right--; } return maxArea; };",No,No,O(n),3
"const generateParenthesis = (n) => { const result = []; const backtrack = (current, open, close) => { if (current.length === 2 * n) { result.push(current); return; } if (open < n) backtrack(current + '(', open + 1, close); if (close < open) backtrack(current + ')', open, close + 1); }; backtrack('', 0, 0); return result; };",No,No,O(2^n),3
"const permute = (nums) => { const result = []; const backtrack = (path) => { if (path.length === nums.length) result.push([...path]); for (let num of nums) { if (!path.includes(num)) { path.push(num); backtrack(path); path.pop(); } } }; backtrack([]); return result; };",No,No,O(n!),3
"const largestRectangleArea = (heights) => { const stack = []; let maxArea = 0; heights.push(0); for (let i = 0; i < heights.length; i++) { while (stack.length && heights[i] < heights[stack[stack.length - 1]]) { const h = heights[stack.pop()]; const w = stack.length ? i - stack[stack.length - 1] - 1 : i; maxArea = Math.max(maxArea, h * w); } stack.push(i); } return maxArea; };",No,No,O(n),3
"const minimumPathSum = (grid) => { for (let i = 0; i < grid.length; i++) { for (let j = 0; j < grid[0].length; j++) { if (i > 0 && j > 0) grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]); else if (i > 0) grid[i][j] += grid[i - 1][j]; else if (j > 0) grid[i][j] += grid[i][j - 1]; } } return grid[grid.length - 1][grid[0].length - 1]; };",No,No,O(m * n),3
"const wordSearch = (board, word) => { const dfs = (i, j, index) => { if (index === word.length) return true; if (i < 0 || j < 0 || i >= board.length || j >= board[0].length || board[i][j] !== word[index]) return false; const temp = board[i][j]; board[i][j] = '#'; const found = dfs(i + 1, j, index + 1) || dfs(i - 1, j, index + 1) || dfs(i, j + 1, index + 1) || dfs(i, j - 1, index + 1); board[i][j] = temp; return found; }; for (let i = 0; i < board.length; i++) { for (let j = 0; j < board[0].length; j++) { if (dfs(i, j, 0)) return true; } } return false; };",No,No,O(m * n),3
"const canJump = (nums) => { let maxReach = 0; for (let i = 0; i < nums.length; i++) { if (i > maxReach) return false; maxReach = Math.max(maxReach, i + nums[i]); } return true; };",No,No,O(n),3
"const jump = (nums) => { let jumps = 0, currentEnd = 0, farthest = 0; for (let i = 0; i < nums.length - 1; i++) { farthest = Math.max(farthest, i + nums[i]); if (i === currentEnd) { jumps++; currentEnd = farthest; } } return jumps; };",No,No,O(n),3
"const countSubstrings = (s) => { const dp = Array(s.length).fill(null).map(() => Array(s.length).fill(false)); let count = 0; for (let end = 0; end < s.length; end++) { for (let start = end; start >= 0; start--) { if (s[start] === s[end] && (end - start <= 2 || dp[start + 1][end - 1])) { dp[start][end] = true; count++; } } } return count; };",No,No,O(n^2),3
"const longestCommonPrefix = (strs) => { if (!strs.length) return ''; let prefix = strs[0]; for (let i = 1; i < strs.length; i++) { while (strs[i].indexOf(prefix) !== 0) { prefix = prefix.slice(0, -1); if (!prefix) return ''; } } return prefix; };",No,No,O(n * m),3
"const trap = (height) => { const leftMax = Array(height.length).fill(0); const rightMax = Array(height.length).fill(0); let water = 0; for (let i = 0; i < height.length; i++) { leftMax[i] = i === 0 ? height[i] : Math.max(leftMax[i - 1], height[i]); } for (let i = height.length - 1; i >= 0; i--) { rightMax[i] = i === height.length - 1 ? height[i] : Math.max(rightMax[i + 1], height[i]); } for (let i = 0; i < height.length; i++) { water += Math.min(leftMax[i], rightMax[i]) - height[i]; } return water; };",No,No,O(n),3
"const deleteNode = (node) => { node.val = node.next.val; node.next = node.next.next; };",No,No,O(1),3
"const removeNthFromEnd = (head, n) => { let fast = head, slow = head; for (let i = 0; i < n; i++) fast = fast.next; if (!fast) return head.next; while (fast.next) { fast = fast.next; slow = slow.next; } slow.next = slow.next.next; return head; };",No,No,O(n),3
"const reverseList = (head) => { let prev = null; let curr = head; while (curr) { const nextTemp = curr.next; curr.next = prev; prev = curr; curr = nextTemp; } return prev; };",No,No,O(n),3
"const isPalindrome = (head) => { let fast = head, slow = head; while (fast && fast.next) { fast = fast.next.next; slow = slow.next; } let prev = null; while (slow) { const nextTemp = slow.next; slow.next = prev; prev = slow; slow = nextTemp; } fast = head; while (prev) { if (fast.val !== prev.val) return false; fast = fast.next; prev = prev.next; } return true; };",No,No,O(n),3
"const copyRandomList = (head) => { const map = new Map(); let curr = head; while (curr) { map.set(curr, new Node(curr.val)); curr = curr.next; } curr = head; while (curr) { if (curr.random) map.get(curr).random = map.get(curr.random); curr = curr.next; } return map.get(head); };",No,No,O(n),3
"const isValidBST = (root) => { const dfs = (node, min, max) => { if (!node) return true; if (node.val <= min || node.val >= max) return false; return dfs(node.left, min, node.val) && dfs(node.right, node.val, max); }; return dfs(root, -Infinity, Infinity); };",No,No,O(n),3
"const kthSmallest = (root, k) => { const stack = []; let count = 0; while (true) { while (root) { stack.push(root); root = root.left; } root = stack.pop(); count++; if (count === k) return root.val; root = root.right; } };",No,No,O(n),3
"const levelOrder = (root) => { const result = []; const dfs = (node, level) => { if (!node) return; if (!result[level]) result[level] = []; result[level].push(node.val); dfs(node.left, level + 1); dfs(node.right, level + 1); }; dfs(root, 0); return result; };",No,No,O(n),3
"const invertTree = (root) => { if (!root) return null; const left = invertTree(root.left); const right = invertTree(root.right); root.left = right; root.right = left; return root; };",No,No,O(n),3
"const lowestCommonAncestor = (root, p, q) => { if (!root || root === p || root === q) return root; const left = lowestCommonAncestor(root.left, p, q); const right = lowestCommonAncestor(root.right, p, q); if (left && right) return root; return left || right; };",No,No,O(n),3
"const maxDepth = (root) => { if (!root) return 0; return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1; };",No,No,O(n),3
"const diameterOfBinaryTree = (root) => { let maxDiameter = 0; const dfs = (node) => { if (!node) return 0; const left = dfs(node.left); const right = dfs(node.right); maxDiameter = Math.max(maxDiameter, left + right); return Math.max(left, right) + 1; }; dfs(root); return maxDiameter; };",No,No,O(n),3
"const pathSum = (root, sum) => { const dfs = (node, currSum) => { if (!node) return 0; currSum += node.val; let count = 0; if (currSum === sum) count++; count += dfs(node.left, currSum) + dfs(node.right, currSum); return count; }; return dfs(root, 0); };",No,No,O(n),3
"const constructMaximumBinaryTree = (nums) => { if (!nums.length) return null; const maxIndex = nums.indexOf(Math.max(...nums)); const root = new TreeNode(nums[maxIndex]); root.left = constructMaximumBinaryTree(nums.slice(0, maxIndex)); root.right = constructMaximumBinaryTree(nums.slice(maxIndex + 1)); return root; };",No,No,O(n),3
"const longestIncreasingSubsequence = (nums) => { const dp = Array(nums.length).fill(1); let maxLength = 1; for (let i = 1; i < nums.length; i++) { for (let j = 0; j < i; j++) { if (nums[i] > nums[j]) { dp[i] = Math.max(dp[i], dp[j] + 1); maxLength = Math.max(maxLength, dp[i]); } } } return maxLength; };",No,No,O(n^2),3
"const findDuplicate = (nums) => { let slow = nums[0], fast = nums[0]; do { slow = nums[slow]; fast = nums[nums[fast]]; } while (slow !== fast); let finder = nums[0]; while (finder !== slow) { finder = nums[finder]; slow = nums[slow]; } return finder; };",No,No,O(n),3
"const maxProduct = (nums) => { let max1 = -Infinity, max2 = -Infinity; for (let num of nums) { if (num > max1) { max2 = max1; max1 = num; } else if (num > max2) max2 = num; } return (max1 - 1) * (max2 - 1); };",No,No,O(n),3
"const maximumSubarray = (nums) => { let maxSum = nums[0], currentSum = nums[0]; for (let i = 1; i < nums.length; i++) { currentSum = Math.max(nums[i], currentSum + nums[i]); maxSum = Math.max(maxSum, currentSum); } return maxSum; };",No,No,O(n),3
"const rotate = (nums, k) => { k %= nums.length; const reverse = (arr, start, end) => { while (start < end) { [arr[start], arr[end]] = [arr[end], arr[start]]; start++; end--; } }; reverse(nums, 0, nums.length - 1); reverse(nums, 0, k - 1); reverse(nums, k, nums.length - 1); };",No,No,O(n),3
"const twoSum = (nums, target) => { const map = new Map(); for (let i = 0; i < nums.length; i++) { if (map.has(target - nums[i])) return [map.get(target - nums[i]), i]; map.set(nums[i], i); } };",No,No,O(n),3
"const climbStairs = (n) => { if (n <= 2) return n; let a = 1, b = 2; for (let i = 3; i <= n; i++) { const temp = b; b = a + b; a = temp; } return b; };",No,No,O(n),3
"const reverseWords = (s) => { const words = s.trim().split(' '); return words.reverse().join(' '); };",No,No,O(n),3
"const longestPalindrome = (s) => { let longest = ''; for (let i = 0; i < s.length; i++) { for (let j = i; j < s.length; j++) { const substring = s.slice(i, j + 1); if (substring === substring.split('').reverse().join('') && substring.length > longest.length) { longest = substring; } } } return longest; };",No,No,O(n^3),3
"const findLongestWord = (s, d) => { let longest = ''; for (let word of d) { if (isSubsequence(word, s) && word.length > longest.length) longest = word; } return longest; };",No,No,O(m * n),3
"const canConstruct = (ransomNote, magazine) => { const count = {}; for (let char of magazine) count[char] = (count[char] || 0) + 1; for (let char of ransomNote) { if (!count[char]) return false; count[char]--; } return true; };",No,No,O(n),3
"const containsNearbyDuplicate = (nums, k) => { const map = new Map(); for (let i = 0; i < nums.length; i++) { if (map.has(nums[i]) && i - map.get(nums[i]) <= k) return true; map.set(nums[i], i); } return false; };",No,No,O(n),3
"const maxSlidingWindow = (nums, k) => { const deque = []; const result = []; for (let i = 0; i < nums.length; i++) { if (deque.length && deque[0] < i - k + 1) deque.shift(); while (deque.length && nums[deque[deque.length - 1]] < nums[i]) deque.pop(); deque.push(i); if (i >= k - 1) result.push(nums[deque[0]]); } return result; };",No,No,O(n),3
"const groupAnagrams = (strs) => { const map = new Map(); for (let str of strs) { const sorted = str.split('').sort().join(''); if (!map.has(sorted)) map.set(sorted, []); map.get(sorted).push(str); } return [...map.values()]; };",No,No,O(n * k * log(k)),3
"const singleNumber = (nums) => { let result = 0; for (let num of nums) result ^= num; return result; };",No,No,O(n),3
"const productExceptSelf = (nums) => { const output = Array(nums.length).fill(1); let leftProduct = 1; for (let i = 0; i < nums.length; i++) { output[i] *= leftProduct; leftProduct *= nums[i]; } let rightProduct = 1; for (let i = nums.length - 1; i >= 0; i--) { output[i] *= rightProduct; rightProduct *= nums[i]; } return output; };",No,No,O(n),3
"const sortedSquares = (nums) => { return nums.map(num => num * num).sort((a, b) => a - b); };",No,No,O(n log n),3
"const maximumProductSubarray = (nums) => { let maxProduct = nums[0], minProduct = nums[0], result = nums[0]; for (let i = 1; i < nums.length; i++) { if (nums[i] < 0) [maxProduct, minProduct] = [minProduct, maxProduct]; maxProduct = Math.max(nums[i], maxProduct * nums[i]); minProduct = Math.min(nums[i], minProduct * nums[i]); result = Math.max(result, maxProduct); } return result; };",No,No,O(n),3
"const searchRange = (nums, target) => { const binarySearch = (left) => { let low = 0, high = nums.length - 1; while (low <= high) { const mid = Math.floor((low + high) / 2); if (nums[mid] < target) low = mid + 1; else high = mid - 1; } return low; }; const start = binarySearch(true); const end = binarySearch(false) - 1; return start <= end ? [start, end] : [-1, -1]; };",No,No,O(log n),3
"const mergeIntervals = (intervals) => { if (!intervals.length) return []; intervals.sort((a, b) => a[0] - b[0]); const merged = [intervals[0]]; for (let i = 1; i < intervals.length; i++) { const [start, end] = intervals[i]; const [lastStart, lastEnd] = merged[merged.length - 1]; if (start <= lastEnd) { merged[merged.length - 1][1] = Math.max(lastEnd, end); } else { merged.push(intervals[i]); } } return merged; };",No,No,O(n log n),3
"const minMeetingRooms = (intervals) => { const startTimes = intervals.map(interval => interval[0]).sort((a, b) => a - b); const endTimes = intervals.map(interval => interval[1]).sort((a, b) => a - b); let startIndex = 0, endIndex = 0, rooms = 0; while (startIndex < intervals.length) { if (startTimes[startIndex] < endTimes[endIndex]) { rooms++; startIndex++; } else { rooms--; endIndex++; } } return rooms; };",No,No,O(n log n),3
"const removeDuplicates = (nums) => { let uniqueCount = 0; for (let i = 0; i < nums.length; i++) { if (i === 0 || nums[i] !== nums[i - 1]) { nums[uniqueCount++] = nums[i]; } } return uniqueCount; };",No,No,O(n),3
"const longestCommonPrefix = (strs) => { if (!strs.length) return ''; let prefix = strs[0]; for (let i = 1; i < strs.length; i++) { while (strs[i].indexOf(prefix) !== 0) { prefix = prefix.slice(0, -1); if (!prefix) return ''; } } return prefix; };",No,No,O(n * m),3
"const trap = (height) => { const leftMax = Array(height.length).fill(0); const rightMax = Array(height.length).fill(0); let water = 0; for (let i = 0; i < height.length; i++) { leftMax[i] = i === 0 ? height[i] : Math.max(leftMax[i - 1], height[i]); } for (let i = height.length - 1; i >= 0; i--) { rightMax[i] = i === height.length - 1 ? height[i] : Math.max(rightMax[i + 1], height[i]); } for (let i = 0; i < height.length; i++) { water += Math.min(leftMax[i], rightMax[i]) - height[i]; } return water; };",No,No,O(n),3
"const deleteNode = (node) => { node.val = node.next.val; node.next = node.next.next; };",No,No,O(1),3
"const removeNthFromEnd = (head, n) => { let fast = head, slow = head; for (let i = 0; i < n; i++) fast = fast.next; if (!fast) return head.next; while (fast.next) { fast = fast.next; slow = slow.next; } slow.next = slow.next.next; return head; };",No,No,O(n),3
"const reverseList = (head) => { let prev = null; let curr = head; while (curr) { const nextTemp = curr.next; curr.next = prev; prev = curr; curr = nextTemp; } return prev; };",No,No,O(n),3
"const isPalindrome = (head) => { let fast = head, slow = head; while (fast && fast.next) { fast = fast.next.next; slow = slow.next; } let prev = null; while (slow) { const nextTemp = slow.next; slow.next = prev; prev = slow; slow = nextTemp; } fast = head; while (prev) { if (fast.val !== prev.val) return false; fast = fast.next; prev = prev.next; } return true; };",No,No,O(n),3
"const copyRandomList = (head) => { const map = new Map(); let curr = head; while (curr) { map.set(curr, new Node(curr.val)); curr = curr.next; } curr = head; while (curr) { if (curr.random) map.get(curr).random = map.get(curr.random); curr = curr.next; } return map.get(head); };",No,No,O(n),3
"const isValidBST = (root) => { const dfs = (node, min, max) => { if (!node) return true; if (node.val <= min || node.val >= max) return false; return dfs(node.left, min, node.val) && dfs(node.right, node.val, max); }; return dfs(root, -Infinity, Infinity); };",No,No,O(n),3
"const kthSmallest = (root, k) => { const stack = []; let count = 0; while (true) { while (root) { stack.push(root); root = root.left; } root = stack.pop(); count++; if (count === k) return root.val; root = root.right; } };",No,No,O(n),3
"const levelOrder = (root) => { if (!root) return []; const result = []; const queue = [root]; while (queue.length) { const level = []; const size = queue.length; for (let i = 0; i < size; i++) { const node = queue.shift(); level.push(node.val); if (node.left) queue.push(node.left); if (node.right) queue.push(node.right); } result.push(level); } return result; };",No,No,O(n),3
"const lowestCommonAncestor = (root, p, q) => { if (!root || root === p || root === q) return root; const left = lowestCommonAncestor(root.left, p, q); const right = lowestCommonAncestor(root.right, p, q); return left && right ? root : left || right; };",No,No,O(n),3
"const serialize = (root) => { const result = []; const dfs = (node) => { if (!node) { result.push('null'); return; } result.push(node.val); dfs(node.left); dfs(node.right); }; dfs(root); return result.join(','); };",No,No,O(n),3
"const deserialize = (data) => { const nodes = data.split(','); const buildTree = () => { if (nodes[0] === 'null') { nodes.shift(); return null; } const node = new TreeNode(nodes.shift()); node.left = buildTree(); node.right = buildTree(); return node; }; return buildTree(); };",No,No,O(n),3
"const zigzagLevelOrder = (root) => { if (!root) return []; const result = []; const queue = [root]; let leftToRight = true; while (queue.length) { const level = []; const size = queue.length; for (let i = 0; i < size; i++) { const node = queue.shift(); level.push(node.val); if (node.left) queue.push(node.left); if (node.right) queue.push(node.right); } if (!leftToRight) level.reverse(); result.push(level); leftToRight = !leftToRight; } return result; };",No,No,O(n),3
"const setZeroes = (matrix) => { const rows = new Set(), cols = new Set(); for (let i = 0; i < matrix.length; i++) { for (let j = 0; j < matrix[0].length; j++) { if (matrix[i][j] === 0) { rows.add(i); cols.add(j); } } } for (let i = 0; i < matrix.length; i++) { for (let j = 0; j < matrix[0].length; j++) { if (rows.has(i) || cols.has(j)) matrix[i][j] = 0; } } };",No,No,O(m * n),3
"const rotate = (matrix) => { const n = matrix.length; for (let i = 0; i < n; i++) { for (let j = i; j < n; j++) { [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]]; } } for (let i = 0; i < n; i++) matrix[i].reverse(); };",No,No,O(n^2),3
"const spiralOrder = (matrix) => { if (!matrix.length) return []; const result = []; const top = 0, bottom = matrix.length - 1, left = 0, right = matrix[0].length - 1; while (top <= bottom && left <= right) { for (let i = left; i <= right; i++) result.push(matrix[top][i]); top++; for (let i = top; i <= bottom; i++) result.push(matrix[i][right]); right--; if (top <= bottom) { for (let i = right; i >= left; i--) result.push(matrix[bottom][i]); bottom--; } if (left <= right) { for (let i = bottom; i >= top; i--) result.push(matrix[i][left]); left++; } } return result; };",No,No,O(m * n),3
"const generateMatrix = (n) => { const matrix = Array.from({ length: n }, () => Array(n).fill(0)); let left = 0, right = n - 1, top = 0, bottom = n - 1, num = 1; while (left <= right && top <= bottom) { for (let i = left; i <= right; i++) matrix[top][i] = num++; top++; for (let i = top; i <= bottom; i++) matrix[i][right] = num++; right--; for (let i = right; i >= left; i--) matrix[bottom][i] = num++; bottom--; for (let i = bottom; i >= top; i--) matrix[i][left] = num++; left++; } return matrix; };",No,No,O(n^2),3
"const rotateImage = (matrix) => { const n = matrix.length; for (let i = 0; i < n; i++) { for (let j = i; j < n; j++) { [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]]; } } for (let i = 0; i < n; i++) matrix[i].reverse(); };",No,No,O(n^2),3
"const maxAreaOfIsland = (grid) => { const dfs = (i, j) => { if (i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || grid[i][j] === 0) return 0; grid[i][j] = 0; return 1 + dfs(i - 1, j) + dfs(i + 1, j) + dfs(i, j - 1) + dfs(i, j + 1); }; let maxArea = 0; for (let i = 0; i < grid.length; i++) { for (let j = 0; j < grid[0].length; j++) { if (grid[i][j] === 1) maxArea = Math.max(maxArea, dfs(i, j)); } } return maxArea; };",No,No,O(m * n),3
"const numIslands = (grid) => { if (!grid.length) return 0; let count = 0; const dfs = (i, j) => { if (i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || grid[i][j] === '0') return; grid[i][j] = '0'; dfs(i - 1, j); dfs(i + 1, j); dfs(i, j - 1); dfs(i, j + 1); }; for (let i = 0; i < grid.length; i++) { for (let j = 0; j < grid[0].length; j++) { if (grid[i][j] === '1') { count++; dfs(i, j); } } } return count; };",No,No,O(m * n),3
"const pacificAtlantic = (heights) => { const m = heights.length, n = heights[0].length; const pacific = Array.from({ length: m }, () => Array(n).fill(false)); const atlantic = Array.from({ length: m }, () => Array(n).fill(false)); const dfs = (i, j, ocean) => { ocean[i][j] = true; for (const [x, y] of [[1, 0], [-1, 0], [0, 1], [0, -1]]) { if (i + x >= 0 && i + x < m && j + y >= 0 && j + y < n && heights[i + x][j + y] >= heights[i][j] && !ocean[i + x][j + y]) { dfs(i + x, j + y, ocean); } } }; for (let i = 0; i < m; i++) { dfs(i, 0, pacific); dfs(i, n - 1, atlantic); } for (let j = 0; j < n; j++) { dfs(0, j, pacific); dfs(m - 1, j, atlantic); } return pacific.flatMap((row, i) => row.map((val, j) => (val && atlantic[i][j] ? [i, j] : []))).filter(Boolean); };",No,No,O(m * n),3
"const wordSearch = (board, word) => { const dfs = (i, j, index) => { if (index === word.length) return true; if (i < 0 || i >= board.length || j < 0 || j >= board[0].length || board[i][j] !== word[index]) return false; const temp = board[i][j]; board[i][j] = '#'; const found = dfs(i + 1, j, index + 1) || dfs(i - 1, j, index + 1) || dfs(i, j + 1, index + 1) || dfs(i, j - 1, index + 1); board[i][j] = temp; return found; }; for (let i = 0; i < board.length; i++) { for (let j = 0; j < board[0].length; j++) { if (dfs(i, j, 0)) return true; } } return false; };",No,No,O(m * n),3
"const findWords = (board, words) => { const trie = new Trie(); for (const word of words) trie.insert(word); const result = new Set(); const dfs = (i, j, node, path) => { if (node.isEnd) { result.add(path); node.isEnd = false; } if (i < 0 || i >= board.length || j < 0 || j >= board[0].length) return; const temp = board[i][j]; if (!temp || !node.children[temp]) return; board[i][j] = '#'; for (const [x, y] of [[1, 0], [-1, 0], [0, 1], [0, -1]]) dfs(i + x, j + y, node.children[temp], path + temp); board[i][j] = temp; }; for (let i = 0; i < board.length; i++) { for (let j = 0; j < board[0].length; j++) { dfs(i, j, trie.root, ''); } } return Array.from(result); };",No,No,O(m * n),3
"const searchMatrix = (matrix, target) => { if (!matrix.length || !matrix[0].length) return false; let row = 0, col = matrix[0].length - 1; while (row < matrix.length && col >= 0) { if (matrix[row][col] === target) return true; if (matrix[row][col] < target) row++; else col--; } return false; };",No,No,O(m + n),3
"const longestIncreasingPath = (matrix) => { if (!matrix.length) return 0; const rows = matrix.length, cols = matrix[0].length; const dp = Array.from({ length: rows }, () => Array(cols).fill(0)); let longest = 0; const dfs = (r, c) => { if (dp[r][c]) return dp[r][c]; const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]]; for (const [x, y] of directions) { const newRow = r + x, newCol = c + y; if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols && matrix[newRow][newCol] > matrix[r][c]) { dp[r][c] = Math.max(dp[r][c], dfs(newRow, newCol)); } } return ++dp[r][c]; }; for (let r = 0; r < rows; r++) { for (let c = 0; c < cols; c++) { longest = Math.max(longest, dfs(r, c)); } } return longest; };",No,No,O(m * n),3
"const minPathSum = (grid) => { const dp = Array.from({ length: grid.length }, () => Array(grid[0].length).fill(0)); dp[0][0] = grid[0][0]; for (let i = 1; i < grid.length; i++) dp[i][0] = dp[i - 1][0] + grid[i][0]; for (let j = 1; j < grid[0].length; j++) dp[0][j] = dp[0][j - 1] + grid[0][j]; for (let i = 1; i < grid.length; i++) { for (let j = 1; j < grid[0].length; j++) { dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]; } } return dp[grid.length - 1][grid[0].length - 1]; };",No,No,O(m * n),3
"const uniquePaths = (m, n) => { const dp = Array.from({ length: m }, () => Array(n).fill(0)); for (let i = 0; i < m; i++) dp[i][0] = 1; for (let j = 0; j < n; j++) dp[0][j] = 1; for (let i = 1; i < m; i++) { for (let j = 1; j < n; j++) { dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } return dp[m - 1][n - 1]; };",No,No,O(m * n),3
"const canJump = (nums) => { let maxReach = 0; for (let i = 0; i < nums.length; i++) { if (i > maxReach) return false; maxReach = Math.max(maxReach, i + nums[i]); } return true; };",No,No,O(n),3
"const jump = (nums) => { let jumps = 0, currentEnd = 0, farthest = 0; for (let i = 0; i < nums.length - 1; i++) { farthest = Math.max(farthest, i + nums[i]); if (i === currentEnd) { jumps++; currentEnd = farthest; } } return jumps; };",No,No,O(n),3
"const canCompleteCircuit = (gas, cost) => { let total = 0, currentTank = 0, startIndex = 0; for (let i = 0; i < gas.length; i++) { total += gas[i] - cost[i]; currentTank += gas[i] - cost[i]; if (currentTank < 0) { startIndex = i + 1; currentTank = 0; } } return total >= 0 ? startIndex : -1; };",No,No,O(n),3
"const findMin = (nums) => { let left = 0, right = nums.length - 1; while (left < right) { const mid = Math.floor((left + right) / 2); if (nums[mid] > nums[right]) left = mid + 1; else right = mid; } return nums[left]; };",No,No,O(log n),3
"const search = (nums, target) => { let left = 0, right = nums.length - 1; while (left <= right) { const mid = Math.floor((left + right) / 2); if (nums[mid] === target) return mid; if (nums[mid] < target) left = mid + 1; else right = mid - 1; } return -1; };",No,No,O(log n),3
"const countSubstrings = (s) => { const dp = Array.from({ length: s.length }, () => Array(s.length).fill(false)); let count = 0; for (let i = 0; i < s.length; i++) { dp[i][i] = true; count++; } for (let i = 0; i < s.length - 1; i++) { if (s[i] === s[i + 1]) { dp[i][i + 1] = true; count++; } } for (let len = 3; len <= s.length; len++) { for (let i = 0; i < s.length - len + 1; i++) { const j = i + len - 1; if (s[i] === s[j] && dp[i + 1][j - 1]) { dp[i][j] = true; count++; } } } return count; };",No,No,O(n^2),3
"const longestPalindrome = (s) => { if (s.length < 2) return s; let start = 0, end = 0; const expandAroundCenter = (left, right) => { while (left >= 0 && right < s.length && s[left] === s[right]) { left--; right++; } return right - left - 1; }; for (let i = 0; i < s.length; i++) { const len1 = expandAroundCenter(i, i); const len2 = expandAroundCenter(i, i + 1); const len = Math.max(len1, len2); if (len > end - start) { start = i - Math.floor((len - 1) / 2); end = i + Math.floor(len / 2); } } return s.substring(start, end + 1); };",No,No,O(n^2),3
"const minCut = (s) => { const dp = new Array(s.length).fill(0); for (let i = 0; i < s.length; i++) dp[i] = i; for (let i = 0; i < s.length; i++) { for (let j = 0; j <= i; j++) { if (s[j] === s[i] && (i - j < 2 || dp[j + 1] === dp[i])) { dp[j] = dp[i] + 1; } } } return dp[0] - 1; };",No,No,O(n^2),3
"const partition = (s) => { const result = []; const backtrack = (start, path) => { if (start === s.length) { result.push([...path]); return; } for (let i = start; i < s.length; i++) { if (isPalindrome(s, start, i)) { path.push(s.slice(start, i + 1)); backtrack(i + 1, path); path.pop(); } } }; backtrack(0, []); return result; }; const isPalindrome = (s, left, right) => { while (left < right) { if (s[left] !== s[right]) return false; left++; right--; } return true; };",No,No,O(n^2),3
"const searchRange = (nums, target) => { let left = -1, right = -1; let low = 0, high = nums.length - 1; while (low <= high) { const mid = Math.floor((low + high) / 2); if (nums[mid] < target) low = mid + 1; else if (nums[mid] > target) high = mid - 1; else { left = mid; high = mid - 1; } } low = 0; high = nums.length - 1; while (low <= high) { const mid = Math.floor((low + high) / 2); if (nums[mid] < target) low = mid + 1; else if (nums[mid] > target) high = mid - 1; else { right = mid; low = mid + 1; } } return [left, right]; };",No,No,O(log n),3
"const majorityElement = (nums) => { let count = 0, candidate; for (const num of nums) { if (count === 0) candidate = num; count += (num === candidate ? 1 : -1); } return candidate; };",No,No,O(n),3
"const singleNumber = (nums) => { const set = new Set(); for (const num of nums) { if (set.has(num)) set.delete(num); else set.add(num); } return [...set][0]; };",No,No,O(n),3
"const twoSum = (nums, target) => { const map = new Map(); for (let i = 0; i < nums.length; i++) { const complement = target - nums[i]; if (map.has(complement)) return [map.get(complement), i]; map.set(nums[i], i); } return []; };",No,No,O(n),3
"const removeDuplicates = (nums) => { let uniqueIndex = 0; for (let i = 1; i < nums.length; i++) { if (nums[i] !== nums[uniqueIndex]) { uniqueIndex++; nums[uniqueIndex] = nums[i]; } } return uniqueIndex + 1; };",No,No,O(n),3
"const rotate = (nums, k) => { k %= nums.length; const reverse = (arr, start, end) => { while (start < end) { [arr[start], arr[end]] = [arr[end], arr[start]]; start++; end--; } }; reverse(nums, 0, nums.length - 1); reverse(nums, 0, k - 1); reverse(nums, k, nums.length - 1); };",No,No,O(n),3
"const intersect = (nums1, nums2) => { const map = new Map(); for (const num of nums1) { map.set(num, (map.get(num) || 0) + 1); } const result = []; for (const num of nums2) { if (map.get(num) > 0) { result.push(num); map.set(num, map.get(num) - 1); } } return result; };",No,No,O(n),3
"const plusOne = (digits) => { for (let i = digits.length - 1; i >= 0; i--) { if (digits[i] < 9) { digits[i]++; return digits; } digits[i] = 0; } return [1, ...digits]; };",No,No,O(n),3
"const lengthOfLastWord = (s) => { const words = s.trim().split(' '); return words.length ? words[words.length - 1].length : 0; };",No,No,O(n),3
"const reverseString = (s) => { return s.split('').reverse().join(''); };",No,No,O(n),3
"const validParentheses = (s) => { const stack = []; for (const char of s) { if (char === '(') stack.push(')'); else if (stack.pop() !== char) return false; } return stack.length === 0; };",No,No,O(n),3
"const threeSum = (nums) => { nums.sort((a, b) => a - b); const result = []; for (let i = 0; i < nums.length; i++) { if (i > 0 && nums[i] === nums[i - 1]) continue; let left = i + 1, right = nums.length - 1; while (left < right) { const sum = nums[i] + nums[left] + nums[right]; if (sum === 0) { result.push([nums[i], nums[left], nums[right]]); while (left < right && nums[left] === nums[left + 1]) left++; while (left < right && nums[right] === nums[right - 1]) right--; left++; right--; } else if (sum < 0) left++; else right--; } } return result; };",No,No,O(n^2),3
"const fourSum = (nums, target) => { nums.sort((a, b) => a - b); const result = []; for (let i = 0; i < nums.length - 3; i++) { if (i > 0 && nums[i] === nums[i - 1]) continue; for (let j = i + 1; j < nums.length - 2; j++) { if (j > i + 1 && nums[j] === nums[j - 1]) continue; let left = j + 1, right = nums.length - 1; while (left < right) { const sum = nums[i] + nums[j] + nums[left] + nums[right]; if (sum === target) { result.push([nums[i], nums[j], nums[left], nums[right]]); while (left < right && nums[left] === nums[left + 1]) left++; while (left < right && nums[right] === nums[right - 1]) right--; left++; right--; } else if (sum < target) left++; else right--; } } } return result; };",No,No,O(n^3),3
"const merge = (intervals) => { if (intervals.length === 0) return []; intervals.sort((a, b) => a[0] - b[0]); const merged = [intervals[0]]; for (let i = 1; i < intervals.length; i++) { const [start, end] = intervals[i]; const [lastStart, lastEnd] = merged[merged.length - 1]; if (start <= lastEnd) { merged[merged.length - 1][1] = Math.max(lastEnd, end); } else { merged.push(intervals[i]); } } return merged; };",No,No,O(n log n),3
"const groupAnagrams = (strs) => { const map = new Map(); for (const str of strs) { const key = str.split('').sort().join(''); if (!map.has(key)) map.set(key, []); map.get(key).push(str); } return Array.from(map.values()); };",No,No,O(n * k log k),3
"const topKFrequent = (nums, k) => { const countMap = new Map(); for (const num of nums) { countMap.set(num, (countMap.get(num) || 0) + 1); } const sorted = [...countMap.entries()].sort((a, b) => b[1] - a[1]); return sorted.slice(0, k).map(([num]) => num); };",No,No,O(n log n),3
"const findKthLargest = (nums, k) => { const quickSelect = (left, right) => { const pivot = nums[right]; let index = left; for (let i = left; i < right; i++) { if (nums[i] > pivot) { [nums[i], nums[index]] = [nums[index], nums[i]]; index++; } } [nums[index], nums[right]] = [nums[right], nums[index]]; return index; }; let left = 0, right = nums.length - 1; while (true) { const index = quickSelect(left, right); if (index === k - 1) return nums[index]; if (index < k - 1) left = index + 1; else right = index - 1; } };",No,No,O(n),3
"const findPeakElement = (nums) => { let left = 0, right = nums.length - 1; while (left < right) { const mid = Math.floor((left + right) / 2); if (nums[mid] < nums[mid + 1]) left = mid + 1; else right = mid; } return left; };",No,No,O(log n),3
"const longestCommonPrefix = (strs) => { if (strs.length === 0) return ''; let prefix = strs[0]; for (let i = 1; i < strs.length; i++) { while (strs[i].indexOf(prefix) !== 0) { prefix = prefix.substring(0, prefix.length - 1); if (prefix === '') return ''; } } return prefix; };",No,No,O(m*n),3
"const isValidSudoku = (board) => { const rows = Array(9).fill(0).map(() => new Set()), columns = Array(9).fill(0).map(() => new Set()), boxes = Array(9).fill(0).map(() => new Set()); for (let i = 0; i < 9; i++) { for (let j = 0; j < 9; j++) { const num = board[i][j]; if (num !== '.') { const boxIndex = Math.floor(i / 3) * 3 + Math.floor(j / 3); if (rows[i].has(num) || columns[j].has(num) || boxes[boxIndex].has(num)) return false; rows[i].add(num); columns[j].add(num); boxes[boxIndex].add(num); } } } return true; };",No,No,O(n^2),3
"const mergeKLists = (lists) => { const mergeTwoLists = (l1, l2) => { let dummy = new ListNode(0), current = dummy; while (l1 && l2) { if (l1.val < l2.val) { current.next = l1; l1 = l1.next; } else { current.next = l2; l2 = l2.next; } current = current.next; } current.next = l1 || l2; return dummy.next; }; let interval = lists; while (interval.length > 1) { const merged = []; for (let i = 0; i < interval.length; i += 2) { const l1 = interval[i], l2 = interval[i + 1] || null; merged.push(mergeTwoLists(l1, l2)); } interval = merged; } return interval[0] || null; };",No,No,O(n*k),3
"const searchInsert = (nums, target) => { let left = 0, right = nums.length - 1; while (left <= right) { const mid = Math.floor((left + right) / 2); if (nums[mid] === target) return mid; else if (nums[mid] < target) left = mid + 1; else right = mid - 1; } return left; };",No,No,O(log n),3
"const coinChange = (coins, amount) => { const dp = Array(amount + 1).fill(Infinity); dp[0] = 0; for (const coin of coins) { for (let i = coin; i <= amount; i++) { dp[i] = Math.min(dp[i], dp[i - coin] + 1); } } return dp[amount] === Infinity ? -1 : dp[amount]; };",No,No,O(n*m),3
"const numDistinct = (s, t) => { const dp = Array(t.length + 1).fill(0); dp[0] = 1; for (let i = 0; i < s.length; i++) { for (let j = t.length - 1; j >= 0; j--) { if (s[i] === t[j]) dp[j + 1] += dp[j]; } } return dp[t.length]; };",No,No,O(n*m),3
"const lengthOfLIS = (nums) => { const dp = []; for (const num of nums) { let left = 0, right = dp.length; while (left < right) { const mid = Math.floor((left + right) / 2); if (dp[mid] < num) left = mid + 1; else right = mid; } dp[left] = num; } return dp.length; };",No,No,O(n log n),3
"const longestPalindromeSubseq = (s) => { const dp = Array(s.length).fill(0).map(() => Array(s.length).fill(0)); for (let i = 0; i < s.length; i++) dp[i][i] = 1; for (let length = 2; length <= s.length; length++) { for (let i = 0; i < s.length - length + 1; i++) { const j = i + length - 1; if (s[i] === s[j]) dp[i][j] = dp[i + 1][j - 1] + 2; else dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]); } } return dp[0][s.length - 1]; };",No,No,O(n^2),3
"const uniquePaths = (m, n) => { const dp = Array(m).fill(0).map(() => Array(n).fill(0)); for (let i = 0; i < m; i++) dp[i][0] = 1; for (let j = 0; j < n; j++) dp[0][j] = 1; for (let i = 1; i < m; i++) { for (let j = 1; j < n; j++) { dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } return dp[m - 1][n - 1]; };",No,No,O(m*n),3
"const numIslands = (grid) => { if (grid.length === 0) return 0; const visited = new Set(), directions = [[1, 0], [-1, 0], [0, 1], [0, -1]]; const dfs = (i, j) => { if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] === '0' || visited.has(`${i},${j}`)) return; visited.add(`${i},${j}`); for (const [dx, dy] of directions) dfs(i + dx, j + dy); }; let count = 0; for (let i = 0; i < grid.length; i++) { for (let j = 0; j < grid[0].length; j++) { if (grid[i][j] === '1' && !visited.has(`${i},${j}`)) { dfs(i, j); count++; } } } return count; };",No,No,O(m*n),3
"const setZeroes = (matrix) => { const rows = new Set(), cols = new Set(); for (let i = 0; i < matrix.length; i++) { for (let j = 0; j < matrix[0].length; j++) { if (matrix[i][j] === 0) { rows.add(i); cols.add(j); } } } for (const row of rows) { for (let j = 0; j < matrix[0].length; j++) matrix[row][j] = 0; } for (const col of cols) { for (let i = 0; i < matrix.length; i++) matrix[i][col] = 0; } };",No,No,O(m*n),3
"const trap = (height) => { const n = height.length; if (n === 0) return 0; const leftMax = new Array(n).fill(0); const rightMax = new Array(n).fill(0); leftMax[0] = height[0]; for (let i = 1; i < n; i++) leftMax[i] = Math.max(leftMax[i - 1], height[i]); rightMax[n - 1] = height[n - 1]; for (let i = n - 2; i >= 0; i--) rightMax[i] = Math.max(rightMax[i + 1], height[i]); let totalWater = 0; for (let i = 0; i < n; i++) totalWater += Math.min(leftMax[i], rightMax[i]) - height[i]; return totalWater; };",No,No,O(n),3
"const findSubstring = (s, words) => { if (words.length === 0 || s.length === 0) return []; const wordLength = words[0].length; const totalLength = wordLength * words.length; const result = []; const wordCount = {}; for (const word of words) { wordCount[word] = (wordCount[word] || 0) + 1; } for (let i = 0; i <= s.length - totalLength; i++) { const seen = {}; let j = 0; while (j < words.length) { const word = s.substr(i + j * wordLength, wordLength); if (!wordCount[word]) break; seen[word] = (seen[word] || 0) + 1; if (seen[word] > wordCount[word]) break; j++; } if (j === words.length) result.push(i); } return result; };",No,No,O(n*m),3
"const countSubstrings = (s) => { let result = 0; const n = s.length; const dp = Array.from({ length: n }, () => Array(n).fill(false)); for (let i = 0; i < n; i++) { dp[i][i] = true; result++; } for (let start = n - 1; start >= 0; start--) { for (let end = start + 1; end < n; end++) { if (s[start] === s[end]) { dp[start][end] = true; result++; } } } return result; };",No,No,O(n^2),3
"const combinationSum = (candidates, target) => { const result = []; const backtrack = (start, target, path) => { if (target === 0) { result.push(path.slice()); return; } if (target < 0) return; for (let i = start; i < candidates.length; i++) { path.push(candidates[i]); backtrack(i, target - candidates[i], path); path.pop(); } }; backtrack(0, target, []); return result; };",No,No,O(2^n),3
"const partition = (s) => { const result = []; const backtrack = (start, path) => { if (start === s.length) { result.push(path.slice()); return; } for (let end = start + 1; end <= s.length; end++) { const substring = s.slice(start, end); if (isPalindrome(substring)) { path.push(substring); backtrack(end, path); path.pop(); } } }; backtrack(0, []); return result; }; const isPalindrome = (str) => { let left = 0, right = str.length - 1; while (left < right) { if (str[left] !== str[right]) return false; left++; right--; } return true; };",No,No,O(2^n),3
"const generateParenthesis = (n) => { const result = []; const backtrack = (open, close, current) => { if (current.length === 2 * n) { result.push(current); return; } if (open < n) backtrack(open + 1, close, current + '('); if (close < open) backtrack(open, close + 1, current + ')'); }; backtrack(0, 0, ''); return result; };",No,No,O(2^n),3
"const numSquares = (n) => { const dp = Array(n + 1).fill(Infinity); dp[0] = 0; for (let i = 1; i * i <= n; i++) { for (let j = i * i; j <= n; j++) { dp[j] = Math.min(dp[j], dp[j - i * i] + 1); } } return dp[n]; };",No,No,O(n*sqrt(n)),3
"const minPathSum = (grid) => { const m = grid.length, n = grid[0].length; for (let i = 0; i < m; i++) { for (let j = 0; j < n; j++) { if (i === 0 && j === 0) continue; const left = j > 0 ? grid[i][j - 1] : Infinity; const up = i > 0 ? grid[i - 1][j] : Infinity; grid[i][j] += Math.min(left, up); } } return grid[m - 1][n - 1]; };",No,No,O(m*n),3
"const countVowels = (s) => { const vowels = new Set(['a', 'e', 'i', 'o', 'u']); let count = 0; for (let i = 0; i < s.length; i++) { if (vowels.has(s[i].toLowerCase())) count++; } return count; };",No,No,O(n),3
"const maxProfit = (prices) => { let minPrice = Infinity, maxProfit = 0; for (let price of prices) { if (price < minPrice) minPrice = price; else if (price - minPrice > maxProfit) maxProfit = price - minPrice; } return maxProfit; };",No,No,O(n),3
"const minMeetingRooms = (intervals) => { if (intervals.length === 0) return 0; const startTimes = intervals.map(interval => interval[0]).sort((a, b) => a - b); const endTimes = intervals.map(interval => interval[1]).sort((a, b) => a - b); let rooms = 0, endIndex = 0; for (let startIndex = 0; startIndex < startTimes.length; startIndex++) { if (startTimes[startIndex] < endTimes[endIndex]) rooms++; else endIndex++; } return rooms; };",No,No,O(n log n),3
"const sortColors = (nums) => { let zeroIndex = 0, twoIndex = nums.length - 1; for (let i = 0; i <= twoIndex; ) { if (nums[i] === 0) { [nums[zeroIndex], nums[i]] = [nums[i], nums[zeroIndex]]; zeroIndex++; i++; } else if (nums[i] === 2) { [nums[twoIndex], nums[i]] = [nums[i], nums[twoIndex]]; twoIndex--; } else { i++; } } };",No,No,O(n),3
"const maxArea = (height) => { let left = 0, right = height.length - 1, maxArea = 0; while (left < right) { const area = Math.min(height[left], height[right]) * (right - left); maxArea = Math.max(maxArea, area); if (height[left] < height[right]) left++; else right--; } return maxArea; };",No,No,O(n),3
"const searchRange = (nums, target) => { const binarySearch = (isLeft) => { let left = 0, right = nums.length - 1; let result = -1; while (left <= right) { const mid = Math.floor((left + right) / 2); if (nums[mid] === target) { result = mid; if (isLeft) right = mid - 1; else left = mid + 1; } else if (nums[mid] < target) left = mid + 1; else right = mid - 1; } return result; }; return [binarySearch(true), binarySearch(false)]; };",No,No,O(log n),3
"const spiralOrder = (matrix) => { const result = []; if (matrix.length === 0) return result; let top = 0, bottom = matrix.length - 1, left = 0, right = matrix[0].length - 1; while (top <= bottom && left <= right) { for (let i = left; i <= right; i++) result.push(matrix[top][i]); top++; for (let i = top; i <= bottom; i++) result.push(matrix[i][right]); right--; if (top <= bottom) { for (let i = right; i >= left; i--) result.push(matrix[bottom][i]); bottom--; } if (left <= right) { for (let i = bottom; i >= top; i--) result.push(matrix[i][left]); left++; } } return result; };",No,No,O(m*n),3
"const rotate = (nums, k) => { k %= nums.length; const reverse = (start, end) => { while (start < end) { [nums[start], nums[end]] = [nums[end], nums[start]]; start++; end--; } }; reverse(0, nums.length - 1); reverse(0, k - 1); reverse(k, nums.length - 1); };",No,No,O(n),3
"const longestCommonPrefix = (strs) => { if (strs.length === 0) return ''; let prefix = strs[0]; for (let i = 1; i < strs.length; i++) { while (strs[i].indexOf(prefix) !== 0) { prefix = prefix.substring(0, prefix.length - 1); if (prefix === '') return ''; } } return prefix; };",No,No,O(m*n),3
"const isValidSudoku = (board) => { const rows = Array(9).fill(0).map(() => new Set()), columns = Array(9).fill(0).map(() => new Set()), boxes = Array(9).fill(0).map(() => new Set()); for (let i = 0; i < 9; i++) { for (let j = 0; j < 9; j++) { const num = board[i][j]; if (num !== '.') { const boxIndex = Math.floor(i / 3) * 3 + Math.floor(j / 3); if (rows[i].has(num) || columns[j].has(num) || boxes[boxIndex].has(num)) return false; rows[i].add(num); columns[j].add(num); boxes[boxIndex].add(num); } } } return true; };",No,No,O(n^2),3
"const mergeKLists = (lists) => { const mergeTwoLists = (l1, l2) => { let dummy = new ListNode(0), current = dummy; while (l1 && l2) { if (l1.val < l2.val) { current.next = l1; l1 = l1.next; } else { current.next = l2; l2 = l2.next; } current = current.next; } current.next = l1 || l2; return dummy.next; }; let result = lists[0]; for (let i = 1; i < lists.length; i++) result = mergeTwoLists(result, lists[i]); return result; };",No,No,O(n log k),3
"const reverseKGroup = (head, k) => { let count = 0, curr = head; while (curr && count < k) { curr = curr.next; count++; } if (count === k) { let prev = null, next = null; curr = head; while (count > 0) { next = curr.next; curr.next = prev; prev = curr; curr = next; count--; } head.next = reverseKGroup(curr, k); return prev; } return head; };",No,No,O(n),3
"const isAnagram = (s, t) => { if (s.length !== t.length) return false; const count = {}; for (const char of s) count[char] = (count[char] || 0) + 1; for (const char of t) { if (!count[char]) return false; count[char]--; } return true; };",No,No,O(n),3
"const maxSlidingWindow = (nums, k) => { const result = []; const deque = []; for (let i = 0; i < nums.length; i++) { if (deque.length && deque[0] === i - k) deque.shift(); while (deque.length && nums[deque[deque.length - 1]] < nums[i]) deque.pop(); deque.push(i); if (i >= k - 1) result.push(nums[deque[0]]); } return result; };",No,No,O(n),3
"const combinationSum4 = (nums, target) => { const dp = Array(target + 1).fill(0); dp[0] = 1; for (let i = 1; i <= target; i++) { for (let num of nums) { if (i - num >= 0) dp[i] += dp[i - num]; } } return dp[target]; };",No,No,O(n * target),3
"const twoSum = (nums, target) => { const numMap = new Map(); for (let i = 0; i < nums.length; i++) { const complement = target - nums[i]; if (numMap.has(complement)) return [numMap.get(complement), i]; numMap.set(nums[i], i); } return []; };",No,No,O(n),3
"const isSubsequence = (s, t) => { let i = 0; for (const char of t) { if (char === s[i]) i++; if (i === s.length) return true; } return false; };",No,No,O(n),3
"const climbingStairs = (n) => { const dp = Array(n + 1).fill(0); dp[0] = 1; for (let i = 1; i <= n; i++) { dp[i] = dp[i - 1]; if (i - 2 >= 0) dp[i] += dp[i - 2]; } return dp[n]; };",No,No,O(n),3
"const dailyTemperatures = (temperatures) => { const result = Array(temperatures.length).fill(0); const stack = []; for (let i = 0; i < temperatures.length; i++) { while (stack.length && temperatures[i] > temperatures[stack[stack.length - 1]]) { const j = stack.pop(); result[j] = i - j; } stack.push(i); } return result; };",No,No,O(n),3
"const connect = (root) => { if (!root) return null; const queue = [root]; while (queue.length) { let size = queue.length; for (let i = 0; i < size; i++) { const node = queue.shift(); if (i < size - 1) node.next = queue[0]; if (node.left) queue.push(node.left); if (node.right) queue.push(node.right); } } return root; };",No,No,O(n),3
"const rotateRight = (head, k) => { if (!head || !head.next) return head; let length = 1, tail = head; while (tail.next) { tail = tail.next; length++; } k %= length; if (k === 0) return head; let slow = head, fast = head; for (let i = 0; i < k; i++) fast = fast.next; while (fast.next) { slow = slow.next; fast = fast.next; } const newHead = slow.next; slow.next = null; tail.next = head; return newHead; };",No,No,O(n),3
"const permute = (nums) => { const result = []; const backtrack = (path) => { if (path.length === nums.length) result.push(path.slice()); for (let num of nums) { if (!path.includes(num)) { path.push(num); backtrack(path); path.pop(); } } }; backtrack([]); return result; };",No,No,O(n!),3
"const insert = (head, newNode) => { if (!head) return newNode; if (newNode.val < head.val) { newNode.next = head; return newNode; } head.next = insert(head.next, newNode); return head; };",No,No,O(n),3
"const validateBinaryTreeNodes = (n, leftChild, rightChild) => { const indegree = Array(n).fill(0); for (let i = 0; i < n; i++) { if (leftChild[i] !== -1) indegree[leftChild[i]]++; if (rightChild[i] !== -1) indegree[rightChild[i]]++; } return indegree.filter(x => x === 0).length === 1 && indegree.filter(x => x > 1).length === 0; };",No,No,O(n),3
"const topKFrequent = (nums, k) => { const count = {}; for (const num of nums) count[num] = (count[num] || 0) + 1; return Object.entries(count).sort((a, b) => b[1] - a[1]).slice(0, k).map(([num]) => parseInt(num)); };",No,No,O(n log n),3
"const findDuplicate = (nums) => { let slow = nums[0], fast = nums[0]; while (true) { slow = nums[slow]; fast = nums[nums[fast]]; if (slow === fast) break; } let ptr1 = nums[0], ptr2 = slow; while (ptr1 !== ptr2) { ptr1 = nums[ptr1]; ptr2 = nums[ptr2]; } return ptr1; };",No,No,O(n),3
"const longestSubarray = (nums, limit) => { let left = 0, maxLength = 0, maxDeque = [], minDeque = []; for (let right = 0; right < nums.length; right++) { while (maxDeque.length && nums[maxDeque[maxDeque.length - 1]] < nums[right]) maxDeque.pop(); while (minDeque.length && nums[minDeque[minDeque.length - 1]] > nums[right]) minDeque.pop(); maxDeque.push(right); minDeque.push(right); while (nums[maxDeque[0]] - nums[minDeque[0]] > limit) left++; if (right - left + 1 > maxLength) maxLength = right - left + 1; } return maxLength; };",No,No,O(n),3
"const missingNumber = (nums) => { const n = nums.length; const expectedSum = (n * (n + 1)) / 2; const actualSum = nums.reduce((sum, num) => sum + num, 0); return expectedSum - actualSum; };",No,No,O(n),3
"const longestPalindromeSubseq = (s) => { const n = s.length; const dp = Array(n).fill(0).map(() => Array(n).fill(0)); for (let i = 0; i < n; i++) dp[i][i] = 1; for (let length = 2; length <= n; length++) { for (let start = 0; start <= n - length; start++) { const end = start + length - 1; if (s[start] === s[end]) dp[start][end] = dp[start + 1][end - 1] + 2; else dp[start][end] = Math.max(dp[start + 1][end], dp[start][end - 1]); } } return dp[0][n - 1]; };",No,No,O(n^2),3
"const kClosest = (points, k) => { return points.sort((a, b) => (a[0] ** 2 + a[1] ** 2) - (b[0] ** 2 + b[1] ** 2)).slice(0, k); };",No,No,O(n log n),3
"const canConstruct = (ransomNote, magazine) => { const magazineCount = {}; for (const char of magazine) magazineCount[char] = (magazine
"const findKthLargest = (nums, k) => nums.sort((a, b) => b - a)[k - 1];",No,No,O(n log n),3
"const maxProfit = (prices) => { let minPrice = prices[0], maxProfit = 0; for (let price of prices) { minPrice = Math.min(minPrice, price); maxProfit = Math.max(maxProfit, price - minPrice); } return maxProfit; };",No,No,O(n),3
"const rob = (nums) => { if (!nums.length) return 0; if (nums.length === 1) return nums[0]; const dp = [nums[0], Math.max(nums[0], nums[1])]; for (let i = 2; i < nums.length; i++) dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]); return dp[nums.length - 1]; };",No,No,O(n),3
"const wordBreak = (s, wordDict) => { const dp = Array(s.length + 1).fill(false); dp[0] = true; for (let i = 1; i <= s.length; i++) { for (let word of wordDict) { if (i >= word.length && s.slice(i - word.length, i) === word) dp[i] = dp[i] || dp[i - word.length]; } } return dp[s.length]; };",No,No,O(n^2),3
"const generateParenthesis = (n) => { const result = []; const generate = (current, open, close) => { if (current.length === n * 2) { result.push(current); return; } if (open < n) generate(current + '(', open + 1, close); if (close < open) generate(current + ')', open, close + 1); }; generate('', 0, 0); return result; };",No,No,O(4^n / sqrt(n)),3
"const floodFill = (image, sr, sc, newColor) => { const color = image[sr][sc]; if (color === newColor) return image; const dfs = (r, c) => { if (r < 0 || c < 0 || r >= image.length || c >= image[0].length || image[r][c] !== color) return; image[r][c] = newColor; dfs(r + 1, c); dfs(r - 1, c); dfs(r, c + 1); dfs(r, c - 1); }; dfs(sr, sc); return image; };",No,No,O(n),3
"const deleteDuplicates = (head) => { let current = head; while (current && current.next) { if (current.val === current.next.val) current.next = current.next.next; else current = current.next; } return head; };",No,No,O(n),3
"const detectCycle = (head) => { if (!head) return null; let slow = head, fast = head; while (fast && fast.next) { slow = slow.next; fast = fast.next.next; if (slow === fast) { let pointer = head; while (pointer !== slow) { pointer = pointer.next; slow = slow.next; } return pointer; } } return null; };",No,No,O(n),3
"const diameterOfBinaryTree = (root) => { let diameter = 0; const depth = (node) => { if (!node) return 0; const left = depth(node.left); const right = depth(node.right); diameter = Math.max(diameter, left + right); return Math.max(left, right) + 1; }; depth(root); return diameter; };",No,No,O(n),3
"const invertTree = (root) => { if (!root) return null; const left = invertTree(root.left); const right = invertTree(root.right); root.left = right; root.right = left; return root; };",No,No,O(n),3
"const isSymmetric = (root) => { const isMirror = (t1, t2) => { if (!t1 && !t2) return true; if (!t1 || !t2) return false; return (t1.val === t2.val) && isMirror(t1.right, t2.left) && isMirror(t1.left, t2.right); }; return isMirror(root, root); };",No,No,O(n),3
"const maxDepth = (root) => { if (!root) return 0; const leftDepth = maxDepth(root.left); const rightDepth = maxDepth(root.right); return Math.max(leftDepth, rightDepth) + 1; };",No,No,O(n),3
"const mergeTwoLists = (l1, l2) => { if (!l1) return l2; if (!l2) return l1; if (l1.val < l2.val) { l1.next = mergeTwoLists(l1.next, l2); return l1; } else { l2.next = mergeTwoLists(l1, l2.next); return l2; } };",No,No,O(n),3
"const minDepth = (root) => { if (!root) return 0; const left = minDepth(root.left); const right = minDepth(root.right); if (!root.left || !root.right) return left + right + 1; return Math.min(left, right) + 1; };",No,No,O(n),3
"const pathSum = (root, targetSum) => { if (!root) return []; const result = []; const dfs = (node, sum, path) => { if (!node) return; path.push(node.val); if (!node.left && !node.right && sum === node.val) result.push([...path]); dfs(node.left, sum - node.val, path); dfs(node.right, sum - node.val, path); path.pop(); }; dfs(root, targetSum, []); return result; };",No,No,O(n),3
"const sortedArrayToBST = (nums) => { if (!nums.length) return null; const mid = Math.floor(nums.length / 2); const root = new TreeNode(nums[mid]); root.left = sortedArrayToBST(nums.slice(0, mid)); root.right = sortedArrayToBST(nums.slice(mid + 1)); return root; };",No,No,O(n),3
"const findDuplicates = (nums) => { const result = []; for (let i = 0; i < nums.length; i++) { const index = Math.abs(nums[i]) - 1; if (nums[index] < 0) result.push(Math.abs(nums[i])); else nums[index] = -nums[index]; } return result; };",No,No,O(n),3
"const threeSum = (nums) => { nums.sort((a, b) => a - b); const result = []; for (let i = 0; i < nums.length - 2; i++) { if (i > 0 && nums[i] === nums[i - 1]) continue; let left = i + 1, right = nums.length - 1; while (left < right) { const sum = nums[i] + nums[left] + nums[right]; if (sum === 0) { result.push([nums[i], nums[left], nums[right]]); while (nums[left] === nums[left + 1]) left++; while (nums[right] === nums[right - 1]) right--; left++; right--; } else if (sum < 0) left++; else right--; } } return result; };",No,No,O(n^2),3
"const trap = (height) => { let left = 0, right = height.length - 1, leftMax = 0, rightMax = 0, total = 0; while (left < right) { if (height[left] < height[right]) { if (height[left] >= leftMax) leftMax = height[left]; else total += leftMax - height[left]; left++; } else { if (height[right] >= rightMax) rightMax = height[right]; else total += rightMax - height[right]; right--; } } return total; };",No,No,O(n),3
"const climbStairs = (n) => { const dp = [1, 1]; for (let i = 2; i <= n; i++) dp[i] = dp[i - 1] + dp[i - 2]; return dp[n]; };",No,No,O(n),3
"const canJump = (nums) => { let maxReach = 0; for (let i = 0; i < nums.length; i++) { if (i > maxReach) return false; maxReach = Math.max(maxReach, i + nums[i]); } return true; };",No,No,O(n),3
"const lengthOfLIS = (nums) => { const dp = Array(nums.length).fill(1); for (let i = 1; i < nums.length; i++) { for (let j = 0; j < i; j++) { if (nums[i] > nums[j]) dp[i] = Math.max(dp[i], dp[j] + 1); } } return Math.max(...dp); };",No,No,O(n^2),3
"const maxSubArray = (nums) => { let maxSum = nums[0], currentSum = 0; for (let num of nums) { currentSum = Math.max(num, currentSum + num); maxSum = Math.max(maxSum, currentSum); } return maxSum; };",No,No,O(n),3
"const permute = (nums) => { const result = []; const backtrack = (path, options) => { if (path.length === nums.length) { result.push([...path]); return; } for (let i = 0; i < options.length; i++) { path.push(options[i]); backtrack(path, options.filter((_, index) => index !== i)); path.pop(); } }; backtrack([], nums); return result; };",No,No,O(n!),3
"const searchInsert = (nums, target) => { let left = 0, right = nums.length - 1; while (left <= right) { const mid = Math.floor((left + right) / 2); if (nums[mid] === target) return mid; if (nums[mid] < target) left = mid + 1; else right = mid - 1; } return left; };",No,No,O(log n),3
"const combinationSum = (candidates, target) => { const result = []; const backtrack = (remain, path, start) => { if (remain === 0) result.push([...path]); if (remain < 0) return; for (let i = start; i < candidates.length; i++) { path.push(candidates[i]); backtrack(remain - candidates[i], path, i); path.pop(); } }; backtrack(target, [], 0); return result; };",No,No,O(2^n),3
"const rotate = (matrix) => { const n = matrix.length; for (let i = 0; i < Math.floor(n / 2); i++) { for (let j = i; j < n - i - 1; j++) { const temp = matrix[i][j]; matrix[i][j] = matrix[n - j - 1][i]; matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]; matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]; matrix[j][n - i - 1] = temp; } } };",No,No,O(n^2),3
"const nextPermutation = (nums) => { let i = nums.length - 2; while (i >= 0 && nums[i] >= nums[i + 1]) i--; if (i >= 0) { let j = nums.length - 1; while (nums[j] <= nums[i]) j--; [nums[i], nums[j]] = [nums[j], nums[i]]; } nums = nums.slice(0, i + 1).concat(nums.slice(i + 1).reverse()); };",No,No,O(n),3
"const twoSum = (nums, target) => { const map = new Map(); for (let i = 0; i < nums.length; i++) { const complement = target - nums[i]; if (map.has(complement)) return [map.get(complement), i]; map.set(nums[i], i); } return []; };",No,No,O(n),3
"const zigzagLevelOrder = (root) => { if (!root) return []; const result = [], queue = [root]; let leftToRight = true; while (queue.length) { const level = [], size = queue.length; for (let i = 0; i < size; i++) { const node = queue.shift(); if (leftToRight) level.push(node.val); else level.unshift(node.val); if (node.left) queue.push(node.left); if (node.right) queue.push(node.right); } result.push(level); leftToRight = !leftToRight; } return result; };",No,No,O(n),3
"const minPathSum = (grid) => { const dp = Array(grid.length).fill().map(() => Array(grid[0].length).fill(0)); dp[0][0] = grid[0][0]; for (let i = 1; i < grid.length; i++) dp[i][0] = dp[i - 1][0] + grid[i][0]; for (let j = 1; j < grid[0].length; j++) dp[0][j] = dp[0][j - 1] + grid[0][j]; for (let i = 1; i < grid.length; i++) { for (let j = 1; j < grid[0].length; j++) dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]; } return dp[grid.length - 1][grid[0].length - 1]; };",No,No,O(n^2),3
"const uniquePaths = (m, n) => { const dp = Array(m).fill().map(() => Array(n).fill(1)); for (let i = 1; i < m; i++) { for (let j = 1; j < n; j++) dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } return dp[m - 1][n - 1]; };",No,No,O(m*n),3
"const majorityElement = (nums) => { let count = 0, candidate = null; for (let num of nums) { if (count === 0) candidate = num; count += (num === candidate) ? 1 : -1; } return candidate; };",No,No,O(n),3
"const mergeIntervals = (intervals) => { if (!intervals.length) return []; intervals.sort((a, b) => a[0] - b[0]); const result = [intervals[0]]; for (let i = 1; i < intervals.length; i++) { const last = result[result.length - 1]; if (last[1] >= intervals[i][0]) last[1] = Math.max(last[1], intervals[i][1]); else result.push(intervals[i]); } return result; };",No,No,O(n log n),3
"const insertInterval = (intervals, newInterval) => { const result = []; for (let interval of intervals) { if (interval[1] < newInterval[0]) result.push(interval); else if (interval[0] > newInterval[1]) { result.push(newInterval); newInterval = interval; } else newInterval = [Math.min(interval[0], newInterval[0]), Math.max(interval[1], newInterval[1])]; } result.push(newInterval); return result; };",No,No,O(n),3
"const longestPalindrome = (s) => { let start = 0, maxLength = 1; const expandFromCenter = (left, right) => { while (left >= 0 && right < s.length && s[left] === s[right]) { if (right - left + 1 > maxLength) { start = left; maxLength = right - left + 1; } left--; right++; } }; for (let i = 0; i < s.length; i++) { expandFromCenter(i, i); expandFromCenter(i, i + 1); } return s.slice(start, start + maxLength); };",No,No,O(n^2),3
"const countSubstrings = (s) => { let count = 0; const expandFromCenter = (left, right) => { while (left >= 0 && right < s.length && s[left] === s[right]) { count++; left--; right++; } }; for (let i = 0; i < s.length; i++) { expandFromCenter(i, i); expandFromCenter(i, i + 1); } return count; };",No,No,O(n^2),3
"const minDistance = (word1, word2) => { const dp = Array(word1.length + 1).fill().map(() => Array(word2.length + 1).fill(0)); for (let i = 0; i <= word1.length; i++) dp[i][0] = i; for (let j = 0; j <= word2.length; j++) dp[0][j] = j; for (let i = 1; i <= word1.length; i++) { for (let j = 1; j <= word2.length; j++) { if (word1[i - 1] === word2[j - 1]) dp[i][j] = dp[i - 1][j - 1]; else dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1; } } return dp[word1.length][word2.length]; };",No,No,O(n^2),3
"const maxArea = (height) => { let left = 0, right = height.length - 1, maxArea = 0; while (left < right) { const area = Math.min(height[left], height[right]) * (right - left); maxArea = Math.max(maxArea, area); if (height[left] < height[right]) left++; else right--; } return maxArea; };",No,No,O(n),3
"const mergeKLists = (lists) => { const mergeTwoLists = (l1, l2) => { if (!l1) return l2; if (!l2) return l1; if (l1.val < l2.val) { l1.next = mergeTwoLists(l1.next, l2); return l1; } else { l2.next = mergeTwoLists(l1, l2.next); return l2; } }; if (!lists.length) return null; while (lists.length > 1) { lists.push(mergeTwoLists(lists.shift(), lists.shift())); } return lists[0]; };",No,No,O(n log k),3
"const wordBreak = (s, wordDict) => { const dp = Array(s.length + 1).fill(false); dp[0] = true; for (let i = 1; i <= s.length; i++) { for (let j = 0; j < i; j++) { if (dp[j] && wordDict.includes(s.slice(j, i))) { dp[i] = true; break; } } } return dp[s.length]; };",No,No,O(n^2),3
"const maxProduct = (nums) => { let maxProd = nums[0], minProd = nums[0], result = nums[0]; for (let i = 1; i < nums.length; i++) { const tempMax = maxProd; maxProd = Math.max(nums[i], maxProd * nums[i], minProd * nums[i]); minProd = Math.min(nums[i], tempMax * nums[i], minProd * nums[i]); result = Math.max(result, maxProd); } return result; };",No,No,O(n),3
"const maxSubArray = (nums) => { let maxSum = nums[0]; let currentSum = nums[0]; for (let i = 1; i < nums.length; i++) { currentSum = Math.max(nums[i], currentSum + nums[i]); maxSum = Math.max(maxSum, currentSum); } return maxSum; };",No,No,O(n),3
"const climbStairs = (n) => { const dp = [1, 1]; for (let i = 2; i <= n; i++) dp[i] = dp[i - 1] + dp[i - 2]; return dp[n]; };",No,No,O(n),3
"const deleteDuplicates = (head) => { let current = head; while (current && current.next) { if (current.val === current.next.val) current.next = current.next.next; else current = current.next; } return head; };",No,No,O(n),3
"const lengthOfLastWord = (s) => { const trimmed = s.trim(); return trimmed.length - trimmed.lastIndexOf(' ') - 1; };",No,No,O(n),3
"const plusOne = (digits) => { for (let i = digits.length - 1; i >= 0; i--) { if (digits[i] < 9) { digits[i]++; return digits; } digits[i] = 0; } digits.unshift(1); return digits; };",No,No,O(n),3
"const addBinary = (a, b) => { let result = '', carry = 0; let i = a.length - 1, j = b.length - 1; while (i >= 0 || j >= 0 || carry) { const sum = (i >= 0 ? +a[i--] : 0) + (j >= 0 ? +b[j--] : 0) + carry; carry = Math.floor(sum / 2); result = (sum % 2) + result; } return result; };",No,No,O(max(n, m)),3
"const mySqrt = (x) => { if (x === 0) return 0; let left = 1, right = Math.floor(x / 2) + 1; while (left <= right) { const mid = Math.floor((left + right) / 2); if (mid * mid === x) return mid; if (mid * mid < x) left = mid + 1; else right = mid - 1; } return right; };",No,No,O(log n),3
"const titleToNumber = (s) => { let result = 0; for (let i = 0; i < s.length; i++) result = result * 26 + (s.charCodeAt(i) - 'A'.charCodeAt(0) + 1); return result; };",No,No,O(n),3
"const convertToTitle = (n) => { let result = ''; while (n > 0) { n--; result = String.fromCharCode((n % 26) + 'A'.charCodeAt(0)) + result; n = Math.floor(n / 26); } return result; };",No,No,O(log n),3
"const isPalindrome = (s) => { let left = 0, right = s.length - 1; while (left < right) { while (left < right && !isAlphanumeric(s[left])) left++; while (left < right && !isAlphanumeric(s[right])) right--; if (s[left].toLowerCase() !== s[right].toLowerCase()) return false; left++; right--; } return true; }; const isAlphanumeric = (c) => /[a-z0-9]/i.test(c);",No,No,O(n),3
"const singleNumber = (nums) => nums.reduce((acc, num) => acc ^ num, 0);",No,No,O(n),3
"const hasCycle = (head) => { let slow = head, fast = head; while (fast && fast.next) { slow = slow.next; fast = fast.next.next; if (slow === fast) return true; } return false; };",No,No,O(n),3
"const intersect = (nums1, nums2) => { const map = new Map(), result = []; for (let num of nums1) map.set(num, (map.get(num) || 0) + 1); for (let num of nums2) { if (map.get(num)) { result.push(num); map.set(num, map.get(num) - 1); } } return result; };",No,No,O(n + m),3
"const isHappy = (n) => { const seen = new Set(); while (n !== 1 && !seen.has(n)) { seen.add(n); n = sumOfSquares(n); } return n === 1; }; const sumOfSquares = (n) => String(n).split('').reduce((acc, digit) => acc + digit ** 2, 0);",No,No,O(log n),3
"const reverseBits = (n) => { let result = 0; for (let i = 0; i < 32; i++) { result <<= 1; result |= n & 1; n >>>= 1; } return result >>> 0; };",No,No,O(1),3
"const hammingWeight = (n) => { let count = 0; while (n !== 0) { count += n & 1; n >>>= 1; } return count; };",No,No,O(1),3
"const rotate = (nums, k) => { k %= nums.length; nums.reverse(); reverse(nums, 0, k - 1); reverse(nums, k, nums.length - 1); }; const reverse = (nums, start, end) => { while (start < end) [nums[start++], nums[end--]] = [nums[end], nums[start]]; };",No,No,O(n),3
"const getIntersectionNode = (headA, headB) => { let a = headA, b = headB; while (a !== b) { a = a ? a.next : headB; b = b ? b.next : headA; } return a; };",No,No,O(n + m),3
"const isValidBST = (root, min = -Infinity, max = Infinity) => { if (!root) return true; if (root.val <= min || root.val >= max) return false; return isValidBST(root.left, min, root.val) && isValidBST(root.right, root.val, max); };",No,No,O(n),3
"const inorderTraversal = (root) => { const result = [], stack = []; let current = root; while (current || stack.length) { while (current) { stack.push(current); current = current.left; } current = stack.pop(); result.push(current.val); current = current.right; } return result; };",No,No,O(n),3
"const preorderTraversal = (root) => { const result = [], stack = [root]; while (stack.length) { const node = stack.pop(); if (node) { result.push(node.val); stack.push(node.right, node.left); } } return result; };",No,No,O(n),3
"const postorderTraversal = (root) => { const result = [], stack = [root]; const visited = new Set(); while (stack.length) { const node = stack[stack.length - 1]; if (!node) stack.pop(); else if (visited.has(node)) { result.push(node.val); stack.pop(); } else { visited.add(node); stack.push(node.right, node.left); } } return result; };",No,No,O(n),3
"const levelOrder = (root) => { if (!root) return []; const result = [], queue = [root]; while (queue.length) { const level = [], size = queue.length; for (let i = 0; i < size; i++) { const node = queue.shift(); level.push(node.val); if (node.left) queue.push(node.left); if (node.right) queue.push(node.right); } result.push(level); } return result; };",No,No,O(n),3
"const maxDepth = (root) => root ? Math.max(maxDepth(root.left), maxDepth(root.right)) + 1 : 0;",No,No,O(n),3
"const flatten = (root) => { if (!root) return; flatten(root.left); flatten(root.right); const temp = root.right; root.right = root.left; root.left = null; let current = root; while (current.right) current = current.right; current.right = temp; };",No,No,O(n),3
"const countBits = (n) => Array.from({ length: n + 1 }, (_, i) => i.toString(2).split('0').join('').length);",No,No,O(n),3
"const addDigits = (num) => (num - 1) % 9 + 1;",No,No,O(1),3
"const missingNumber = (nums) => { const n = nums.length; const sum = (n * (n + 1)) / 2; return sum - nums.reduce((acc, num) => acc + num, 0); };",No,No,O(n),3
"const findDuplicate = (nums) => { let slow = nums[0], fast = nums[0]; do { slow = nums[slow]; fast = nums[nums[fast]]; } while (slow !== fast); slow = nums[0]; while (slow !== fast) { slow = nums[slow]; fast = nums[fast]; } return slow; };",No,No,O(n),3
"const reverseList = (head) => { let prev = null, current = head; while (current) { const next = current.next; current.next = prev; prev = current; current = next; } return prev; };",No,No,O(n),3
"const mergeKLists = (lists) => { const mergeTwoLists = (l1, l2) => { if (!l1) return l2; if (!l2) return l1; if (l1.val < l2.val) { l1.next = mergeTwoLists(l1.next, l2); return l1; } else { l2.next = mergeTwoLists(l1, l2.next); return l2; } }; if (!lists.length) return null; while (lists.length > 1) { lists.push(mergeTwoLists(lists.shift(), lists.shift())); } return lists[0]; };",No,No,O(n log k),3
"const trap = (height) => { let left = 0, right = height.length - 1; let leftMax = 0, rightMax = 0; let totalWater = 0; while (left < right) { if (height[left] < height[right]) { height[left] >= leftMax ? leftMax = height[left] : totalWater += leftMax - height[left]; left++; } else { height[right] >= rightMax ? rightMax = height[right] : totalWater += rightMax - height[right]; right--; } } return totalWater; };",No,No,O(n),3
"const groupAnagrams = (strs) => { const map = new Map(); for (const str of strs) { const key = str.split('').sort().join(''); if (!map.has(key)) map.set(key, []); map.get(key).push(str); } return Array.from(map.values()); };",No,No,O(n k log k),3
"const minWindow = (s, t) => { const map = new Map(); for (const char of t) map.set(char, (map.get(char) || 0) + 1); let left = 0, right = 0, start = 0, minLen = Infinity, counter = t.length; while (right < s.length) { if (map.get(s[right]) > 0) counter--; map.set(s[right], (map.get(s[right]) || 0) - 1); right++; while (counter === 0) { if (right - left < minLen) { minLen = right - left; start = left; } map.set(s[left], (map.get(s[left]) || 0) + 1); if (map.get(s[left]) > 0) counter++; left++; } } return minLen === Infinity ? '' : s.substring(start, start + minLen); };",No,No,O(n),3
"const findAnagrams = (s, p) => { const result = []; const pCount = Array(26).fill(0), sCount = Array(26).fill(0); for (let i = 0; i < p.length; i++) { pCount[p.charCodeAt(i) - 'a'.charCodeAt(0)]++; sCount[s.charCodeAt(i) - 'a'.charCodeAt(0)]++; } for (let i = p.length; i < s.length; i++) { if (matches(pCount, sCount)) result.push(i - p.length); sCount[s.charCodeAt(i) - 'a'.charCodeAt(0)]++; sCount[s.charCodeAt(i - p.length) - 'a'.charCodeAt(0)]--; } if (matches(pCount, sCount)) result.push(s.length - p.length); return result; }; const matches = (pCount, sCount) => pCount.every((count, i) => count === sCount[i]);",No,No,O(n),3
"const canJump = (nums) => { let lastPos = nums.length - 1; for (let i = nums.length - 2; i >= 0; i--) { if (i + nums[i] >= lastPos) lastPos = i; } return lastPos === 0; };",No,No,O(n),3
"const maxProduct = (nums) => { let max = nums[0], min = nums[0], result = nums[0]; for (let i = 1; i < nums.length; i++) { if (nums[i] < 0) [max, min] = [min, max]; max = Math.max(nums[i], max * nums[i]); min = Math.min(nums[i], min * nums[i]); result = Math.max(result, max); } return result; };",No,No,O(n),3
"const rob = (nums) => { if (nums.length === 0) return 0; if (nums.length === 1) return nums[0]; let prev1 = 0, prev2 = 0; for (const num of nums) { const temp = prev1; prev1 = Math.max(prev1, prev2 + num); prev2 = temp; } return prev1; };",No,No,O(n),3
"const coinChange = (coins, amount) => { const dp = Array(amount + 1).fill(Infinity); dp[0] = 0; for (const coin of coins) { for (let i = coin; i <= amount; i++) dp[i] = Math.min(dp[i], dp[i - coin] + 1); } return dp[amount] === Infinity ? -1 : dp[amount]; };",No,No,O(n m),3
"const lengthOfLIS = (nums) => { const dp = Array(nums.length).fill(1); for (let i = 1; i < nums.length; i++) for (let j = 0; j < i; j++) if (nums[i] > nums[j]) dp[i] = Math.max(dp[i], dp[j] + 1); return Math.max(...dp); };",No,No,O(n^2),3
"const wordBreak = (s, wordDict) => { const dp = Array(s.length + 1).fill(false); dp[0] = true; for (let i = 1; i <= s.length; i++) for (const word of wordDict) if (i >= word.length && dp[i - word.length] && s.substring(i - word.length, i) === word) dp[i] = true; return dp[s.length]; };",No,No,O(n^2),3
"const minPathSum = (grid) => { const m = grid.length, n = grid[0].length; const dp = Array.from({ length: m }, () => Array(n).fill(0)); dp[0][0] = grid[0][0]; for (let i = 1; i < m; i++) dp[i][0] = dp[i - 1][0] + grid[i][0]; for (let j = 1; j < n; j++) dp[0][j] = dp[0][j - 1] + grid[0][j]; for (let i = 1; i < m; i++) for (let j = 1; j < n; j++) dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]; return dp[m - 1][n - 1]; };",No,No,O(m n),3
"const uniquePaths = (m, n) => { const dp = Array(m).fill().map(() => Array(n).fill(1)); for (let i = 1; i < m; i++) for (let j = 1; j < n; j++) dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; return dp[m - 1][n - 1]; };",No,No,O(m n),3
"const minDistance = (word1, word2) => { const dp = Array.from({ length: word1.length + 1 }, () => Array(word2.length + 1).fill(0)); for (let i = 0; i <= word1.length; i++) dp[i][0] = i; for (let j = 0; j <= word2.length; j++) dp[0][j] = j; for (let i = 1; i <= word1.length; i++) for (let j = 1; j <= word2.length; j++) if (word1[i - 1] === word2[j - 1]) dp[i][j] = dp[i - 1][j - 1]; else dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1; return dp[word1.length][word2.length]; };",No,No,O(n m),3
"const maximalSquare = (matrix) => { const m = matrix.length, n = matrix[0].length; const dp = Array.from({ length: m }, () => Array(n).fill(0)); let maxSquareLength = 0; for (let i = 0; i < m; i++) { for (let j = 0; j < n; j++) { if (matrix[i][j] === '1') { dp[i][j] = Math.min(dp[i - 1]?.[j], dp[i][j - 1], dp[i - 1]?.[j - 1]) + 1; maxSquareLength = Math.max(maxSquareLength, dp[i][j]); } } } return maxSquareLength ** 2; };",No,No,O(m n),3
"const maxProfit = (prices) => { let minPrice = Infinity, maxProfit = 0; for (const price of prices) { minPrice = Math.min(minPrice, price); maxProfit = Math.max(maxProfit, price - minPrice); } return maxProfit; };",No,No,O(n),3
"const jump = (nums) => { let jumps = 0, currentEnd = 0, farthest = 0; for (let i = 0; i < nums.length - 1; i++) { farthest = Math.max(farthest, i + nums[i]); if (i === currentEnd) { jumps++; currentEnd = farthest; } } return jumps; };",No,No,O(n),3
"const permute = (nums) => { const result = []; const backtrack = (path, used) => { if (path.length === nums.length) { result.push([...path]); return; } for (let i = 0; i < nums.length; i++) { if (used[i]) continue; used[i] = true; path.push(nums[i]); backtrack(path, used); path.pop(); used[i] = false; } }; backtrack([], Array(nums.length).fill(false)); return result; };",No,No,O(n!),3
"const mergeIntervals = (intervals) => { if (intervals.length === 0) return []; intervals.sort((a, b) => a[0] - b[0]); const merged = [intervals[0]]; for (let i = 1; i < intervals.length; i++) { if (intervals[i][0] <= merged[merged.length - 1][1]) merged[merged.length - 1][1] = Math.max(merged[merged.length - 1][1], intervals[i][1]); else merged.push(intervals[i]); } return merged; };",No,No,O(n log n),3
"const subsets = (nums) => { const result = [[]]; for (const num of nums) result.push(...result.map(subset => [...subset, num])); return result; };",No,No,O(n 2^n),3
"const letterCombinations = (digits) => { if (!digits.length) return []; const map = { '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz' }; const result = []; const backtrack = (index, path) => { if (path.length === digits.length) { result.push(path); return; } for (const char of map[digits[index]]) backtrack(index + 1, path + char); }; backtrack(0, ''); return result; };",No,No,O(4^n),3
"const rotate = (nums, k) => { k %= nums.length; reverse(nums, 0, nums.length - 1); reverse(nums, 0, k - 1); reverse(nums, k, nums.length - 1); }; const reverse = (arr, start, end) => { while (start < end) { [arr[start], arr[end]] = [arr[end], arr[start]]; start++; end--; } };",No,No,O(n),3
"const threeSum = (nums) => { const result = []; nums.sort((a, b) => a - b); for (let i = 0; i < nums.length - 2; i++) { if (i > 0 && nums[i] === nums[i - 1]) continue; let left = i + 1, right = nums.length - 1; while (left < right) { const sum = nums[i] + nums[left] + nums[right]; if (sum === 0) { result.push([nums[i], nums[left], nums[right]]); while (left < right && nums[left] === nums[left + 1]) left++; while (left < right && nums[right] === nums[right - 1]) right--; left++; right--; } else if (sum < 0) left++; else right--; } } return result; };",No,No,O(n^2),3
"const maxArea = (height) => { let left = 0, right = height.length - 1, maxArea = 0; while (left < right) { const area = Math.min(height[left], height[right]) * (right - left); maxArea = Math.max(maxArea, area); if (height[left] < height[right]) left++; else right--; } return maxArea; };",No,No,O(n),3
"const longestValidParentheses = (s) => { const stack = [-1]; let maxLength = 0; for (let i = 0; i < s.length; i++) { if (s[i] === '(') stack.push(i); else { stack.pop(); if (stack.length === 0) stack.push(i); else maxLength = Math.max(maxLength, i - stack[stack.length - 1]); } } return maxLength; };",No,No,O(n),3
"const validPalindrome = (s) => { const isPalindrome = (str) => str === str.split('').reverse().join(''); for (let i = 0; i < s.length; i++) { if (isPalindrome(s.slice(0, i) + s.slice(i + 1))) return true; } return false; };",No,No,O(n^2),3
"const minimumTotal = (triangle) => { for (let i = triangle.length - 2; i >= 0; i--) { for (let j = 0; j <= i; j++) { triangle[i][j] += Math.min(triangle[i + 1][j], triangle[i + 1][j + 1]); } } return triangle[0][0]; };",No,No,O(n^2),3
"const searchInsert = (nums, target) => { let left = 0, right = nums.length - 1; while (left <= right) { const mid = Math.floor((left + right) / 2); if (nums[mid] === target) return mid; if (nums[mid] < target) left = mid + 1; else right = mid - 1; } return left; };",No,No,O(log n),3
"const majorityElement = (nums) => { let count = 0, candidate; for (const num of nums) { if (count === 0) candidate = num; count += (num === candidate) ? 1 : -1; } return candidate; };",No,No,O(n),3
"const findDuplicate = (nums) => { let slow = nums[0], fast = nums[0]; do { slow = nums[slow]; fast = nums[nums[fast]]; } while (slow !== fast); let ptr1 = nums[0], ptr2 = slow; while (ptr1 !== ptr2) { ptr1 = nums[ptr1]; ptr2 = nums[ptr2]; } return ptr1; };",No,No,O(n),3
"const isValidSudoku = (board) => { const rows = Array(9).fill().map(() => new Set()), cols = Array(9).fill().map(() => new Set()), boxes = Array(9).fill().map(() => new Set()); for (let i = 0; i < 9; i++) { for (let j = 0; j < 9; j++) { const num = board[i][j]; if (num === '.') continue; const boxIndex = Math.floor(i / 3) * 3 + Math.floor(j / 3); if (rows[i].has(num) || cols[j].has(num) || boxes[boxIndex].has(num)) return false; rows[i].add(num); cols[j].add(num); boxes[boxIndex].add(num); } } return true; };",No,No,O(1),3
"const generateParenthesis = (n) => { const result = []; const backtrack = (left, right, current) => { if (current.length === 2 * n) { result.push(current); return; } if (left < n) backtrack(left + 1, right, current + '('); if (right < left) backtrack(left, right + 1, current + ')'); }; backtrack(0, 0, ''); return result; };",No,No,O(4^n/n^0.5),3
"const increaseTriplet = (nums) => { let first = Infinity, second = Infinity; for (const num of nums) { if (num <= first) first = num; else if (num <= second) second = num; else return true; } return false; };",No,No,O(n),3
"const partition = (s) => { const result = []; const backtrack = (start, path) => { if (start === s.length) { result.push(path); return; } for (let end = start + 1; end <= s.length; end++) { const substring = s.slice(start, end); if (isPalindrome(substring)) backtrack(end, [...path, substring]); } }; backtrack(0, []); return result; }; const isPalindrome = (str) => str === str.split('').reverse().join('');",No,No,O(n 2^n),3
"const numIslands = (grid) => { if (!grid.length) return 0; const dfs = (i, j) => { if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] === '0') return; grid[i][j] = '0'; dfs(i + 1, j); dfs(i - 1, j); dfs(i, j + 1); dfs(i, j - 1); }; let islands = 0; for (let i = 0; i < grid.length; i++) for (let j = 0; j < grid[0].length; j++) if (grid[i][j] === '1') { islands++; dfs(i, j); } return islands; };",No,No,O(m n),3
"const findKthLargest = (nums, k) => { const quickSelect = (left, right) => { const pivot = nums[Math.floor((left + right) / 2)]; const partition = (left, right) => { while (left <= right) { while (nums[left] > pivot) left++; while (nums[right] < pivot) right--; if (left <= right) [nums[left++], nums[right--]] = [nums[right], nums[left]]; } return left; }; const index = partition(left, right); if (k === index) return nums[k]; if (k < index) return quickSelect(left, index - 1); return quickSelect(index, right); }; return quickSelect(0, nums.length - 1); };",No,No,O(n),3
"const topKFrequent = (nums, k) => { const frequencyMap = new Map(); for (const num of nums) frequencyMap.set(num, (frequencyMap.get(num) || 0) + 1); const sorted = [...frequencyMap.entries()].sort((a, b) => b[1] - a[1]); return sorted.slice(0, k).map(([num]) => num); };",No,No,O(n log n),3
"const letterCasePermutation = (s) => { const result = []; const backtrack = (index, path) => { if (index === s.length) { result.push(path); return; } backtrack(index + 1, path + s[index]); if (isNaN(s[index])) backtrack(index + 1, path + s[index].toUpperCase()); }; backtrack(0, ''); return result; };",No,No,O(2^n),3
"const findMedianSortedArrays = (nums1, nums2) => { const merged = [...nums1, ...nums2].sort((a, b) => a - b); const mid = merged.length / 2; return merged.length % 2 === 0 ? (merged[mid - 1] + merged[mid]) / 2 : merged[Math.floor(mid)]; };",No,No,O((m+n) log(m+n)),3
"const uniquePaths = (m, n) => { const dp = Array(m).fill().map(() => Array(n).fill(1)); for (let i = 1; i < m; i++) for (let j = 1; j < n; j++) dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; return dp[m - 1][n - 1]; };",No,No,O(m n),3
"const climbingStairs = (n) => { if (n <= 1) return 1; const dp = Array(n + 1).fill(0); dp[0] = 1; dp[1] = 1; for (let i = 2; i <= n; i++) dp[i] = dp[i - 1] + dp[i - 2]; return dp[n]; };",No,No,O(n),3
"const productExceptSelf = (nums) => { const result = Array(nums.length).fill(1); let left = 1, right = 1; for (let i = 0; i < nums.length; i++) { result[i] *= left; left *= nums[i]; } for (let i = nums.length - 1; i >= 0; i--) { result[i] *= right; right *= nums[i]; } return result; };",No,No,O(n),3
"const numberOfIslands = (grid) => { if (!grid.length) return 0; const dfs = (i, j) => { if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] === '0') return; grid[i][j] = '0'; dfs(i + 1, j); dfs(i - 1, j); dfs(i, j + 1); dfs(i, j - 1); }; let count = 0; for (let i = 0; i < grid.length; i++) { for (let j = 0; j < grid[0].length; j++) { if (grid[i][j] === '1') { count++; dfs(i, j); } } } return count; };",No,No,O(m*n),3
"const search = (nums, target) => { let left = 0, right = nums.length - 1; while (left <= right) { const mid = Math.floor((left + right) / 2); if (nums[mid] === target) return mid; if (nums[mid] < target) left = mid + 1; else right = mid - 1; } return -1; };",No,No,O(log n),3
"const longestSubstring = (s, k) => { let left = 0, right = 0, maxLength = 0; const countMap = new Map(); while (right < s.length) { countMap.set(s[right], (countMap.get(s[right]) || 0) + 1); while (countMap.size > k) { countMap.set(s[left], countMap.get(s[left]) - 1); if (countMap.get(s[left]) === 0) countMap.delete(s[left]); left++; } maxLength = Math.max(maxLength, right - left + 1); right++; } return maxLength; };",No,No,O(n),3
"const countAndSay = (n) => { if (n === 1) return '1'; let prev = countAndSay(n - 1); let result = ''; let count = 1; for (let i = 1; i < prev.length; i++) { if (prev[i] === prev[i - 1]) count++; else { result += count + prev[i - 1]; count = 1; } } return result + count + prev[prev.length - 1]; };",No,No,O(2^n),3
"const jump = (nums) => { let jumps = 0, currentEnd = 0, farthest = 0; for (let i = 0; i < nums.length - 1; i++) { farthest = Math.max(farthest, i + nums[i]); if (i === currentEnd) { jumps++; currentEnd = farthest; } } return jumps; };",No,No,O(n),3
"const maxProduct = (nums) => { let maxProd = nums[0], minProd = nums[0], result = nums[0]; for (let i = 1; i < nums.length; i++) { if (nums[i] < 0) [maxProd, minProd] = [minProd, maxProd]; maxProd = Math.max(nums[i], maxProd * nums[i]); minProd = Math.min(nums[i], minProd * nums[i]); result = Math.max(result, maxProd); } return result; };",No,No,O(n),3
"const longestCommonPrefix = (strs) => { if (!strs.length) return ''; let prefix = strs[0]; for (let i = 1; i < strs.length; i++) { while (strs[i].indexOf(prefix) !== 0) { prefix = prefix.slice(0, -1); } } return prefix; };",No,No,O(n*m),3
"const reverseString = (s) => { let left = 0, right = s.length - 1; while (left < right) { [s[left], s[right]] = [s[right], s[left]]; left++; right--; } return s; };",No,No,O(n),3
"const containsDuplicate = (nums) => { const numSet = new Set(); for (const num of nums) { if (numSet.has(num)) return true; numSet.add(num); } return false; };",No,No,O(n),3
"const singleNumber = (nums) => { return nums.reduce((acc, num) => acc ^ num, 0); };",No,No,O(n),3
"const twoSum = (nums, target) => { const numMap = new Map(); for (let i = 0; i < nums.length; i++) { const complement = target - nums[i]; if (numMap.has(complement)) return [numMap.get(complement), i]; numMap.set(nums[i], i); } return []; };",No,No,O(n),3
"const longestSubstringWithoutRepeating = (s) => { const charIndexMap = new Map(); let maxLength = 0, start = 0; for (let i = 0; i < s.length; i++) { if (charIndexMap.has(s[i]) && charIndexMap.get(s[i]) >= start) start = charIndexMap.get(s[i]) + 1; charIndexMap.set(s[i], i); maxLength = Math.max(maxLength, i - start + 1); } return maxLength; };",No,No,O(n),3
"const isAnagram = (s, t) => { if (s.length !== t.length) return false; const count = new Array(26).fill(0); for (let i = 0; i < s.length; i++) { count[s.charCodeAt(i) - 97]++; count[t.charCodeAt(i) - 97]--; } return count.every(val => val === 0); };",No,No,O(n),3
"const searchMatrix = (matrix, target) => { if (!matrix.length || !matrix[0].length) return false; let row = 0, col = matrix[0].length - 1; while (row < matrix.length && col >= 0) { const current = matrix[row][col]; if (current === target) return true; if (current > target) col--; else row++; } return false; };",No,No,O(m+n),3
"const validParentheses = (s) => { const stack = []; const map = { '(': ')', '{': '}', '[': ']' }; for (const char of s) { if (map[char]) stack.push(map[char]); else if (stack.pop() !== char) return false; } return stack.length === 0; };",No,No,O(n),3
"const permutations = (nums) => { const result = []; const backtrack = (path) => { if (path.length === nums.length) result.push(path); for (const num of nums) { if (!path.includes(num)) backtrack([...path, num]); } }; backtrack([]); return result; };",No,No,O(n!),3
"const rotateArray = (nums, k) => { k %= nums.length; reverse(nums, 0, nums.length - 1); reverse(nums, 0, k - 1); reverse(nums, k, nums.length - 1); }; const reverse = (arr, start, end) => { while (start < end) { [arr[start], arr[end]] = [arr[end], arr[start]]; start++; end--; } };",No,No,O(n),3
"const removeDuplicates = (nums) => { let i = 0; for (let j = 1; j < nums.length; j++) { if (nums[j] !== nums[i]) nums[++i] = nums[j]; } return i + 1; };",No,No,O(n),3
"const isPalindromeNumber = (x) => { if (x < 0 || (x % 10 === 0 && x !== 0)) return false; let reversed = 0; while (x > reversed) { reversed = reversed * 10 + x % 10; x = Math.floor(x / 10); } return x === reversed || x === Math.floor(reversed / 10); };",No,No,O(log n),3
"const mergeSortedArray = (nums1, m, nums2, n) => { let i = m + n - 1; while (m > 0 && n > 0) { if (nums1[m - 1] > nums2[n - 1]) { nums1[i] = nums1[m - 1]; m--; } else { nums1[i] = nums2[n - 1]; n--; } i--; } while (n > 0) { nums1[i] = nums2[n - 1]; n--; i--; } };",No,No,O(m+n),3
"const combinationSum = (candidates, target) => { const result = []; const backtrack = (start, path, remaining) => { if (remaining === 0) result.push(path); for (let i = start; i < candidates.length; i++) { if (remaining >= candidates[i]) backtrack(i, [...path, candidates[i]], remaining - candidates[i]); } }; backtrack(0, [], target); return result; };",No,No,O(2^n),3
"const removeElement = (nums, val) => { let k = 0; for (let i = 0; i < nums.length; i++) { if (nums[i] !== val) nums[k++] = nums[i]; } return k; };",No,No,O(n),3
"const isSubsequence = (s, t) => { let sIndex = 0; for (let tIndex = 0; tIndex < t.length; tIndex++) { if (s[sIndex] === t[tIndex]) sIndex++; if (sIndex === s.length) return true; } return sIndex === s.length; };",No,No,O(n),3
"const validMountainArray = (arr) => { let i = 0; while (i < arr.length - 1 && arr[i] < arr[i + 1]) i++; if (i === 0 || i === arr.length - 1) return false; while (i < arr.length - 1 && arr[i] > arr[i + 1]) i++; return i === arr.length - 1; };",No,No,O(n),3
"const longestValidParentheses = (s) => { const stack = [-1]; let maxLength = 0; for (let i = 0; i < s.length; i++) { if (s[i] === '(') stack.push(i); else { stack.pop(); if (stack.length === 0) stack.push(i); else maxLength = Math.max(maxLength, i - stack[stack.length - 1]); } } return maxLength; };",No,No,O(n),3
"const findTargetSumWays = (nums, target) => { const memo = {}; const backtrack = (index, total) => { if (index === nums.length) return total === target ? 1 : 0; const key = index + ',' + total; if (key in memo) return memo[key]; memo[key] = backtrack(index + 1, total + nums[index]) + backtrack(index + 1, total - nums[index]); return memo[key]; }; return backtrack(0, 0); };",No,No,O(2^n),3
"const searchInsert = (nums, target) => { let left = 0, right = nums.length - 1; while (left <= right) { const mid = Math.floor((left + right) / 2); if (nums[mid] === target) return mid; if (nums[mid] < target) left = mid + 1; else right = mid - 1; } return left; };",No,No,O(log n),3
"const partitionLabels = (s) => { const lastIndex = {}; for (let i = 0; i < s.length; i++) lastIndex[s[i]] = i; const result = []; let j = 0, anchor = 0; for (let i = 0; i < s.length; i++) { j = Math.max(j, lastIndex[s[i]]); if (i === j) { result.push(i - anchor + 1); anchor = i + 1; } } return result; };",No,No,O(n),3
"const restoreIpAddresses = (s) => { const result = []; const backtrack = (start, path) => { if (path.length === 4 && start === s.length) result.push(path.join('.')); if (path.length > 4) return; for (let len = 1; len <= 3; len++) { const segment = s.slice(start, start + len); if (parseInt(segment) <= 255 && (segment[0] !== '0' || segment.length === 1)) backtrack(start + len, [...path, segment]); } }; backtrack(0, []); return result; };",No,No,O(2^n),3
"const topKFrequent = (nums, k) => { const count = {}; nums.forEach(num => count[num] = (count[num] || 0) + 1); return Object.entries(count).sort((a, b) => b[1] - a[1]).slice(0, k).map(entry => parseInt(entry[0])); };",No,No,O(n log n),3
"const permuteUnique = (nums) => { const result = []; nums.sort((a, b) => a - b); const backtrack = (path, used) => { if (path.length === nums.length) result.push([...path]); for (let i = 0; i < nums.length; i++) { if (used[i] || (i > 0 && nums[i] === nums[i - 1] && !used[i - 1])) continue; used[i] = true; path.push(nums[i]); backtrack(path, used); path.pop(); used[i] = false; } }; backtrack([], new Array(nums.length).fill(false)); return result; };",No,No,O(n!),3
"const generateParenthesis = (n) => { const result = []; const backtrack = (left, right, path) => { if (left === 0 && right === 0) result.push(path); if (left > 0) backtrack(left - 1, right, path + '('); if (right > left) backtrack(left, right - 1, path + ')'); }; backtrack(n, n, ''); return result; };",No,No,O(2^n),3
"const longestPalindrome = (s) => { const expandAroundCenter = (left, right) => { while (left >= 0 && right < s.length && s[left] === s[right]) { left--; right++; } return right - left - 1; }; let maxLength = 0; for (let i = 0; i < s.length; i++) { maxLength = Math.max(maxLength, Math.max(expandAroundCenter(i, i), expandAroundCenter(i, i + 1))); } return maxLength; };",No,No,O(n^2),3
"const groupAnagrams = (strs) => { const anagrams = {}; for (const str of strs) { const key = str.split('').sort().join(''); if (!anagrams[key]) anagrams[key] = []; anagrams[key].push(str); } return Object.values(anagrams); };",No,No,O(n*m log m),3
"const sumNumbers = (root) => { const dfs = (node, currentSum) => { if (!node) return 0; currentSum = currentSum * 10 + node.val; if (!node.left && !node.right) return currentSum; return dfs(node.left, currentSum) + dfs(node.right, currentSum); }; return dfs(root, 0); };",No,No,O(n),3
"const diameterOfBinaryTree = (root) => { let maxDiameter = 0; const dfs = (node) => { if (!node) return 0; const left = dfs(node.left); const right = dfs(node.right); maxDiameter = Math.max(maxDiameter, left + right); return Math.max(left, right) + 1; }; dfs(root); return maxDiameter; };",No,No,O(n),3
"const minimumDepthOfBinaryTree = (root) => { if (!root) return 0; if (!root.left && !root.right) return 1; if (!root.left) return minimumDepthOfBinaryTree(root.right) + 1; if (!root.right) return minimumDepthOfBinaryTree(root.left) + 1; return Math.min(minimumDepthOfBinaryTree(root.left), minimumDepthOfBinaryTree(root.right)) + 1; };",No,No,O(n),3
"const pathSum = (root, sum) => { const dfs = (node, currentSum) => { if (!node) return 0; currentSum += node.val; if (!node.left && !node.right) return currentSum === sum ? 1 : 0; return dfs(node.left, currentSum) + dfs(node.right, currentSum); }; return dfs(root, 0); };",No,No,O(n),3
"const levelOrder = (root) => { const result = []; const traverse = (node, depth) => { if (!node) return; if (!result[depth]) result[depth] = []; result[depth].push(node.val); traverse(node.left, depth + 1); traverse(node.right, depth + 1); }; traverse(root, 0); return result; };",No,No,O(n),3
"const isSameTree = (p, q) => { if (!p && !q) return true; if (!p || !q) return false; return p.val === q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right); };",No,No,O(n),3
"const invertTree = (root) => { if (!root) return null; const left = invertTree(root.left); const right = invertTree(root.right); root.left = right; root.right = left; return root; };",No,No,O(n),3
"const maxDepth = (root) => { if (!root) return 0; return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1; };",No,No,O(n),3
"const mergeTwoLists = (l1, l2) => { const dummy = new ListNode(0); let current = dummy; while (l1 && l2) { if (l1.val < l2.val) { current.next = l1; l1 = l1.next; } else { current.next = l2; l2 = l2.next; } current = current.next; } current.next = l1 || l2; return dummy.next; };",No,No,O(n+m),3
"const removeNthFromEnd = (head, n) => { const dummy = new ListNode(0, head); let first = dummy, second = dummy; for (let i = 0; i <= n; i++) first = first.next; while (first) { first = first.next; second = second.next; } second.next = second.next.next; return dummy.next; };",No,No,O(n),3
"const reverseKGroup = (head, k) => { let count = 0, current = head; while (current && count !== k) { current = current.next; count++; } if (count === k) { current = reverseKGroup(current, k); while (count--) { const temp = head.next; head.next = current; current = head; head = temp; } head = current; } return head; };",No,No,O(n),3
"const swapPairs = (head) => { if (!head || !head.next) return head; const newHead = head.next; head.next = swapPairs(newHead.next); newHead.next = head; return newHead; };",No,No,O(n),3
"const hasCycle = (head) => { let slow = head, fast = head; while (fast && fast.next) { slow = slow.next; fast = fast.next.next; if (slow === fast) return true; } return false; };",No,No,O(n),3
"const flatten = (root) => { if (!root) return; flatten(root.left); flatten(root.right); root.right = lastVisited; root.left = null; lastVisited = root; }; let lastVisited = null; flatten(root);",No,No,O(n),3
"const isSymmetric = (root) => { const check = (left, right) => { if (!left && !right) return true; if (!left || !right) return false; return left.val === right.val && check(left.left, right.right) && check(left.right, right.left); }; return check(root, root); };",No,No,O(n),3
"const findMode = (root) => { const count = {}, maxCount = [0], result = []; const traverse = (node) => { if (!node) return; count[node.val] = (count[node.val] || 0) + 1; if (count[node.val] > maxCount[0]) { maxCount[0] = count[node.val]; result.length = 0; result.push(node.val); } else if (count[node.val] === maxCount[0]) result.push(node.val); traverse(node.left); traverse(node.right); }; traverse(root); return result; };",No,No,O(n),3
"const kthLargest = (root, k) => { const stack = []; let current = root; while (true) { while (current) { stack.push(current); current = current.right; } current = stack.pop(); if (--k === 0) return current.val; current = current.left; } };",No,No,O(n),3
"const maxPathSum = (root) => { let maxSum = -Infinity; const dfs = (node) => { if (!node) return 0; const left = Math.max(dfs(node.left), 0); const right = Math.max(dfs(node.right), 0); maxSum = Math.max(maxSum, left + right + node.val); return Math.max(left, right) + node.val; }; dfs(root); return maxSum; };",No,No,O(n),3
"const countNodes = (root) => { if (!root) return 0; return 1 + countNodes(root.left) + countNodes(root.right); };",No,No,O(n),3
"const connect = (root) => { if (!root) return; const queue = [root]; while (queue.length) { const size = queue.length; for (let i = 0; i < size; i++) { const node = queue.shift(); if (i < size - 1) node.next = queue[0]; if (node.left) queue.push(node.left); if (node.right) queue.push(node.right); } } };",No,No,O(n),3
"const serialize = (root) => { const result = []; const traverse = (node) => { if (!node) { result.push(null); return; } result.push(node.val); traverse(node.left); traverse(node.right); }; traverse(root); return result; };",No,No,O(n),3
"const deserialize = (data) => { const buildTree = (nodes) => { if (nodes[0] === null) { nodes.shift(); return null; } const node = new TreeNode(nodes.shift()); node.left = buildTree(nodes); node.right = buildTree(nodes); return node; }; return buildTree(data); };",No,No,O(n),3
"const minDepth = (root) => { if (!root) return 0; if (!root.left && !root.right) return 1; if (!root.left) return minDepth(root.right) + 1; if (!root.right) return minDepth(root.left) + 1; return Math.min(minDepth(root.left), minDepth(root.right)) + 1; };",No,No,O(n),3
"const pathSum = (root, sum) => { const dfs = (node, currentSum) => { if (!node) return 0; currentSum += node.val; if (!node.left && !node.right) return currentSum === sum ? 1 : 0; return dfs(node.left, currentSum) + dfs(node.right, currentSum); }; return dfs(root, 0); };",No,No,O(n),3
"const isBalanced = (root) => { const check = (node) => { if (!node) return 0; const left = check(node.left); const right = check(node.right); return left === -1 || right === -1 || Math.abs(left - right) > 1 ? -1 : Math.max(left, right) + 1; }; return check(root) !== -1; };",No,No,O(n),3
"const averageOfLevels = (root) => { const result = []; const queue = [root]; while (queue.length) { const size = queue.length; let sum = 0; for (let i = 0; i < size; i++) { const node = queue.shift(); sum += node.val; if (node.left) queue.push(node.left); if (node.right) queue.push(node.right); } result.push(sum / size); } return result; };",No,No,O(n),3
"const convertBST = (root) => { let sum = 0; const traverse = (node) => { if (!node) return; traverse(node.right); sum += node.val; node.val = sum; traverse(node.left); }; traverse(root); return root; };",No,No,O(n),3
"const sumOfLeftLeaves = (root) => { if (!root) return 0; if (root.left && !root.left.left && !root.left.right) return root.left.val + sumOfLeftLeaves(root.right); return sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right); };",No,No,O(n),3
"const countUnivalSubtrees = (root) => { let count = 0; const check = (node) => { if (!node) return true; const left = check(node.left); const right = check(node.right); if (left && right) count++; return node.val === (node.left ? node.left.val : null) && node.val === (node.right ? node.right.val : null); }; check(root); return count; };",No,No,O(n),3
"const diameterOfBinaryTree = (root) => { let maxDiameter = 0; const dfs = (node) => { if (!node) return 0; const left = dfs(node.left); const right = dfs(node.right); maxDiameter = Math.max(maxDiameter, left + right); return Math.max(left, right) + 1; }; dfs(root); return maxDiameter; };",No,No,O(n),3
"const binaryTreePaths = (root) => { const paths = []; const dfs = (node, path) => { if (!node) return; path.push(node.val); if (!node.left && !node.right) paths.push(path.join('->')); dfs(node.left, path); dfs(node.right, path); path.pop(); }; dfs(root, []); return paths; };",No,No,O(n),3
"const findBottomLeftValue = (root) => { const queue = [root]; let bottomLeftValue; while (queue.length) { const size = queue.length; for (let i = 0; i < size; i++) { const node = queue.shift(); if (i === 0) bottomLeftValue = node.val; if (node.left) queue.push(node.left); if (node.right) queue.push(node.right); } } return bottomLeftValue; };",No,No,O(n),3
"const rightSideView = (root) => { const result = []; const traverse = (node, depth) => { if (!node) return; if (depth === result.length) result.push(node.val); traverse(node.right, depth + 1); traverse(node.left, depth + 1); }; traverse(root, 0); return result; };",No,No,O(n),3
"const binaryTreeTilt = (root) => { let tilt = 0; const dfs = (node) => { if (!node) return 0; const left = dfs(node.left); const right = dfs(node.right); tilt += Math.abs(left - right); return left + right + node.val; }; dfs(root); return tilt; };",No,No,O(n),3
"const minCameraCover = (root) => { let cameras = 0; const dfs = (node) => { if (!node) return 1; const left = dfs(node.left); const right = dfs(node.right); if (left === 0 || right === 0) { cameras++; return -1; } return left === -1 || right === -1 ? 1 : 0; }; return dfs(root) < 0 ? cameras + 1 : cameras; };",No,No,O(n),3
"const longestUnivaluePath = (root) => { let maxLength = 0; const dfs = (node) => { if (!node) return 0; const left = dfs(node.left); const right = dfs(node.right); let leftLength = node.left && node.left.val === node.val ? left + 1 : 0; let rightLength = node.right && node.right.val === node.val ? right + 1 : 0; maxLength = Math.max(maxLength, leftLength + rightLength); return Math.max(leftLength, rightLength); }; dfs(root); return maxLength; };",No,No,O(n),3
"const canPartition = (nums) => { const sum = nums.reduce((a, b) => a + b, 0); if (sum % 2 !== 0) return false; const target = sum / 2; const dp = new Array(target + 1).fill(false); dp[0] = true; for (const num of nums) { for (let j = target; j >= num; j--) { dp[j] = dp[j] || dp[j - num]; } } return dp[target]; };",No,No,O(n * target),3
"const lengthOfLIS = (nums) => { const dp = []; for (const num of nums) { let left = 0, right = dp.length; while (left < right) { const mid = Math.floor((left + right) / 2); if (dp[mid] < num) left = mid + 1; else right = mid; } dp[left] = num; } return dp.length; };",No,No,O(n log n),3
"const jump = (nums) => { let jumps = 0, currentEnd = 0, farthest = 0; for (let i = 0; i < nums.length - 1; i++) { farthest = Math.max(farthest, i + nums[i]); if (i === currentEnd) { jumps++; currentEnd = farthest; } } return jumps; };",No,No,O(n),3
"const partitionLabels = (s) => { const lastOccurrence = {}; for (let i = 0; i < s.length; i++) lastOccurrence[s[i]] = i; const result = []; let anchor = 0, maxIndex = 0; for (let i = 0; i < s.length; i++) { maxIndex = Math.max(maxIndex, lastOccurrence[s[i]]); if (i === maxIndex) { result.push(i - anchor + 1); anchor = i + 1; } } return result; };",No,No,O(n),3
"const subarraySum = (nums, k) => { const count = new Map(); count.set(0, 1); let sum = 0, result = 0; for (const num of nums) { sum += num; result += count.get(sum - k) || 0; count.set(sum, (count.get(sum) || 0) + 1); } return result; };",No,No,O(n),3
"const findMaxAverage = (nums, k) => { let sum = 0; for (let i = 0; i < k; i++) sum += nums[i]; let maxSum = sum; for (let i = k; i < nums.length; i++) { sum += nums[i] - nums[i - k]; maxSum = Math.max(maxSum, sum); } return maxSum / k; };",No,No,O(n),3
"const longestSubstring = (s, k) => { let left = 0, right = 0, maxLength = 0; const count = {}; while (right < s.length) { count[s[right]] = (count[s[right]] || 0) + 1; while (Object.keys(count).length > k) { count[s[left]]--; if (count[s[left]] === 0) delete count[s[left]]; left++; } maxLength = Math.max(maxLength, right - left + 1); right++; } return maxLength; };",No,No,O(n),3
"const threeSum = (nums) => { nums.sort((a, b) => a - b); const result = []; for (let i = 0; i < nums.length; i++) { if (i > 0 && nums[i] === nums[i - 1]) continue; let left = i + 1, right = nums.length - 1; while (left < right) { const sum = nums[i] + nums[left] + nums[right]; if (sum === 0) { result.push([nums[i], nums[left], nums[right]]); while (nums[left] === nums[left + 1]) left++; while (nums[right] === nums[right - 1]) right--; left++; right--; } else if (sum < 0) left++; else right--; } } return result; };",No,No,O(n^2),3
"const validAnagram = (s, t) => { if (s.length !== t.length) return false; const count = {}; for (const char of s) count[char] = (count[char] || 0) + 1; for (const char of t) { if (!count[char]) return false; count[char]--; if (count[char] < 0) return false; } return true; };",No,No,O(n),3
"const searchRange = (nums, target) => { const findIndex = (isLeft) => { let left = 0, right = nums.length - 1, index = -1; while (left <= right) { const mid = Math.floor((left + right) / 2); if (nums[mid] === target) { index = mid; isLeft ? right = mid - 1 : left = mid + 1; } else if (nums[mid] < target) left = mid + 1; else right = mid - 1; } return index; }; return [findIndex(true), findIndex(false)]; };",No,No,O(log n),3
"const maxProfit = (prices) => { let maxProfit = 0; for (let i = 1; i < prices.length; i++) { if (prices[i] > prices[i - 1]) maxProfit += prices[i] - prices[i - 1]; } return maxProfit; };",No,No,O(n),3
"const isPalindrome = (s) => { const cleaned = s.replace(/[^a-z0-9]/gi, '').toLowerCase(); return cleaned === cleaned.split('').reverse().join(''); };",No,No,O(n),3
"const generateParenthesis = (n) => { const result = []; const backtrack = (left, right, current) => { if (left === n && right === n) { result.push(current); return; } if (left < n) backtrack(left + 1, right, current + '('); if (right < left) backtrack(left, right + 1, current + ')'); }; backtrack(0, 0, ''); return result; };",No,No,O(2^n),3
"const simplifyPath = (path) => { const stack = []; for (const part of path.split('/')) { if (part === '' || part === '.') continue; if (part === '..') stack.pop(); else stack.push(part); } return '/' + stack.join('/'); };",No,No,O(n),3
"const mergeIntervals = (intervals) => { if (intervals.length === 0) return []; intervals.sort((a, b) => a[0] - b[0]); const merged = [intervals[0]]; for (let i = 1; i < intervals.length; i++) { const current = intervals[i]; const lastMerged = merged[merged.length - 1]; if (current[0] <= lastMerged[1]) lastMerged[1] = Math.max(lastMerged[1], current[1]); else merged.push(current); } return merged; };",No,No,O(n log n),3
"const twoSum = (nums, target) => { const map = new Map(); for (let i = 0; i < nums.length; i++) { const complement = target - nums[i]; if (map.has(complement)) return [map.get(complement), i]; map.set(nums[i], i); } return []; };",No,No,O(n),3
"const lengthOfLastWord = (s) => { const words = s.trim().split(' '); return words.length === 0 ? 0 : words[words.length - 1].length; };",No,No,O(n),3
"const firstUniqChar = (s) => { const count = {}; for (const char of s) count[char] = (count[char] || 0) + 1; for (let i = 0; i < s.length; i++) { if (count[s[i]] === 1) return i; } return -1; };",No,No,O(n),3
"const maxArea = (height) => { let left = 0, right = height.length - 1, maxArea = 0; while (left < right) { const area = Math.min(height[left], height[right]) * (right - left); maxArea = Math.max(maxArea, area); if (height[left] < height[right]) left++; else right--; } return maxArea; };",No,No,O(n),3
"const trap = (height) => { const n = height.length; if (n === 0) return 0; const leftMax = new Array(n).fill(0); const rightMax = new Array(n).fill(0); leftMax[0] = height[0]; rightMax[n - 1] = height[n - 1]; for (let i = 1; i < n; i++) leftMax[i] = Math.max(leftMax[i - 1], height[i]); for (let i = n - 2; i >= 0; i--) rightMax[i] = Math.max(rightMax[i + 1], height[i]); let waterTrapped = 0; for (let i = 0; i < n; i++) waterTrapped += Math.min(leftMax[i], rightMax[i]) - height[i]; return waterTrapped; };",No,No,O(n),3
"const groupAnagrams = (strs) => { const map = {}; for (const str of strs) { const key = str.split('').sort().join(''); if (!map[key]) map[key] = []; map[key].push(str); } return Object.values(map); };",No,No,O(n k log k),3
"const longestCommonPrefix = (strs) => { if (strs.length === 0) return ''; let prefix = strs[0]; for (let i = 1; i < strs.length; i++) { while (strs[i].indexOf(prefix) !== 0) { prefix = prefix.slice(0, -1); if (prefix === '') return ''; } } return prefix; };",No,No,O(n*m),3
"const isValid = (s) => { const stack = []; const map = { '(': ')', '{': '}', '[': ']' }; for (const char of s) { if (map[char]) stack.push(map[char]); else if (stack.length === 0 || stack.pop() !== char) return false; } return stack.length === 0; };",No,No,O(n),3
"const countBits = (n) => { const result = []; for (let i = 0; i <= n; i++) result.push(i.toString(2).split(' ').join('').length); return result; };",No,No,O(n),3
"const lengthOfLIS = (nums) => { const dp = []; for (const num of nums) { const index = dp.findIndex((n) => n >= num); if (index === -1) dp.push(num); else dp[index] = num; } return dp.length; };",No,No,O(n log n),3
"const findDuplicate = (nums) => { const seen = new Set(); for (const num of nums) { if (seen.has(num)) return num; seen.add(num); } return -1; };",No,No,O(n),3
"const longestIncreasingSubsequence = (nums) => { const dp = Array(nums.length).fill(1); for (let i = 1; i < nums.length; i++) { for (let j = 0; j < i; j++) { if (nums[i] > nums[j]) dp[i] = Math.max(dp[i], dp[j] + 1); } } return Math.max(...dp); };",No,No,O(n^2),3
"const productExceptSelf = (nums) => { const length = nums.length; const output = Array(length).fill(1); let leftProduct = 1; for (let i = 0; i < length; i++) { output[i] = leftProduct; leftProduct *= nums[i]; } let rightProduct = 1; for (let i = length - 1; i >= 0; i--) { output[i] *= rightProduct; rightProduct *= nums[i]; } return output; };",No,No,O(n),3
"const searchInsert = (nums, target) => { let left = 0, right = nums.length - 1; while (left <= right) { const mid = Math.floor((left + right) / 2); if (nums[mid] === target) return mid; if (nums[mid] < target) left = mid + 1; else right = mid - 1; } return left; };",No,No,O(log n),3
"const maxSubArray = (nums) => { let maxSum = nums[0], currentSum = nums[0]; for (let i = 1; i < nums.length; i++) { currentSum = Math.max(nums[i], currentSum + nums[i]); maxSum = Math.max(maxSum, currentSum); } return maxSum; };",No,No,O(n),3
"const findKthLargest = (nums, k) => { nums.sort((a, b) => b - a); return nums[k - 1]; };",No,No,O(n log n),3
"const combine = (n, k) => { const result = []; const backtrack = (start, current) => { if (current.length === k) { result.push([...current]); return; } for (let i = start; i <= n; i++) { current.push(i); backtrack(i + 1, current); current.pop(); } }; backtrack(1, []); return result; };",No,No,O(C(n, k)),3
"const minimumPathSum = (grid) => { const m = grid.length, n = grid[0].length; for (let i = 1; i < m; i++) grid[i][0] += grid[i - 1][0]; for (let j = 1; j < n; j++) grid[0][j] += grid[0][j - 1]; for (let i = 1; i < m; i++) { for (let j = 1; j < n; j++) { grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]); } } return grid[m - 1][n - 1]; };",No,No,O(m*n),3
"const largestRectangleArea = (heights) => { const stack = [], n = heights.length; let maxArea = 0; for (let i = 0; i <= n; i++) { const h = i === n ? 0 : heights[i]; while (stack.length && heights[stack[stack.length - 1]] > h) { const height = heights[stack.pop()]; const width = stack.length === 0 ? i : i - stack[stack.length - 1] - 1; maxArea = Math.max(maxArea, height * width); } stack.push(i); } return maxArea; };",No,No,O(n),3
"const climbStairs = (n) => { if (n <= 2) return n; let first = 1, second = 2; for (let i = 3; i <= n; i++) { [first, second] = [second, first + second]; } return second; };",No,No,O(n),3
"const rotate = (nums, k) => { k %= nums.length; const reverse = (arr, start, end) => { while (start < end) { [arr[start], arr[end]] = [arr[end], arr[start]]; start++; end--; } }; reverse(nums, 0, nums.length - 1); reverse(nums, 0, k - 1); reverse(nums, k, nums.length - 1); };",No,No,O(n),3
"const numIslands = (grid) => { if (grid.length === 0) return 0; let count = 0; const dfs = (i, j) => { if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] === '0') return; grid[i][j] = '0'; dfs(i - 1, j); dfs(i + 1, j); dfs(i, j - 1); dfs(i, j + 1); }; for (let i = 0; i < grid.length; i++) { for (let j = 0; j < grid[0].length; j++) { if (grid[i][j] === '1') { count++; dfs(i, j); } } } return count; };",No,No,O(m*n),3
"const canJump = (nums) => { let maxReach = 0; for (let i = 0; i < nums.length; i++) { if (i > maxReach) return false; maxReach = Math.max(maxReach, i + nums[i]); } return true; };",No,No,O(n),3
"const generate = (numRows) => { const result = []; for (let i = 0; i < numRows; i++) { const row = Array(i + 1).fill(1); for (let j = 1; j < i; j++) row[j] = result[i - 1][j - 1] + result[i - 1][j]; result.push(row); } return result; };",No,No,O(numRows^2),3
"const letterCombinations = (digits) => { const map = { '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz' }; const result = []; const backtrack = (index, current) => { if (current.length === digits.length) { result.push(current.join('')); return; } const letters = map[digits[index]]; for (const letter of letters) { current.push(letter); backtrack(index + 1, current); current.pop(); } }; backtrack(0, []); return result; };",No,No,O(3^n),3
"const findMin = (nums) => { let left = 0, right = nums.length - 1; while (left < right) { const mid = Math.floor((left + right) / 2); if (nums[mid] > nums[right]) left = mid + 1; else right = mid; } return nums[left]; };",No,No,O(log n),3
"const uniquePaths = (m, n) => { const dp = Array.from({ length: m }, () => Array(n).fill(1)); for (let i = 1; i < m; i++) { for (let j = 1; j < n; j++) { dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } return dp[m - 1][n - 1]; };",No,No,O(m*n),3
"const maximumSubArray = (nums) => { let maxSum = nums[0], currentSum = nums[0]; for (let i = 1; i < nums.length; i++) { currentSum = Math.max(nums[i], currentSum + nums[i]); maxSum = Math.max(maxSum, currentSum); } return maxSum; };",No,No,O(n),3
"const mergeTwoLists = (l1, l2) => { const dummy = new ListNode(0); let current = dummy; while (l1 !== null && l2 !== null) { if (l1.val < l2.val) { current.next = l1; l1 = l1.next; } else { current.next = l2; l2 = l2.next; } current = current.next; } current.next = l1 !== null ? l1 : l2; return dummy.next; };",No,No,O(n),3
"const spiralOrder = (matrix) => { if (matrix.length === 0) return []; const result = []; let left = 0, right = matrix[0].length - 1, top = 0, bottom = matrix.length - 1; while (left <= right && top <= bottom) { for (let i = left; i <= right; i++) result.push(matrix[top][i]); top++; for (let i = top; i <= bottom; i++) result.push(matrix[i][right]); right--; if (top <= bottom) { for (let i = right; i >= left; i--) result.push(matrix[bottom][i]); bottom--; } if (left <= right) { for (let i = bottom; i >= top; i--) result.push(matrix[i][left]); left++; } } return result; };",No,No,O(m*n),3
"const rob = (nums) => { if (nums.length === 1) return nums[0]; let prev1 = 0, prev2 = 0; for (let num of nums) { const temp = Math.max(prev1 + num, prev2); prev1 = prev2; prev2 = temp; } return prev2; };",No,No,O(n),3
"const searchMatrix = (matrix, target) => { if (!matrix.length) return false; let row = matrix.length, col = matrix[0].length, left = 0, right = row * col - 1; while (left <= right) { const mid = Math.floor((left + right) / 2); const midVal = matrix[Math.floor(mid / col)][mid % col]; if (midVal === target) return true; if (midVal < target) left = mid + 1; else right = mid - 1; } return false; };",No,No,O(log(m*n)),3
"const groupAnagrams = (strs) => { const map = {}; for (const str of strs) { const key = str.split('').sort().join(''); if (!map[key]) map[key] = []; map[key].push(str); } return Object.values(map); };",No,No,O(n*k log k),3
"const fourSum = (nums, target) => { nums.sort((a, b) => a - b); const result = []; for (let i = 0; i < nums.length - 3; i++) { if (i > 0 && nums[i] === nums[i - 1]) continue; for (let j = i + 1; j < nums.length - 2; j++) { if (j > i + 1 && nums[j] === nums[j - 1]) continue; let left = j + 1, right = nums.length - 1; while (left < right) { const sum = nums[i] + nums[j] + nums[left] + nums[right]; if (sum === target) { result.push([nums[i], nums[j], nums[left], nums[right]]); while (left < right && nums[left] === nums[left + 1]) left++; while (left < right && nums[right] === nums[right - 1]) right--; left++; right--; } else if (sum < target) left++; else right--; } } } return result; };",No,No,O(n^3),3
"const generateParenthesis = (n) => { const result = []; const backtrack = (current = '', open = 0, close = 0) => { if (current.length === 2 * n) { result.push(current); return; } if (open < n) backtrack(current + '(', open + 1, close); if (close < open) backtrack(current + ')', open, close + 1); }; backtrack(); return result; };",No,No,O(4^n/sqrt(n)),3
"const search = (nums, target) => { let left = 0, right = nums.length - 1; while (left <= right) { const mid = Math.floor((left + right) / 2); if (nums[mid] === target) return mid; if (nums[mid] < target) left = mid + 1; else right = mid - 1; } return -1; };",No,No,O(log n),3
"const lengthOfLongestSubstring = (s) => { const map = new Map(); let left = 0, maxLength = 0; for (let right = 0; right < s.length; right++) { if (map.has(s[right])) left = Math.max(map.get(s[right]) + 1, left); map.set(s[right], right); maxLength = Math.max(maxLength, right - left + 1); } return maxLength; };",No,No,O(n),3
"const reverseKGroup = (head, k) => { let count = 0, current = head; while (count < k && current) { current = current.next; count++; } if (count === k) { current = head; let prev = null; for (let i = 0; i < k; i++) { const temp = head.next; head.next = prev; prev = head; head = temp; } current.next = reverseKGroup(current, k); return prev; } return head; };",No,No,O(n),3
"const isPalindrome = (head) => { let slow = head, fast = head; while (fast && fast.next) { slow = slow.next; fast = fast.next.next; } let prev = null; while (prev !== slow) { const temp = slow.next; slow.next = prev; prev = slow; slow = temp; } return prev; };",No,No,O(n),3
"const longestPalindrome = (s) => { let start = 0, end = 0; const expandFromCenter = (left, right) => { while (left >= 0 && right < s.length && s[left] === s[right]) { left--; right++; } return right - left - 1; }; for (let i = 0; i < s.length; i++) { const len1 = expandFromCenter(i, i); const len2 = expandFromCenter(i, i + 1); const maxLen = Math.max(len1, len2); if (maxLen > end - start) { start = i - Math.floor((maxLen - 1) / 2); end = i + Math.floor(maxLen / 2); } } return s.slice(start, end + 1); };",No,No,O(n^2),3
"const minWindow = (s, t) => { const map = {}; for (const char of t) map[char] = (map[char] || 0) + 1; let left = 0, right = 0, minLen = Infinity, start = 0, count = t.length; while (right < s.length) { if (map[s[right]] > 0) count--; map[s[right]]--; right++; while (count === 0) { if (right - left < minLen) { minLen = right - left; start = left; } map[s[left]]++; if (map[s[left]] > 0) count++; left++; } } return minLen === Infinity ? "" : s.slice(start, start + minLen); };",No,No,O(n),3
"const sortColors = (nums) => { let p0 = 0, p2 = nums.length - 1; for (let i = 0; i <= p2; i++) { while (nums[i] === 2 && i < p2) [nums[i], nums[p2--]] = [nums[p2], nums[i]]; while (nums[i] === 0 && i > p0) [nums[i], nums[p0++]] = [nums[p0], nums[i]]; } return nums; };",No,No,O(n),3
"const removeNthFromEnd = (head, n) => { const dummy = new ListNode(0, head); let first = dummy, second = dummy; for (let i = 0; i < n + 1; i++) first = first.next; while (first) { first = first.next; second = second.next; } second.next = second.next.next; return dummy.next; };",No,No,O(n),3
"const merge = (intervals) => { intervals.sort((a, b) => a[0] - b[0]); const merged = []; for (const interval of intervals) { if (!merged.length || merged[merged.length - 1][1] < interval[0]) merged.push(interval); else merged[merged.length - 1][1] = Math.max(merged[merged.length - 1][1], interval[1]); } return merged; };",No,No,O(n log n),3
"const countAndSay = (n) => { if (n === 1) return '1'; let previous = countAndSay(n - 1); let result = '', count = 1; for (let i = 1; i < previous.length; i++) { if (previous[i] === previous[i - 1]) count++; else { result += count + previous[i - 1]; count = 1; } } result += count + previous[previous.length - 1]; return result; };",No,No,O(n),3
"const combinationSum = (candidates, target) => { const result = []; const backtrack = (start = 0, combination = [], sum = 0) => { if (sum === target) result.push([...combination]); if (sum >= target) return; for (let i = start; i < candidates.length; i++) { combination.push(candidates[i]); backtrack(i, combination, sum + candidates[i]); combination.pop(); } }; backtrack(); return result; };",No,No,O(2^n),3
"const uniquePaths = (m, n) => { const dp = Array.from({ length: m }, () => Array(n).fill(1)); for (let i = 1; i < m; i++) { for (let j = 1; j < n; j++) { dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } return dp[m - 1][n - 1]; };",No,No,O(m*n),3
"const numIslands = (grid) => { if (grid.length === 0) return 0; const directions = [[1, 0], [-1, 0], [0, 1], [0, -1]]; let count = 0; const dfs = (i, j) => { if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] === '0') return; grid[i][j] = '0'; for (const [x, y] of directions) dfs(i + x, j + y); }; for (let i = 0; i < grid.length; i++) { for (let j = 0; j < grid[0].length; j++) { if (grid[i][j] === '1') { count++; dfs(i, j); } } } return count; };",No,No,O(m*n),3
"const validateBinarySearchTree = (root) => { const helper = (node, lower = -Infinity, upper = Infinity) => { if (!node) return true; if (node.val <= lower || node.val >= upper) return false; return helper(node.left, lower, node.val) && helper(node.right, node.val, upper); }; return helper(root); };",No,No,O(n),3
"const lowestCommonAncestor = (root, p, q) => { if (!root || root === p || root === q) return root; const left = lowestCommonAncestor(root.left, p, q); const right = lowestCommonAncestor(root.right, p, q); return left && right ? root : left || right; };",No,No,O(n),3
"const binaryTreePaths = (root) => { const result = []; const backtrack = (node, path) => { if (!node) return; path += node.val; if (!node.left && !node.right) result.push(path); else { path += '->'; backtrack(node.left, path); backtrack(node.right, path); } }; backtrack(root, ''); return result; };",No,No,O(n),3
"const findMode = (root) => { const map = new Map(); const inorder = (node) => { if (!node) return; inorder(node.left); map.set(node.val, (map.get(node.val) || 0) + 1); inorder(node.right); }; inorder(root); const maxCount = Math.max(...map.values()); return [...map].filter(([key, count]) => count === maxCount).map(([key]) => key); };",No,No,O(n),3
"const cloneGraph = (node) => { if (!node) return null; const map = new Map(); const dfs = (n) => { if (map.has(n)) return map.get(n); const clone = new Node(n.val); map.set(n, clone); clone.neighbors = n.neighbors.map(dfs); return clone; }; return dfs(node); };",No,No,O(n),3
"const isSubtree = (root, subRoot) => { if (!root) return !subRoot; if (!subRoot) return false; return isSameTree(root, subRoot) || isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot); };",No,No,O(n),3
"const kthSmallest = (root, k) => { const inorder = (node) => { return node ? [...inorder(node.left), node.val, ...inorder(node.right)] : []; }; return inorder(root)[k - 1]; };",No,No,O(n),3
"const diameterOfBinaryTree = (root) => { let maxDiameter = 0; const height = (node) => { if (!node) return 0; const leftHeight = height(node.left); const rightHeight = height(node.right); maxDiameter = Math.max(maxDiameter, leftHeight + rightHeight); return Math.max(leftHeight, rightHeight) + 1; }; height(root); return maxDiameter; };",No,No,O(n),3
"const sumNumbers = (root) => { const dfs = (node, currentNumber) => { if (!node) return 0; currentNumber = currentNumber * 10 + node.val; if (!node.left && !node.right) return currentNumber; return dfs(node.left, currentNumber) + dfs(node.right, currentNumber); }; return dfs(root, 0); };",No,No,O(n),3
"const pathSum = (root, sum) => { const result = []; const dfs = (node, currentSum, path) => { if (!node) return; currentSum += node.val; if (!node.left && !node.right && currentSum === sum) result.push(path.concat(node.val)); dfs(node.left, currentSum, path.concat(node.val)); dfs(node.right, currentSum, path.concat(node.val)); }; dfs(root, 0, []); return result; };",No,No,O(n),3
"const findPath = (root, target) => { const dfs = (node) => { if (!node) return false; if (node.val === target) return true; return dfs(node.left) || dfs(node.right); }; return dfs(root); };",No,No,O(n),3
"const maxPathSum = (root) => { let maxSum = -Infinity; const dfs = (node) => { if (!node) return 0; const left = Math.max(dfs(node.left), 0); const right = Math.max(dfs(node.right), 0); maxSum = Math.max(maxSum, left + right + node.val); return left + right + node.val; }; dfs(root); return maxSum; };",No,No,O(n),3
"const serialize = (root) => { const result = []; const dfs = (node) => { if (!node) { result.push('null'); return; } result.push(node.val); dfs(node.left); dfs(node.right); }; dfs(root); return result.join(','); };",No,No,O(n),3
"const deserialize = (data) => { const list = data.split(','); const dfs = () => { const value = list.shift(); if (value === 'null') return null; const node = new TreeNode(Number(value)); node.left = dfs(); node.right = dfs(); return node; }; return dfs(); };",No,No,O(n),3
"const convertBST = (root) => { let sum = 0; const dfs = (node) => { if (!node) return; dfs(node.right); sum += node.val; node.val = sum; dfs(node.left); }; dfs(root); return root; };",No,No,O(n),3
"const maxDepth = (root) => { if (!root) return 0; return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1; };",No,No,O(n),3
"const isBalanced = (root) => { const dfs = (node) => { if (!node) return 0; const left = dfs(node.left); const right = dfs(node.right); if (left === -1 || right === -1 || Math.abs(left - right) > 1) return -1; return Math.max(left, right) + 1; }; return dfs(root) !== -1; };",No,No,O(n),3
"const lowestCommonAncestor = (root, p, q) => { if (!root || root === p || root === q) return root; const left = lowestCommonAncestor(root.left, p, q); const right = lowestCommonAncestor(root.right, p, q); return left && right ? root : left || right; };",No,No,O(n),3
"const pathSum = (root, sum) => { const result = []; const dfs = (node, currentSum) => { if (!node) return; currentSum += node.val; if (!node.left && !node.right && currentSum === sum) result.push(currentSum); dfs(node.left, currentSum); dfs(node.right, currentSum); }; dfs(root, 0); return result; };",No,No,O(n),3
"const diameterOfBinaryTree = (root) => { let maxDiameter = 0; const dfs = (node) => { if (!node) return 0; const leftHeight = dfs(node.left); const rightHeight = dfs(node.right); maxDiameter = Math.max(maxDiameter, leftHeight + rightHeight); return Math.max(leftHeight, rightHeight) + 1; }; dfs(root); return maxDiameter; };",No,No,O(n),3
"const mergeTrees = (t1, t2) => { if (!t1 && !t2) return null; const val1 = t1 ? t1.val : 0; const val2 = t2 ? t2.val : 0; const merged = new TreeNode(val1 + val2); merged.left = mergeTrees(t1 ? t1.left : null, t2 ? t2.left : null); merged.right = mergeTrees(t1 ? t1.right : null, t2 ? t2.right : null); return merged; };",No,No,O(n),3
"const maxPathSum = (root) => { let maxSum = -Infinity; const dfs = (node) => { if (!node) return 0; const left = Math.max(dfs(node.left), 0); const right = Math.max(dfs(node.right), 0); maxSum = Math.max(maxSum, left + right + node.val); return left + right + node.val; }; dfs(root); return maxSum; };",No,No,O(n),3
"const sumOfLeftLeaves = (root) => { const dfs = (node, isLeft) => { if (!node) return 0; if (!node.left && !node.right && isLeft) return node.val; return dfs(node.left, true) + dfs(node.right, false); }; return dfs(root, false); };",No,No,O(n),3
"const diameterOfBinaryTree = (root) => { let maxDiameter = 0; const dfs = (node) => { if (!node) return 0; const leftHeight = dfs(node.left); const rightHeight = dfs(node.right); maxDiameter = Math.max(maxDiameter, leftHeight + rightHeight); return Math.max(leftHeight, rightHeight) + 1; }; dfs(root); return maxDiameter; };",No,No,O(n),3
"const averageOfLevels = (root) => { const result = []; const dfs = (node, depth) => { if (!node) return; if (!result[depth]) result[depth] = []; result[depth].push(node.val); dfs(node.left, depth + 1); dfs(node.right, depth + 1); }; dfs(root, 0); return result.map(level => level.reduce((a, b) => a + b) / level.length); };",No,No,O(n),3
"const pathSum = (root, sum) => { const result = []; const dfs = (node, currentSum) => { if (!node) return; currentSum += node.val; if (!node.left && !node.right && currentSum === sum) result.push(currentSum); dfs(node.left, currentSum); dfs(node.right, currentSum); }; dfs(root, 0); return result; };",No,No,O(n),3
"const levelOrder = (root) => { const result = []; const dfs = (node, depth) => { if (!node) return; if (!result[depth]) result[depth] = []; result[depth].push(node.val); dfs(node.left, depth + 1); dfs(node.right, depth + 1); }; dfs(root, 0); return result; };",No,No,O(n),3
"const isSymmetric = (root) => { const dfs = (left, right) => { if (!left && !right) return true; if (!left || !right) return false; return left.val === right.val && dfs(left.left, right.right) && dfs(left.right, right.left); }; return dfs(root.left, root.right); };",No,No,O(n),3
"const lowestCommonAncestor = (root, p, q) => { if (!root || root === p || root === q) return root; const left = lowestCommonAncestor(root.left, p, q); const right = lowestCommonAncestor(root.right, p, q); return left && right ? root : left || right; };",No,No,O(n),3
"const findBottomLeftValue = (root) => { let result; const dfs = (node, depth) => { if (!node) return; if (depth > maxDepth) { result = node.val; maxDepth = depth; } dfs(node.left, depth + 1); dfs(node.right, depth + 1); }; let maxDepth = -1; dfs(root, 0); return result; };",No,No,O(n),3
"const convertBST = (root) => { let sum = 0; const dfs = (node) => { if (!node) return; dfs(node.right); sum += node.val; node.val = sum; dfs(node.left); }; dfs(root); return root; };",No,No,O(n),3
"const findLeaves = (root) => { const result = []; const dfs = (node) => { if (!node) return; if (!result[node.depth]) result[node.depth] = []; result[node.depth].push(node.val); dfs(node.left); dfs(node.right); }; dfs(root); return result; };",No,No,O(n),3
"const zigzagLevelOrder = (root) => { const result = []; const dfs = (node, depth) => { if (!node) return; if (!result[depth]) result[depth] = []; result[depth].push(node.val); dfs(node.left, depth + 1); dfs(node.right, depth + 1); }; dfs(root, 0); return result.map((level, i) => i % 2 === 0 ? level : level.reverse()); };",No,No,O(n),3
"const maxDepth = (root) => { if (!root) return 0; return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1; };",No,No,O(n),3
"const minDepth = (root) => { if (!root) return 0; if (!root.left) return minDepth(root.right) + 1; if (!root.right) return minDepth(root.left) + 1; return Math.min(minDepth(root.left), minDepth(root.right)) + 1; };",No,No,O(n),3
"const isBalanced = (root) => { const dfs = (node) => { if (!node) return 0; const left = dfs(node.left); const right = dfs(node.right); if (left === -1 || right === -1 || Math.abs(left - right) > 1) return -1; return Math.max(left, right) + 1; }; return dfs(root) !== -1; };",No,No,O(n),3
"const binaryTreePaths = (root) => { const result = []; const dfs = (node, path) => { if (!node) return; path += node.val; if (!node.left && !node.right) result.push(path); else { path += '->'; dfs(node.left, path); dfs(node.right, path); } }; dfs(root, ''); return result; };",No,No,O(n),3
"const flatten = (root) => { const dfs = (node) => { if (!node) return null; const left = dfs(node.left); const right = dfs(node.right); node.left = null; node.right = right; return left || node; }; return dfs(root); };",No,No,O(n),3
"const longestUnivaluePath = (root) => { let maxPath = 0; const dfs = (node, parentValue) => { if (!node) return 0; const left = dfs(node.left, node.val); const right = dfs(node.right, node.val); maxPath = Math.max(maxPath, left + right); return node.val === parentValue ? Math.max(left, right) + 1 : 0; }; dfs(root, null); return maxPath; };",No,No,O(n),3
"const levelOrder = (root) => { const result = []; const dfs = (node, depth) => { if (!node) return; if (!result[depth]) result[depth] = []; result[depth].push(node.val); dfs(node.left, depth + 1); dfs(node.right, depth + 1); }; dfs(root, 0); return result; };",No,No,O(n),3
"const flatten = (root) => { let prev = null; const dfs = (node) => { if (!node) return; dfs(node.right); dfs(node.left); node.right = prev; node.left = null; prev = node; }; dfs(root); };",No,No,O(n),3
"const isSymmetric = (root) => { const dfs = (left, right) => { if (!left && !right) return true; if (!left || !right) return false; return left.val === right.val && dfs(left.left, right.right) && dfs(left.right, right.left); }; return dfs(root.left, root.right); };",No,No,O(n),3
"const rangeSumBST = (root, low, high) => { if (!root) return 0; if (root.val < low) return rangeSumBST(root.right, low, high); if (root.val > high) return rangeSumBST(root.left, low, high); return root.val + rangeSumBST(root.left, low, high) + rangeSumBST(root.right, low, high); };",No,No,O(n),3
"const findTarget = (root, k) => { const seen = new Set(); const dfs = (node) => { if (!node) return false; if (seen.has(k - node.val)) return true; seen.add(node.val); return dfs(node.left) || dfs(node.right); }; return dfs(root); };",No,No,O(n),3
"const sumOfLeftLeaves = (root) => { const dfs = (node, isLeft) => { if (!node) return 0; if (!node.left && !node.right && isLeft) return node.val; return dfs(node.left, true) + dfs(node.right, false); }; return dfs(root, false); };",No,No,O(n),3
"const isBalanced = (root) => { const dfs = (node) => { if (!node) return 0; const left = dfs(node.left); const right = dfs(node.right); if (left === -1 || right === -1 || Math.abs(left - right) > 1) return -1; return Math.max(left, right) + 1; }; return dfs(root) !== -1; };",No,No,O(n),3
"const binaryTreePaths = (root) => { const result = []; const dfs = (node, path) => { if (!node) return; path += node.val; if (!node.left && !node.right) result.push(path); else { path += '->'; dfs(node.left, path); dfs(node.right, path); } }; dfs(root, ''); return result; };",No,No,O(n),3
"const diameterOfBinaryTree = (root) => { let maxDiameter = 0; const dfs = (node) => { if (!node) return 0; const leftHeight = dfs(node.left); const rightHeight = dfs(node.right); maxDiameter = Math.max(maxDiameter, leftHeight + rightHeight); return Math.max(leftHeight, rightHeight) + 1; }; dfs(root); return maxDiameter; };",No,No,O(n),3
"const convertBST = (root) => { let sum = 0; const dfs = (node) => { if (!node) return; dfs(node.right); sum += node.val; node.val = sum; dfs(node.left); }; dfs(root); return root; };",No,No,O(n),3
"const findBottomLeftValue = (root) => { let result; const dfs = (node, depth) => { if (!node) return; if (depth > maxDepth) { result = node.val; maxDepth = depth; } dfs(node.left, depth + 1); dfs(node.right, depth + 1); }; let maxDepth = -1; dfs(root, 0); return result; };",No,No,O(n),3
"const longestUnivaluePath = (root) => { let maxPath = 0; const dfs = (node, parentValue) => { if (!node) return 0; const left = dfs(node.left, node.val); const right = dfs(node.right, node.val); maxPath = Math.max(maxPath, left + right); return node.val === parentValue ? Math.max(left, right) + 1 : 0; }; dfs(root, null); return maxPath; };",No,No,O(n),3
"const isSymmetric = (root) => { const dfs = (left, right) => { if (!left && !right) return true; if (!left || !right) return false; return left.val === right.val && dfs(left.left, right.right) && dfs(left.right, right.left); }; return dfs(root.left, root.right); };",No,No,O(n),3
"const rangeSumBST = (root, low, high) => { if (!root) return 0; if (root.val < low) return rangeSumBST(root.right, low, high); if (root.val > high) return rangeSumBST(root.left, low, high); return root.val + rangeSumBST(root.left, low, high) + rangeSumBST(root.right, low, high); };",No,No,O(n),3
"const maxDepth = (root) => { if (!root) return 0; return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1; };",No,No,O(n),3
"const diameterOfBinaryTree = (root) => { let maxDiameter = 0; const dfs = (node) => { if (!node) return 0; const leftHeight = dfs(node.left); const rightHeight = dfs(node.right); maxDiameter = Math.max(maxDiameter, leftHeight + rightHeight); return Math.max(leftHeight, rightHeight) + 1; }; dfs(root); return maxDiameter; };",No,No,O(n),3
"const flatten = (root) => { let prev = null; const dfs = (node) => { if (!node) return; dfs(node.right); dfs(node.left); node.right = prev; node.left = null; prev = node; }; dfs(root); };",No,No,O(n),3
"const maxPathSum = (root) => { let maxSum = -Infinity; const dfs = (node) => { if (!node) return 0; const left = Math.max(dfs(node.left), 0); const right = Math.max(dfs(node.right), 0); maxSum = Math.max(maxSum, left + right + node.val); return left + right + node.val; }; dfs(root); return maxSum; };",No,No,O(n),3
"const sumOfLeftLeaves = (root) => { const dfs = (node, isLeft) => { if (!node) return 0; if (!node.left && !node.right && isLeft) return node.val; return dfs(node.left, true) + dfs(node.right, false); }; return dfs(root, false); };",No,No,O(n),3
"const longestUnivaluePath = (root) => { let maxPath = 0; const dfs = (node, parentValue) => { if (!node) return 0; const left = dfs(node.left, node.val); const right = dfs(node.right, node.val); maxPath = Math.max(maxPath, left + right); return node.val === parentValue ? Math.max(left, right) + 1 : 0; }; dfs(root, null); return maxPath; };",No,No,O(n),3
"const binaryTreePaths = (root) => { const result = []; const dfs = (node, path) => { if (!node) return; path += node.val; if (!node.left && !node.right) result.push(path); else { path += '->'; dfs(node.left, path); dfs(node.right, path); } }; dfs(root, ''); return result; };",No,No,O(n),3
"const levelOrder = (root) => { const result = []; const dfs = (node, depth) => { if (!node) return; if (!result[depth]) result[depth] = []; result[depth].push(node.val); dfs(node.left, depth + 1); dfs(node.right, depth + 1); }; dfs(root, 0); return result; };",No,No,O(n),3
"const flatten = (root) => { const dfs = (node) => { if (!node) return null; const left = dfs(node.left); const right = dfs(node.right); node.left = null; node.right = right; return left || node; }; return dfs(root); };",No,No,O(n),3
"const isBalanced = (root) => { const dfs = (node) => { if (!node) return 0; const left = dfs(node.left); const right = dfs(node.right); if (left === -1 || right === -1 || Math.abs(left - right) > 1) return -1; return Math.max(left, right) + 1; }; return dfs(root) !== -1; };",No,No,O(n),3
"const findBottomLeftValue = (root) => { let result; const dfs = (node, depth) => { if (!node) return; if (depth > maxDepth) { result = node.val; maxDepth = depth; } dfs(node.left, depth + 1); dfs(node.right, depth + 1); }; let maxDepth = -1; dfs(root, 0); return result; };",No,No,O(n),3
"const averageOfLevels = (root) => { const result = []; const dfs = (node, depth) => { if (!node) return; if (!result[depth]) result[depth] = []; result[depth].push(node.val); dfs(node.left, depth + 1); dfs(node.right, depth + 1); }; dfs(root, 0); return result.map(level => level.reduce((sum, val) => sum + val) / level.length); };",No,No,O(n),3
"const countNodes = (root) => { if (!root) return 0; return 1 + countNodes(root.left) + countNodes(root.right); };",No,No,O(n),3
"const buildTree = (preorder, inorder) => { if (!preorder.length) return null; const rootVal = preorder[0]; const root = new TreeNode(rootVal); const rootIndex = inorder.indexOf(rootVal); root.left = buildTree(preorder.slice(1, rootIndex + 1), inorder.slice(0, rootIndex)); root.right = buildTree(preorder.slice(rootIndex + 1), inorder.slice(rootIndex + 1)); return root; };",No,No,O(n),3
"const rob = (nums) => { const dfs = (i) => { if (i < 0) return 0; return Math.max(dfs(i - 1), dfs(i - 2) + nums[i]); }; return dfs(nums.length - 1); };",No,No,O(n),3
"const longestConsecutive = (nums) => { const numSet = new Set(nums); let longestStreak = 0; for (const num of numSet) { if (!numSet.has(num - 1)) { let currentNum = num; let currentStreak = 1; while (numSet.has(currentNum + 1)) { currentNum++; currentStreak++; } longestStreak = Math.max(longestStreak, currentStreak); } } return longestStreak; };",No,No,O(n),3
"const containsDuplicate = (nums) => { const numSet = new Set(); for (const num of nums) { if (numSet.has(num)) return true; numSet.add(num); } return false; };",No,No,O(n),3
"const productExceptSelf = (nums) => { const result = Array(nums.length).fill(1); let leftProduct = 1; for (let i = 0; i < nums.length; i++) { result[i] *= leftProduct; leftProduct *= nums[i]; } let rightProduct = 1; for (let i = nums.length - 1; i >= 0; i--) { result[i] *= rightProduct; rightProduct *= nums[i]; } return result; };",No,No,O(n),3
"const maxSubArray = (nums) => { let maxSum = -Infinity, currentSum = 0; for (const num of nums) { currentSum = Math.max(num, currentSum + num); maxSum = Math.max(maxSum, currentSum); } return maxSum; };",No,No,O(n),3
"const minSubArrayLen = (target, nums) => { let left = 0, sum = 0, minLength = Infinity; for (let right = 0; right < nums.length; right++) { sum += nums[right]; while (sum >= target) { minLength = Math.min(minLength, right - left + 1); sum -= nums[left++]; } } return minLength === Infinity ? 0 : minLength; };",No,No,O(n),3
"const maxArea = (height) => { let left = 0, right = height.length - 1, maxArea = 0; while (left < right) { const area = Math.min(height[left], height[right]) * (right - left); maxArea = Math.max(maxArea, area); if (height[left] < height[right]) left++; else right--; } return maxArea; };",No,No,O(n),3
"const search = (nums, target) => { let left = 0, right = nums.length - 1; while (left <= right) { const mid = Math.floor((left + right) / 2); if (nums[mid] === target) return mid; if (nums[mid] < target) left = mid + 1; else right = mid - 1; } return -1; };",No,No,O(log n),3
"const climbStairs = (n) => { const dp = Array(n + 1).fill(0); dp[0] = 1; dp[1] = 1; for (let i = 2; i <= n; i++) { dp[i] = dp[i - 1] + dp[i - 2]; } return dp[n]; };",No,No,O(n),3
"const mergeIntervals = (intervals) => { if (!intervals.length) return []; intervals.sort((a, b) => a[0] - b[0]); const merged = [intervals[0]]; for (let i = 1; i < intervals.length; i++) { const [start, end] = intervals[i]; const [lastStart, lastEnd] = merged[merged.length - 1]; if (start <= lastEnd) { merged[merged.length - 1][1] = Math.max(lastEnd, end); } else { merged.push(intervals[i]); } } return merged; };",No,No,O(n log n),3
"const generateParenthesis = (n) => { const result = []; const backtrack = (open, close, str) => { if (str.length === 2 * n) { result.push(str); return; } if (open < n) backtrack(open + 1, close, str + '('); if (close < open) backtrack(open, close + 1, str + ')'); }; backtrack(0, 0, ''); return result; };",No,No,O(2^n),3
"const permute = (nums) => { const result = []; const backtrack = (start) => { if (start === nums.length) { result.push([...nums]); return; } for (let i = start; i < nums.length; i++) { [nums[start], nums[i]] = [nums[i], nums[start]]; backtrack(start + 1); [nums[start], nums[i]] = [nums[i], nums[start]]; } }; backtrack(0); return result; };",No,No,O(n!),3
"const subsets = (nums) => { const result = []; const backtrack = (start, path) => { result.push(path); for (let i = start; i < nums.length; i++) { backtrack(i + 1, path.concat(nums[i])); } }; backtrack(0, []); return result; };",No,No,O(2^n),3
"const letterCombinations = (digits) => { if (!digits.length) return []; const phoneMap = {2: 'abc', 3: 'def', 4: 'ghi', 5: 'jkl', 6: 'mno', 7: 'pqrs', 8: 'tuv', 9: 'wxyz'}; const result = []; const backtrack = (index, path) => { if (path.length === digits.length) { result.push(path.join('')); return; } for (const char of phoneMap[digits[index]]) { path.push(char); backtrack(index + 1, path); path.pop(); } }; backtrack(0, []); return result; };",No,No,O(3^n),3
"const uniquePaths = (m, n) => { const dp = Array(m).fill(0).map(() => Array(n).fill(0)); for (let i = 0; i < m; i++) dp[i][0] = 1; for (let j = 0; j < n; j++) dp[0][j] = 1; for (let i = 1; i < m; i++) { for (let j = 1; j < n; j++) { dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } return dp[m - 1][n - 1]; };",No,No,O(m*n),3
"const editDistance = (word1, word2) => { const dp = Array(word1.length + 1).fill(0).map(() => Array(word2.length + 1).fill(0)); for (let i = 0; i <= word1.length; i++) dp[i][0] = i; for (let j = 0; j <= word2.length; j++) dp[0][j] = j; for (let i = 1; i <= word1.length; i++) { for (let j = 1; j <= word2.length; j++) { if (word1[i - 1] === word2[j - 1]) dp[i][j] = dp[i - 1][j - 1]; else dp[i][j] = Math.min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1; } } return dp[word1.length][word2.length]; };",No,No,O(m*n),3
"const numIslands = (grid) => { if (!grid.length) return 0; const dfs = (i, j) => { if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] === '0') return; grid[i][j] = '0'; dfs(i - 1, j); dfs(i + 1, j); dfs(i, j - 1); dfs(i, j + 1); }; let count = 0; for (let i = 0; i < grid.length; i++) { for (let j = 0; j < grid[0].length; j++) { if (grid[i][j] === '1') { dfs(i, j); count++; } } } return count; };",No,No,O(m*n),3
"const islandPerimeter = (grid) => { let perimeter = 0; for (let i = 0; i < grid.length; i++) { for (let j = 0; j < grid[0].length; j++) { if (grid[i][j] === 1) { perimeter += 4; if (i > 0 && grid[i - 1][j] === 1) perimeter -= 2; if (j > 0 && grid[i][j - 1] === 1) perimeter -= 2; } } } return perimeter; };",No,No,O(m*n),3
"const lowestCommonAncestor = (root, p, q) => { if (!root || root === p || root === q) return root; const left = lowestCommonAncestor(root.left, p, q); const right = lowestCommonAncestor(root.right, p, q); return left && right ? root : left || right; };",No,No,O(n),3
"const canJump = (nums) => { let maxReach = 0; for (let i = 0; i < nums.length; i++) { if (i > maxReach) return false; maxReach = Math.max(maxReach, i + nums[i]); } return true; };",No,No,O(n),3
"const jump = (nums) => { let jumps = 0, currentEnd = 0, farthest = 0; for (let i = 0; i < nums.length - 1; i++) { farthest = Math.max(farthest, i + nums[i]); if (i === currentEnd) { jumps++; currentEnd = farthest; } } return jumps; };",No,No,O(n),3
"const findDuplicate = (nums) => { let slow = nums[0], fast = nums[0]; do { slow = nums[slow]; fast = nums[nums[fast]]; } while (slow !== fast); let finder = nums[0]; while (finder !== slow) { finder = nums[finder]; slow = nums[slow]; } return finder; };",No,No,O(n),3
"const hIndex = (citations) => { let left = 0, right = citations.length - 1; while (left <= right) { const mid = Math.floor((left + right) / 2); if (citations[mid] >= citations.length - mid) right = mid - 1; else left = mid + 1; } return citations.length - left; };",No,No,O(log n),3
"const smallestRangeI = (A, K) => { const minVal = Math.min(...A); const maxVal = Math.max(...A); return Math.max(0, maxVal - minVal - 2 * K); };",No,No,O(n),3
"const twoSum = (nums, target) => { const numMap = new Map(); for (let i = 0; i < nums.length; i++) { const complement = target - nums[i]; if (numMap.has(complement)) return [numMap.get(complement), i]; numMap.set(nums[i], i); } return []; };",No,No,O(n),3
"const rotate = (nums, k) => { k %= nums.length; const reverse = (start, end) => { while (start < end) { [nums[start], nums[end]] = [nums[end], nums[start]]; start++; end--; } }; reverse(0, nums.length - 1); reverse(0, k - 1); reverse(k, nums.length - 1); };",No,No,O(n),3
"const spiralOrder = (matrix) => { if (!matrix.length) return []; const result = []; let left = 0, right = matrix[0].length - 1, top = 0, bottom = matrix.length - 1; while (left <= right && top <= bottom) { for (let i = left; i <= right; i++) result.push(matrix[top][i]); top++; for (let i = top; i <= bottom; i++) result.push(matrix[i][right]); right--; if (top <= bottom) { for (let i = right; i >= left; i--) result.push(matrix[bottom][i]); bottom--; } if (left <= right) { for (let i = bottom; i >= top; i--) result.push(matrix[i][left]); left++; } } return result; };",No,No,O(m*n),3
"const countBattleships = (board) => { if (!board.length) return 0; let count = 0; for (let i = 0; i < board.length; i++) { for (let j = 0; j < board[0].length; j++) { if (board[i][j] === 'X' && (i === 0 || board[i - 1][j] === '.') && (j === 0 || board[i][j - 1] === '.')) count++; } } return count; };",No,No,O(m*n),3
"const canConstruct = (ransomNote, magazine) => { const magazineCount = {}; for (const char of magazine) magazineCount[char] = (magazineCount[char] || 0) + 1; for (const char of ransomNote) { if (!magazineCount[char]) return false; magazineCount[char]--; } return true; };",No,No,O(m+n),3
"const maximumProduct = (nums) => { nums.sort((a, b) => a - b); return Math.max(nums[0] * nums[1] * nums[nums.length - 1], nums[nums.length - 1] * nums[nums.length - 2] * nums[nums.length - 3]); };",No,No,O(n log n),3
"const arrayPairSum = (nums) => { nums.sort((a, b) => a - b); return nums.reduce((sum, val, index) => index % 2 === 0 ? sum + val : sum, 0); };",No,No,O(n log n),3
"const isValidSudoku = (board) => { const rows = Array(9).fill(0).map(() => new Set()), columns = Array(9).fill(0).map(() => new Set()), boxes = Array(9).fill(0).map(() => new Set()); for (let i = 0; i < 9; i++) { for (let j = 0; j < 9; j++) { if (board[i][j] !== '.') { const val = board[i][j]; const boxIndex = Math.floor(i / 3) * 3 + Math.floor(j / 3); if (rows[i].has(val) || columns[j].has(val) || boxes[boxIndex].has(val)) return false; rows[i].add(val); columns[j].add(val); boxes[boxIndex].add(val); } } } return true; };",No,No,O(n^2),3
"const maxProfit = (prices) => { let maxProfit = 0; for (let i = 1; i < prices.length; i++) { if (prices[i] > prices[i - 1]) maxProfit += prices[i] - prices[i - 1]; } return maxProfit; };",No,No,O(n),3
"const isAnagram = (s, t) => { if (s.length !== t.length) return false; const count = {}; for (const char of s) count[char] = (count[char] || 0) + 1; for (const char of t) { if (!count[char]) return false; count[char]--; } return true; };",No,No,O(n),3
"const longestPalindrome = (s) => { let result = ''; for (let i = 0; i < s.length; i++) { const odd = expandAroundCenter(s, i, i); const even = expandAroundCenter(s, i, i + 1); result = result.length > odd.length ? result : odd.length > even.length ? odd : even; } return result; }; const expandAroundCenter = (s, left, right) => { while (left >= 0 && right < s.length && s[left] === s[right]) { left--; right++; } return s.slice(left + 1, right); };",No,No,O(n^2),3
"const firstUniqChar = (s) => { const charCount = {}; for (const char of s) charCount[char] = (charCount[char] || 0) + 1; for (let i = 0; i < s.length; i++) { if (charCount[s[i]] === 1) return i; } return -1; };",No,No,O(n),3
"const reverseString = (s) => { let left = 0, right = s.length - 1; while (left < right) { [s[left], s[right]] = [s[right], s[left]]; left++; right--; } return s; };",No,No,O(n),3
"const longestCommonPrefix = (strs) => { if (!strs.length) return ''; let prefix = strs[0]; for (let i = 1; i < strs.length; i++) { while (strs[i].indexOf(prefix) !== 0) { prefix = prefix.substring(0, prefix.length - 1); if (!prefix) return ''; } } return prefix; };",No,No,O(n*m),3
"const addTwoNumbers = (l1, l2) => { let carry = 0, dummyHead = new ListNode(0), current = dummyHead; while (l1 || l2 || carry) { const sum = (l1 ? l1.val : 0) + (l2 ? l2.val : 0) + carry; carry = Math.floor(sum / 10); current.next = new ListNode(sum % 10); current = current.next; if (l1) l1 = l1.next; if (l2) l2 = l2.next; } return dummyHead.next; };",No,No,O(max(n,m)),3
"const groupAnagrams = (strs) => { const map = {}; for (const str of strs) { const sortedStr = str.split('').sort().join(''); if (!map[sortedStr]) map[sortedStr] = []; map[sortedStr].push(str); } return Object.values(map); };",No,No,O(n*k log k),3
"const mergeTwoLists = (l1, l2) => { let dummy = new ListNode(0), current = dummy; while (l1 && l2) { if (l1.val < l2.val) { current.next = l1; l1 = l1.next; } else { current.next = l2; l2 = l2.next; } current = current.next; } current.next = l1 || l2; return dummy.next; };",No,No,O(n+m),3
"const findKthLargest = (nums, k) => { const sorted = nums.sort((a, b) => b - a); return sorted[k - 1]; };",No,No,O(n log n),3
"const merge = (intervals) => { if (!intervals.length) return []; intervals.sort((a, b) => a[0] - b[0]); const merged = [intervals[0]]; for (let i = 1; i < intervals.length; i++) { const [start, end] = intervals[i]; const [lastStart, lastEnd] = merged[merged.length - 1]; if (start <= lastEnd) { merged[merged.length - 1][1] = Math.max(lastEnd, end); } else { merged.push(intervals[i]); } } return merged; };",No,No,O(n log n),3
"const generateParenthesis = (n) => { const result = []; const backtrack = (current, open, close) => { if (current.length === 2 * n) { result.push(current); return; } if (open < n) backtrack(current + '(', open + 1, close); if (close < open) backtrack(current + ')', open, close + 1); }; backtrack('', 0, 0); return result; };",No,No,O(4^n/sqrt(n)),3
"const uniquePaths = (m, n) => { const dp = Array(m).fill(0).map(() => Array(n).fill(0)); for (let i = 0; i < m; i++) dp[i][0] = 1; for (let j = 0; j < n; j++) dp[0][j] = 1; for (let i = 1; i < m; i++) { for (let j = 1; j < n; j++) { dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } return dp[m - 1][n - 1]; };",No,No,O(m*n),3
"const search = (nums, target) => { let left = 0, right = nums.length - 1; while (left <= right) { const mid = Math.floor((left + right) / 2); if (nums[mid] === target) return mid; if (nums[mid] < target) left = mid + 1; else right = mid - 1; } return -1; };",No,No,O(log n),3
"const lengthOfLongestSubstring = (s) => { const charIndex = {}; let left = 0, maxLength = 0; for (let right = 0; right < s.length; right++) { if (charIndex[s[right]] !== undefined) left = Math.max(left, charIndex[s[right]] + 1); charIndex[s[right]] = right; maxLength = Math.max(maxLength, right - left + 1); } return maxLength; };",No,No,O(n),3
"const validParentheses = (s) => { const stack = []; for (let char of s) { if (char === '(') stack.push(char); else if (char === ')') { if (!stack.length) return false; stack.pop(); } } return stack.length === 0; };",No,No,O(n),3
"const maxArea = (height) => { let left = 0, right = height.length - 1, maxArea = 0; while (left < right) { const area = Math.min(height[left], height[right]) * (right - left); maxArea = Math.max(maxArea, area); if (height[left] < height[right]) left++; else right--; } return maxArea; };",No,No,O(n),3
"const myAtoi = (s) => { let index = 0, sign = 1, total = 0; while (s[index] === ' ') index++; if (s[index] === '-' || s[index] === '+') { sign = s[index] === '-' ? -1 : 1; index++; } while (index < s.length && s[index] >= '0' && s[index] <= '9') { total = total * 10 + (s[index].charCodeAt(0) - '0'.charCodeAt(0)); index++; } return Math.max(Math.min(total * sign, 2**31 - 1), -2**31); };",No,No,O(n),3
"const searchInsert = (nums, target) => { let left = 0, right = nums.length - 1; while (left <= right) { const mid = Math.floor((left + right) / 2); if (nums[mid] === target) return mid; if (nums[mid] < target) left = mid + 1; else right = mid - 1; } return left; };",No,No,O(log n),3
"const isPalindrome = (s) => { const filtered = s.replace(/[^a-zA-Z0-9]/g, '').toLowerCase(); return filtered === filtered.split('').reverse().join(''); };",No,No,O(n),3
"const findMedianSortedArrays = (nums1, nums2) => { const merged = [...nums1, ...nums2].sort((a, b) => a - b); const mid = Math.floor(merged.length / 2); return merged.length % 2 === 0 ? (merged[mid - 1] + merged[mid]) / 2 : merged[mid]; };",No,No,O((m+n) log(m+n)),3
"const threeSum = (nums) => { nums.sort((a, b) => a - b); const result = []; for (let i = 0; i < nums.length; i++) { if (i > 0 && nums[i] === nums[i - 1]) continue; let left = i + 1, right = nums.length - 1; while (left < right) { const sum = nums[i] + nums[left] + nums[right]; if (sum < 0) left++; else if (sum > 0) right--; else { result.push([nums[i], nums[left], nums[right]]); while (left < right && nums[left] === nums[left + 1]) left++; while (left < right && nums[right] === nums[right - 1]) right--; left++; right--; } } } return result; };",No,No,O(n^2),3
"const letterCombinations = (digits) => { const digitToChar = { '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz' }; const result = []; const backtrack = (combination, nextDigits) => { if (!nextDigits.length) result.push(combination); else { const digit = nextDigits[0]; const letters = digitToChar[digit]; for (const letter of letters) backtrack(combination + letter, nextDigits.slice(1)); } }; backtrack('', digits); return result; };",No,No,O(3^n),3
"const productExceptSelf = (nums) => { const result = Array(nums.length).fill(1); let left = 1, right = 1; for (let i = 0; i < nums.length; i++) { result[i] *= left; left *= nums[i]; } for (let j = nums.length - 1; j >= 0; j--) { result[j] *= right; right *= nums[j]; } return result; };",No,No,O(n),3
"const reverseString = (s) => { let left = 0, right = s.length - 1; while (left < right) [s[left++], s[right--]] = [s[right], s[left]]; };",No,No,O(n),3
"const rotateArray = (nums, k) => { k %= nums.length; const reverse = (arr, start, end) => { while (start < end) [arr[start++], arr[end--]] = [arr[end], arr[start]]; }; reverse(nums, 0, nums.length - 1); reverse(nums, 0, k - 1); reverse(nums, k, nums.length - 1); };",No,No,O(n),3
"const canJump = (nums) => { let maxReach = 0; for (let i = 0; i < nums.length; i++) { if (i > maxReach) return false; maxReach = Math.max(maxReach, i + nums[i]); } return true; };",No,No,O(n),3
"const findAllDuplicates = (nums) => { const result = []; for (const num of nums) { const index = Math.abs(num) - 1; if (nums[index] < 0) result.push(index + 1); nums[index] = -nums[index]; } return result; };",No,No,O(n),3
"const canConstruct = (ransomNote, magazine) => { const charCount = {}; for (const char of magazine) charCount[char] = (charCount[char] || 0) + 1; for (const char of ransomNote) { if (!charCount[char]) return false; charCount[char]--; } return true; };",No,No,O(n),3
"const maxProfit = (prices) => { let minPrice = Infinity, maxProfit = 0; for (const price of prices) { minPrice = Math.min(minPrice, price); maxProfit = Math.max(maxProfit, price - minPrice); } return maxProfit; };",No,No,O(n),3
"const twoSum = (nums, target) => { const map = {}; for (let i = 0; i < nums.length; i++) { const complement = target - nums[i]; if (map[complement] !== undefined) return [map[complement], i]; map[nums[i]] = i; } };",No,No,O(n),3
"const climbStairs = (n) => { const dp = Array(n + 1).fill(0); dp[0] = 1; for (let i = 1; i <= n; i++) { dp[i] += dp[i - 1]; if (i - 2 >= 0) dp[i] += dp[i - 2]; } return dp[n]; };",No,No,O(n),3
"const longestIncreasingSubsequence = (nums) => { const dp = Array(nums.length).fill(1); for (let i = 1; i < nums.length; i++) { for (let j = 0; j < i; j++) { if (nums[i] > nums[j]) dp[i] = Math.max(dp[i], dp[j] + 1); } } return Math.max(...dp); };",No,No,O(n^2),3
"const numIslands = (grid) => { if (!grid.length) return 0; const visited = new Set(); const dfs = (i, j) => { if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] === '0' || visited.has(`${i},${j}`)) return; visited.add(`${i},${j}`); dfs(i - 1, j); dfs(i + 1, j); dfs(i, j - 1); dfs(i, j + 1); }; let count = 0; for (let i = 0; i < grid.length; i++) { for (let j = 0; j < grid[0].length; j++) { if (grid[i][j] === '1' && !visited.has(`${i},${j}`)) { count++; dfs(i, j); } } } return count; };",No,No,O(m*n),3
"const rotateImage = (matrix) => { const n = matrix.length; for (let layer = 0; layer < n / 2; layer++) { const first = layer; const last = n - 1 - layer; for (let i = first; i < last; i++) { const offset = i - first; const top = matrix[first][i]; matrix[first][i] = matrix[last - offset][first]; matrix[last - offset][first] = matrix[last][last - offset]; matrix[last][last - offset] = matrix[i][last]; matrix[i][last] = top; } } };",No,No,O(n^2),3
"const minPathSum = (grid) => { const m = grid.length, n = grid[0].length; const dp = Array(m).fill(0).map(() => Array(n).fill(0)); dp[0][0] = grid[0][0]; for (let i = 1; i < m; i++) dp[i][0] = dp[i - 1][0] + grid[i][0]; for (let j = 1; j < n; j++) dp[0][j] = dp[0][j - 1] + grid[0][j]; for (let i = 1; i < m; i++) { for (let j = 1; j < n; j++) { dp[i][j] = grid[i][j] + Math.min(dp[i - 1][j], dp[i][j - 1]); } } return dp[m - 1][n - 1]; };",No,No,O(m*n),3
"const partition = (s) => { const result = []; const backtrack = (start, path) => { if (start === s.length) result.push([...path]); for (let end = start; end < s.length; end++) { const substr = s.substring(start, end + 1); if (isPalindrome(substr)) { path.push(substr); backtrack(end + 1, path); path.pop(); } } }; backtrack(0, []); return result; };",No,No,O(n*2^n),3
"const wordBreak = (s, wordDict) => { const dp = Array(s.length + 1).fill(false); dp[0] = true; for (let i = 1; i <= s.length; i++) { for (let j = 0; j < i; j++) { if (dp[j] && wordDict.includes(s.substring(j, i))) { dp[i] = true; break; } } } return dp[s.length]; };",No,No,O(n^2),3
"const numSquares = (n) => { const dp = Array(n + 1).fill(Infinity); dp[0] = 0; for (let i = 1; i <= n; i++) { for (let j = 1; j * j <= i; j++) { dp[i] = Math.min(dp[i], dp[i - j * j] + 1); } } return dp[n]; };",No,No,O(n*sqrt(n)),3
"const permute = (nums) => { const result = []; const backtrack = (path) => { if (path.length === nums.length) result.push([...path]); for (const num of nums) { if (path.includes(num)) continue; path.push(num); backtrack(path); path.pop(); } }; backtrack([]); return result; };",No,No,O(n*n!),3
"const combine = (n, k) => { const result = []; const backtrack = (start, path) => { if (path.length === k) { result.push([...path]); return; } for (let i = start; i <= n; i++) { path.push(i); backtrack(i + 1, path); path.pop(); } }; backtrack(1, []); return result; };",No,No,O(nCk),3
"const rotateK = (matrix, k) => { const n = matrix.length; for (let i = 0; i < k; i++) rotateImage(matrix); };",No,No,O(k*n^2),3
"const maximumProduct = (nums) => { nums.sort((a, b) => a - b); return Math.max(nums[0] * nums[1] * nums[nums.length - 1], nums[nums.length - 1] * nums[nums.length - 2] * nums[nums.length - 3]); };",No,No,O(n log n),3
"const searchRange = (nums, target) => { const leftIndex = nums.indexOf(target); const rightIndex = nums.lastIndexOf(target); return [leftIndex, rightIndex]; };",No,No,O(n),3
